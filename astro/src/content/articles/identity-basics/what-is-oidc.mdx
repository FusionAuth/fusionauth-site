---
title: "What Is OIDC?"
description: "What Is OIDC, OpenID Connnect, And How Do You Use It?"
author: Dan Moore
icon: /img/icons/what-is-scim.svg
section: Identity Basics
date: 2023-12-10
dateModified: 2023-12-10
---
import OIDCFlow from "../../../diagrams/articles/identity-basics/oidc-flow.astro";
import Aside from '/src/components/Aside.astro';


OIDC, which stands for OpenID Connect, is a specification to allow users to authenticate using a standard protocol.

This article will cover what OIDC is, why you might want to use it, and how it works.

## What Is OIDC?

OIDC is a standard built on top of two different standards that solves the common problem of authenticating users. OIDC leverages both OAuth, which defines the data flow and specifics around token generation, and OpenID, which defines the authentication process.

It's an extremely flexible framework that can cover both simple authentication systems and complex large-scale systems. There is a core set of functionality defined in the specification as well as a fair amount of optional behavior and additional specifications handling use cases beyond authentication such as sign out and session management.

## What Does OIDC Allow?

At a high level, using OIDC lets you delegate user authentication in a standardized fashion. By running an OIDC compliant identity data store, other applications, including custom built apps, open source applications, commercial off the shelf apps, and SaaS solutions, can all use the same authentication solution.

For example, you could have your own application (custom-built), forum software like Discourse (open source), Oracle (COTS), and Zendesk all delegate authentication to your OIDC compliant user identity datastore.

## Why Would You Use OIDC?

Similar to other single sign-on software, using OIDC has the following benefits:

* your users have one set of credentials to manage
* you get a single view into your users, whether they are customers, free users or employees
* when you add layers of authentication security to your OIDC server, all applications benefit without any effort

OIDC is unique because:

* since it is a standard, many other applications support it
* it is widely deployed 
* it's built for web applications
* since it is built on OAuth, all OIDC flows automatically get an access token

Let's dive into some of the major pieces of OIDC.

## Clients, OIDC Providers and Relying Parties

OIDC has a few important components:

* An end user who is trying to get access to an application using a browser or omobile device.
* An OpenID provider (OP), by definition an OAuth 2.0 compatible authorization server, which will authenticate a user. It can also delegate authentication to other identity stores via OIDC or other protocols.
* A relying party (RP), an application that needs to identify the end user.

Here's an example OIDC flow, using the authorization code flow.

<OIDCFlow/>

## Tokens

Because OIDC is built on top of OAuth, an access token is always returned, but an Id token and possibly a refresh token are returned as well.

The Id token looks like this:

TODO include Id token

It is a signed JWT and must be validated. The claims inside the token can be examined by the RP to determine the identity of the user who went through the flow. 

<Aside type="note">
A claim is fancy term for a key and value pair in a JSON object.
</Aside>

There are a number of standard claims defined by the specification. Some of these reflect the authentication event and OP details. These include but are not limited to:

* `iss` which is the identifier of the issuer of the Id token. It's a URL like `https://example.com`.
* `aud` which is the identifier of the RP. Per the specification, it must be at least the `client_id` of the RP, but can include other identifiers.
* `exp` which is the expiration time of the Id token.
* `iat` which is the time at which the Id token was issued.
* `auth_time` which is the time the authentication event occurred.

There are also claims for user profile data. Here's an incomplete list:

* `sub` which is an identifier for the end user at the OP.
* `name` which is the full name, in a format displayable to humans.
* `preferred_username` which is a preferred username for use by the RP. This is not guaranteed to be unique.
* `email` which is the user's preferred email address, again, not guaranteed to be unique.
* `email_verified` which is `true` if the email address has been verified to be controlled by the end user, as defined by the OP.
* `locale` which is the end user's locale, like `en-US` or `fr-CA`.
* `phone_number` which is the user's preferred telephone number.
* `updated_at` the time the user's info was last updated.

All times are numbers representing the number of seconds since the unix epoch.

The `iss`, `sub`, `aud`, `exp`, and `iat` claims are required and should be present in every Id token. Every other claim is optional, though some are required if the RP requests it or the OP is configured in certain ways. 

You can see that you can get a decent amount of information about a user and their authentication from the OP. It's transmitted in the Id token, which must be validated to ensure that there's no funny business going on.

### Id Token Validation

As an RP, you must [validate the Id token](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation) you receive to ensure that the authentication event occurred at the correct OP in the correct manner. This is a multi step process:

* verify the signature (or encryption if the Id token is encrypted).
* ensure the `iss` claim matches the expected OP Issuer value.
* ensure the `aud` claim contains the RP `client_id`.
* validate that the time represented by the `exp` claim is in the future.

Because of the flexibility of OIDC, there may be other validation required if the RP requests certain profile data.

<Aside type="caution">
The combination of `iss` and `sub` claims is guaranteed to be unique and stable. Nothing else is. So if you are building an application and need a unique identifier for a user, make sure you use these.

The reason for this is that `sub` claim is, per the specification, guaranteed to be unique in any OP and never reassigned or changed. The `iss` claim is, again per the specification, a URL containing the `https` scheme and a hostname.
</Aside>

### What Next?

After validation, the RP can use the claims. It might use these in a number of different ways:

* create a record in its own datastore to attach application specific data to
* display the profile data to the end user; "Welcome Dan!"
* store off email address and phone number for later communication
* create a time-limited session for the user based on the `auth_time` claim

## Requesting Certain Data

The RP can request certain profile data. OIDC optionally uses scopes to determine the claims returned. 

The [following scopes are outlined by the specification](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims):

* `profile` which requests access to the users default profile claims. These are: `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, and `updated_at`. 
* `email` which requests access to the `email` and `email_verified` claims. 
* `address` which requests access to the `address` claim. 
* `phone` which requests access to the `phone_number` and `phone_number_verified` claims. 

An OP may support zero, one or more of these scopes.

These scopes are placed on the initial authorization request, just like any other OAuth scopes. So an RP can ask for just the `email` and `profile` scopes. Since the user has to consent to any information shared, requesting the minimum amount of profile data to fulfill the RP's needs is good practice.

## Response Types

OIDC supports a number of other response types, which determine what components of the system have access to the tokens and whether a refresh token can be requested. In general, however, using the `code` response type, which maps to the OAuth authorization code grant, is a good place to start.

## What's Outside the Scope of OIDC

OIDC specifies how the RP can delegate authentication to the OP. But there are no guarantees in the specification or in practice about how the user is authenticated. It may be authenticated with strong methods such as passkeys or weaker methods such as cookies. [From the specification](https://openid.net/specs/openid-connect-core-1_0.html#Authenticates):

> The methods used by the Authorization Server [OP] to Authenticate the End-User (e.g., username and password, session cookies, etc.) are beyond the scope of this specification.

The actual methods of authentication are defined and managed by the OP.

## OIDC and CIAM

As mentioned above, OIDC work well with CIAM systems, such as FusionAuth.

OIDC is useful when you are trying to standardize the authentication process across many applciations. Because it is a stadard, lots of application support OIDC as a RP. This is just as true for applications which customers use as those that employees use. 

Leveraging OIDC simplifies the authentication experience for your customers and also gives you a single view into their activities.

## Additional Resources

Here are additional resources:

* [An overview of the OIDC specification](https://openid.net/specs/openid-connect-core-1_0.html)
* [Additional OIDC related specifications](https://openid.net/developers/specs/)
* [The OpenID foundation website](https://openid.net/)
* [The foundational OAuth RFC](https://datatracker.ietf.org/doc/html/rfc6749)

