---
title: How service to service OAuth differs from user to service OAuth
description: How service to service OAuth differs from user to service OAuth
author: Richard Cooke
section: Authentication
tags: oauth, oauth2, service
icon: /img/icons/webauthn-explained.svg
darkIcon: /img/icons/webauthn-explained-dark.svg
---

import PremiumEditionBlurbApi from 'src/content/docs/_shared/_premium-edition-blurb-api.astro';

- [Introduction](#introduction)
- [Understand user login](#understand-user-login)
- [Understand machine login](#understand-machine-login)
- [Designing A FusionAuth Example](#designing-a-fusionauth-example)
  - [update customer type - can't](#update-customer-type---cant)
- [Why Not Use Only A Username And Password For Machine Authorization?](#why-not-use-only-a-username-and-password-for-machine-authorization)
- [Further Reading](#further-reading)
- [TODO](#todo)

## Introduction

This article explains how to use OAuth 2.0 and FusionAuth for service to service communication (which you can call machine OA). In other words, how to both provide and call an API programmatically, with no user logging in on a webpage.

<PremiumEditionBlurbApi />

## Understand user login

Let's start by summarizing how OAuth normally works for user login. You've most likely used FA for local login or third-party login. With local login, FA stores usernames and password hashes. With third-party login, another organization, like Google, handles authentication and FA is merely an intermediary. Either way, the authentication flow works as follows:

- A user (resource owner) clicks "Log in" on your website (client).
- Your site redirects the user to the URL (authorization endpoint) of the authorization server, which could either be FA directly, or another redirection to Google. This URL includes parameters for the Id of your site (client Id), the URL the user's browser should be sent to after logging in (redirect URI), the response type of code, and the permissions your site is requesting on behalf of the user (scopes).
- The user logs in and consents to the permissions requested on a page provided by the server.
- The authorization server redirects the browser back to your site (using the redirect URI), with a temporary authorization code.
- Your site then starts a separate HTTP call to the server directly (to the token endpoint). This is more secure than using the browser. Now your site can ask the server for a key (access token) to access the user's resources in future calls. In this call your site sends the temporary authorization code, your client Id, and your client secret. The server might instead return a refresh token with a long duration, which can be used to request access tokens with short durations. This enhances security and limits the damage caused if an attacker manages to steal an access token.

The protocol above is called a flow, specifically the authorization code flow. What the flow returns is called a grant — access to the requested scopes. The grant is represented by data like the client credentials and the access token. The word grant is often used interchangeably with the word flow, but that isn't strictly correct.

For a detailed overview of all OAuth flows, please read the [FusionAuth modern guide to OAuth](https://fusionauth.io/resources/the-modern-guide-to-oauth.pdf).

## Understand machine login

Let's move on from discussing users to discussing services. The OA flow for calling an API from a machine with no user login page is called the client credentials flow.

- Your app makes a POST request to the token endpoint of the authorization server, passing your `client_id`, `client_secret`, and `grant_type` with value `client_credentials` as form data.
- Since the app is requesting access to its own resources, not the resources of a user, no consent is required.
- The server will return JSON containing an access token and possibly a list of scopes.

This flow is much simpler than the user flow earlier, but there are still some design choices to be aware of. Both the client and the resource server have to trust the authorization server. So both parties must be registered users of the authorization server. Additionally, the resource server needs to trust that when any call is made to it with an access token, that that access token represents the permissions granted by a client. So the authorization server must sign the access token (encrypt a hash of the token with its private key). Without a signature, any client could create an access token claiming whatever permissions they wanted.

## Designing A FusionAuth Example

Imagine you are a backup service that allows customers to save files in your storage. Your free service allows a customer to store up to 100 MB and your premium service allows more than that. You have two customers currently: North University and North Hospital. Customers will authenticate with your API using the client credentials flow. This flow is provided in FusionAuth by Entities, not Users. Please read the [documentation on Entities and Entity Types](https://fusionauth.io/docs/get-started/core-concepts/entity-management) before proceeding.

Let's look at the implications of this scenario using FusionAuth:

- Your customers don't have to register on FusionAuth, or have any knowledge of it. It is only your service that needs be aware of FusionAuth, and that the Ids of customers and permissions between FusionAuth and the service database agree.
- When receiving an API call, your service needs to check only that the access token is signed by FusionAuth, that the caller is trying to access its own resorces, and the caller has permissions to perform the requested operation on those resources.
- A customer will change between free and premium. When working with individual users in FusionAuth, you could use roles, but entities do not support roles. How can you model this?

You can't use entity types for free and premium — one type for customers and one for premium customers — because you cannot change the type of an entity once it is created. Nor can entity types have default permissions to other entity types. Permissions are defined only between two entities.

Instead, you have two options:
- Write a script that calls the [FusionAuth Entity API](https://fusionauth.io/docs/apis/entities/entities#update-an-entity) and updates all permissions for an entity. Note that you will have to track which permissions premium customers should have and which permissions free customers should have, and which customers are of which type, outside FusionAuth. FusionAuth will have no concept of different customer types.
- Use the entity API to add a custom attribute of `premium` to premium customers. Then write a [Lambda](https://fusionauth.io/docs/extend/code/lambdas/client-credentials-jwt-populate) to check if the customer has the `premium` attribute at login, and add extra permissions to the JWT if it does. This option is more complex than the previous, but allows you to keep all customer type and permission information in one place, in FusionAuth.

Below is a diagram of the system you'll build in the next section.

```mermaid

```

api entity type and customer entity type

<Aside type="note">
entities cannot be used with users, only with other entities. https://github.com/FusionAuth/fusionauth-issues/issues/1295. so you can't model hospitals as entities, and have patients, admission staff, and doctors as users with different permissions to medical records at different hospitals.
</Aside>

### update customer type - can't

update type from customer to api

33052c8a-c283-4e96-9d2a-eb1215c69f8f-not-for-prod

40450891-0231-49c4-839b-b2c444f57f9c
NorthUniversity
40450891-0231-49c4-839b-b2c444f57f9c
EmQ3FL-rDqHuESnJCmZacFK3sKQbOKX-gQYnC5pPLio

PUT /api/entity/{entityId}

```sh
curl -X PUT \
  -H "Authorization: 33052c8a-c283-4e96-9d2a-eb1215c69f8f-not-for-prod" \
  -H "Content-Type: application/json" \
  -d '{
    "entity": {
      "clientId": "40450891-0231-49c4-839b-b2c444f57f9c",
      "clientSecret": "EmQ3FL-rDqHuESnJCmZacFK3sKQbOKX-gQYnC5pPLio",
      "type": {
        "id": "ba94d545-230b-4e9c-95f9-af87c8e97f80"
      },
      "name": "NorthUniversity"
    }
  }' \
  "http://localhost:9011/api/entity/40450891-0231-49c4-839b-b2c444f57f9c"
```

## Why Not Use Only A Username And Password For Machine Authorization?

advantages - manage permissions from apps to other apps in fusionauth web interface



When you've called an API, you've most likely used a username and password — which might be called an access token or an API key. This is simple and secure, so why complicate it by using OAuth when you don't need to worry about users anyway?

Credential Management & Rotation

- With basic auth, changing passwords requires updating all services using them
- OAuth allows you to rotate client secrets without service downtime
- You can revoke specific tokens without changing the main credentials

Fine-grained Access Control

- OAuth scopes let you limit what each service can do
Example: Service A might only need "read" access to users, while Service B - needs "write" access
- Basic auth is usually all-or-nothing access

Audit Trail & Monitoring

- OAuth tokens can be tracked individually
You can see which service accessed what and when
- With basic auth, multiple services sharing the same credentials are - indistinguishable

Standardized Security

- OAuth is a well-tested protocol with industry best practices
Many security tools and platforms are built to work with OAuth
- Basic auth lacks features like token expiration and scope control

Scalability

- As your system grows, OAuth makes it easier to manage hundreds of service-to-service connections
- Each service can have its own client credentials with specific permissions
- Basic auth becomes a maintenance nightmare at scale




- Client Credentials Grant flow, where the client application directly requests an access token using its client ID and secret. There is no user involved.
- Access tokens often have much shorter expiration times compared to user-granted OAuth tokens, since there is no user to re-authenticate.
- The client authentication can use a pre-established client ID and secret (symmetric key), or leverage public/private key pairs (asymmetric keys) for higher security.




## Further Reading

- [FusionAuth modern guide to OAuth](https://fusionauth.io/resources/the-modern-guide-to-oauth.pdf)

## TODO

OA OAuth
FA FusionAuth

    client credentials grant
    how to create/manage scopes
    how to think about on behalf of calls
    token expiration time
    what kind of signing key to use (symmetric? asymmetric?)

Have this playlist which helps some: https://www.youtube.com/watch?v=rT-VTtgligI&list=PLUOVyt5DYPpNzRdTKrio0P0a4mktqLPN9
