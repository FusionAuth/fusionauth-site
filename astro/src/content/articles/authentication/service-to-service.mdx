---
title: How service to service OAuth differs from user to service OAuth
description: How service to service OAuth differs from user to service OAuth
author: Richard Cooke
section: Authentication
tags: oauth, oauth2, service
icon: /img/icons/webauthn-explained.svg
darkIcon: /img/icons/webauthn-explained-dark.svg
---

import PremiumEditionBlurbApi from 'src/content/docs/_shared/_premium-edition-blurb-api.astro';
import Breadcrumb from 'src/components/Breadcrumb.astro';
import InlineField from 'src/components/InlineField.astro';
import InlineUIElement from 'src/components/InlineUIElement.astro';
import Aside from 'src/components/Aside.astro';

- [Introduction](#introduction)
- [Understand OAuth User Login](#understand-oauth-user-login)
- [Understand OAuth Machine Login](#understand-oauth-machine-login)
- [Designing A FusionAuth Example](#designing-a-fusionauth-example)
- [Why Not Use Only A Username And Password For Machine Authorization?](#why-not-use-only-a-username-and-password-for-machine-authorization)
- [Set Up A FusionAuth Machine-To-Machine OAuth Example](#set-up-a-fusionauth-machine-to-machine-oauth-example)
  - [Create Entity Types](#create-entity-types)
  - [Create Entities](#create-entities)
  - [Add Permissions To Customers](#add-permissions-to-customers)
  - [Create Customer Code To Get Access Token](#create-customer-code-to-get-access-token)
  - [Authenticate The Access Token](#authenticate-the-access-token)
- [curl Command To Update An Entity](#curl-command-to-update-an-entity)
- [Check The Updated Permissions](#check-the-updated-permissions)
- [Write A Lambda Function To Add The StoreLargeData Permission To Premium Customers](#write-a-lambda-function-to-add-the-storelargedata-permission-to-premium-customers)
- [Test The Lambda Code](#test-the-lambda-code)
- [Further Reading](#further-reading)
- [TODO](#todo)

## Introduction

This article explains how to use OAuth 2.0 and FusionAuth for service-to-service communication, also known as machine-to-machine OAuth. In other words, how to provide and call an API programmatically, with no user logging in on a webpage.

<PremiumEditionBlurbApi />

## Understand OAuth User Login

Let's start by summarizing how OAuth normally works for user login, which you're more familiar with than machine OAuth. You've most likely used FA for local login or third-party login. With local login, FA stores usernames and password hashes. With third-party login, another organization, like Google, handles authentication and FA is merely an intermediary. Either way, the authentication flow works as follows:

- A user (resource owner) clicks "Log in" on your website (client).
- Your site redirects the user to the URL (authorization endpoint) of the authorization server, which could either be FA directly, or another redirection to Google. This URL includes parameters for the Id of your site (client Id), the URL the user's browser should be sent to after logging in (redirect URI), the response type of code, and the permissions (scopes) your site is requesting on behalf of the user.
- The user logs in and consents to the permissions requested on a page provided by the server.
- The authorization server redirects the browser back to your site (using the redirect URI), with a temporary authorization code.
- Your site then starts a separate HTTP call to the server directly (to the token endpoint). This is more secure than using the browser, where the access token might be stolen. Now your site can ask the server for a key (access token) to access the user's resources in future calls. In this call your site sends the temporary authorization code, your client Id, and your client secret. The server might instead return a refresh token with a long duration, which can be used to request access tokens with short durations. This enhances security and limits the damage caused if an attacker manages to steal an access token.

The protocol above is called a flow, specifically the authorization code flow. What the flow returns is called a grant — access to the requested scopes. The grant is represented by data like the client credentials and the access token. The word grant is often used interchangeably with the word flow, but that isn't strictly correct.

For a detailed overview of all OAuth flows, please read the [FusionAuth modern guide to OAuth](https://fusionauth.io/resources/the-modern-guide-to-oauth.pdf).

## Understand OAuth Machine Login

Let's move on from discussing users to discussing services. In OAuth, the flow for calling an API from a machine with no user login page is called the client credentials flow.

- Your app makes a POST request to the token endpoint of the authorization server, passing your `client_id`, `client_secret`, and `grant_type` with value `client_credentials` as form data.
- Since the app is requesting access to its own resources, not the resources of another user, no consent is required.
- The server will return JSON containing an access token and possibly a list of scopes.

This flow is much simpler than the user flow earlier, but there are still some design choices to be aware of. Both the client and the resource server have to trust the authorization server. So both parties must be registered users of the authorization server. Additionally, the resource server needs to trust that when any call is made to it with an access token, that that access token represents the permissions granted by a client. So the authorization server must sign the access token (encrypt a hash of the token with its private key). Without a signature, any client could create an access token claiming whatever permissions they wanted.

## Designing A FusionAuth Example

Imagine you sell a file backup service that allows customers to save files in your storage. Your free service allows a customer to store up to 1 GB and your premium service allows more than that. You have two customers currently: North University and North Hospital. You want to start using OAuth authentication through FusionAuth. Customers will authenticate with your API using the client credentials flow. This flow is provided in FusionAuth by Entities, not Users. Please read the [documentation on Entities and Entity Types](https://fusionauth.io/docs/get-started/core-concepts/entity-management) before proceeding.

Let's look at the implications of this scenario:

- Your customers don't have to register on FusionAuth, or use the web interface. To them, FusionAuth is merely a generic OAuth endpoint they call to get an access token. However, both your server and all clients need to know their Ids in FusionAuth, ,the Ids of the API to which they want access, and which permissions they have.
- When receiving an API call, your service needs to check that the access token is signed by FusionAuth, that the caller is trying to access its own resorces, and the caller has permissions to perform the requested operation on those resources.
- A customer will change between free and premium. When working with individual users in FusionAuth, you could use roles, but entities do not support roles. How can you model this?

You can't use entity types for free and premium — one type for customers and one for premium customers — because you cannot change the type of an entity once it is created. Nor can entity types have default permissions to other entity types. Permissions are defined only between two entities.

Instead, you have two options:
- Write a script that calls the [FusionAuth Entity API](https://fusionauth.io/docs/apis/entities/entities#update-an-entity) and updates all permissions for an entity. Note that you will have to track which permissions premium customers should have and which permissions free customers should have, and which customers are of which type, outside FusionAuth. FusionAuth will have no concept of different customer types.
- Use the entity API to add a custom attribute of `premium` to premium customers. Then write a [Lambda](https://fusionauth.io/docs/extend/code/lambdas/client-credentials-jwt-populate) in FusionAuth to check if the customer has the `premium` attribute at login, and if so, add extra permissions to the access token returned to the customer. This option is more complex than the previous one, but allows you to keep all customer type and permission information in one place, in FusionAuth.

Below is a diagram of the system you'll build in this guide, using two entity types: API and Customer.

```mermaid
graph LR
  n1("NorthHospital (Customer)") --> |Send token, store files| n2("FileApi (API)")
  n3("NorthUniversity (Customer)") --> |Send token, store files| n2
  n4(FusionAuth)
  n1 --> |Get token| n4
  n2 --> |Verify token|n4
  n3 --> |Get token|n4
```

<Aside type="note">
Entities can be used only with other entities, [not with users](https://github.com/FusionAuth/fusionauth-issues/issues/1295). So you can't model hospitals as entities, and have patients, admission staff, and doctors as users with different permissions to medical records at different hospitals. For that situation, you need to have a hospital as an application, with doctors and patients as roles for users. You would also need to add the hospital as an entity if you wanted external services to call it as an API. But the hospital as an entity and the hospital as an application are completely separate in FusionAuth, and changes to each would need to be duplicated.
</Aside>

## Why Not Use Only A Username And Password For Machine Authorization?

Before looking at how to code this example, you might be wondering: why bother with the complexity of OAuth and access tokens, instead of giving customers a username and password? Firstly, calling an endpoint to get an access token, and sending that with API calls instead of the password directly, is only one extra step. So it's not much more work for customers. There are also several advantages:
- You can manage entities and permissions in one place — the FusionAuth web interface.
- Customers can store the client secret (password) very securely, and give only the access token to services that make API calls. In the event this token is exposed to attackers, it can be immediately revoked through an OAuth endpoint, without needing to change the client secret. Since access tokens expire, you also have password rotation by default.
- Basic authentication with a password usually gives an API caller full rights to do anything. With OAuth, you can issue a token with only certain permissions.
- Access tokens can be logged individually. You can see which service accessed what resource and when. With basic authentication, different services sharing the same customer username and password are indistinguishable.

## Set Up A FusionAuth Machine-To-Machine OAuth Example

In this section, you'll learn how to set up FusionAuth to create the API and customer example. This guide needs only Docker. To follow along, download and unzip the repository (or use `git clone`) at https://github.com/FusionAuth/fusionauth-example-docker-compose.

Open a terminal in the `light` subdirectory. All commands will be run here.

### Create Entity Types

- First, start FusionAuth by running `docker compose up`, and wait a minute for all services to initialize.
- In a web browser, browse to the FusionAuth web interface at http://localhost:9011.
- In the sidebar, browse to <Breadcrumb>Reactor</Breadcrumb>, and authorize your paid FusionAuth features by entering your key.
- In the sidebar, open </Breadcrumb>Entity Management -> Entity Types</Breadcrumb>.
- Click the <InlineUIElement>Add</InlineUIElement> button to create a new type.
- Enter `Customer` for <InlineField>Name</InlineField>. (You don't need to enter a specific UUID, because you won't be altering entity types in scripts.)
- In the <InlineUIElement>JWT</InlineUIElement> tab, enabled <InlineUIElement>Enabled<InlineUIElement> and set the <InlineUIElement>Access token signing key<InlineUIElement> to `RS256`.
- Click <InlineUIElement>Save<InlineUIElement> at the top right.
- You have just created a new Entity Type, `Customer`, that will be the type of all customers using your API, both premium and free.
- Repeating the steps above, add a new entity type with the name `API`.
  - You don't need to change the JWT signing algorithm here, because the API doesn't ever create access tokens — it only verifies tokens from clients.
  - This time, before saving, add the following permissions in the <InlineUIElement>Permissions<InlineUIElement> tab: `Create`, `Read`, `Update`, `StoreLargeData`.
  - Save.

![Entity types in FusionAuth](../../../../public/img/articles/authentication/service-to-service/types.webp)

<Aside type="note">
All OAuth providers expose their public keys at the standard endpoint: http://localhost:9011/.well-known/jwks.json (on different domains though, of course). FusionAuth exposes apps' public keys at this endpoint, such as the `RS256` one you used above. This public key is used for any service to check that an access token it received was truly signed by FusionAuth. But FusionAuth doesn't expose the default signing key, an `HS256` one, so you actually can't use the default key for access tokens. This is why you changed the JWT key in the instructions above.
</Aside>

### Create Entities

- In the sidebar, open <Breadcrumb>Entity Management -> Entites</Breadcrumb>.
- Click the <InlineUIElement>Add</InlineUIElement> button to create a new entity.
- Enter the following values:
  - <InlineField>Id</InlineField> — `09a00bb3-5099-4eff-af10-a1c139e847f9`
  - <InlineField>Name</InlineField> — `FileApi`
  - <InlineField>Client Id</InlineField> — `09a00bb3-5099-4eff-af10-a1c139e847f9`
  - <InlineField>Client Secret</InlineField> — `fDt7Pn5s3FymamBobVUxUtDwggxNpW1iyaujCOZjX6E`
  - <InlineField>Entity Type</InlineField> — `API`
- Save.

This API entity represents the single server that all customers will upload files to.

![FileApi](../../../../public/img/articles/authentication/service-to-service/fileapi.webp)

- Click the <InlineUIElement>Add</InlineUIElement> button to create a new entity.
- Enter the following values:
  - <InlineField>Id</InlineField> — `de085100-893e-463d-9641-a96c265b1f6c`
  - <InlineField>Name</InlineField> — `NorthHospital`
  - <InlineField>Client Id</InlineField> — `de085100-893e-463d-9641-a96c265b1f6c`
  - <InlineField>Client Secret</InlineField> — `_snp1-t_0ec5Tm9gj3RBoH-LNmZlqS4mVorcBPoF5go`
  - <InlineField>Entity Type</InlineField> — `Customer`
- Save.

- Click the <InlineUIElement>Add</InlineUIElement> button to create a new entity.
- Enter the following values:
  - <InlineField>Id</InlineField> - `40450891-0231-49c4-839b-b2c444f57f9c`
  - <InlineField>Name</InlineField> - `NorthUniversity`
  - <InlineField>Client Id</InlineField> - `40450891-0231-49c4-839b-b2c444f57f9c`
  - <InlineField>Client Secret</InlineField> - `EmQ3FL-rDqHuESnJCmZacFK3sKQbOKX-gQYnC5pPLio`
  - <InlineField>Entity Type</InlineField> - `Customer`
- Save.

<Aside type="note">
Note that the client Ids and FusionAuth Ids are the same for each entity by default. This makes it easier to match entities between your API database and FusionAuth.
</Aside>

You are not saying anything about premium customers yet, except to have the `StoreLargeData` attribute in the API type.

### Add Permissions To Customers

- In the <InlineUIElement>Entities</InlineUIElement> screen, click <InlineUIElement>Manage</InlineUIElement> for `NorthUniversity`.
- In the <InlineUIElement>Entity grants</InlineUIElement> tab at the bottom, click <InlineUIElement>Add</InlineUIElement>.
- Type `api` in the search box and select <InlineUIElement>FileApi</InlineUIElement>.
- Enable all permissions except `StoreLargeData` and click <InlineUIElement>Save</InlineUIElement>.

The university now has permissions to add and update files through the API. The hospital has no permissions. Both customers are free customers, not premium, and don't have the `StoreLargeData` permission.

### Create Customer Code To Get Access Token

You are ready to get access tokens from FusionAuth as a Customer, and verify tokens as the API.

- Create a file called `customer.mjs`.
- Add the code below to get the access token for NorthUniversity.
  ```js
  import axios from "axios";

  async function getAccessToken() {
    try {
      const formData = new URLSearchParams();
      formData.append("grant_type", "client_credentials");
      formData.append("client_id", "40450891-0231-49c4-839b-b2c444f57f9c");
      formData.append("client_secret", "EmQ3FL-rDqHuESnJCmZacFK3sKQbOKX-gQYnC5pPLio");
      formData.append("scope", "read create update");

      const response = await axios({
        method: "post",
        url: "http://localhost:9011/oauth2/token",
        headers: { "Content-Type": "application/x-www-form-urlencoded"},
        data: formData,
      });

      console.log("Access Token:", response.data.access_token);
      return response.data.access_token;
    } catch (error) {
      console.error("Error getting access token:", error.response?.data || error.message);
      throw error;
    }
  }

  await getAccessToken();
  ```
- Run the command below in a terminal to make the JavaScript above get a token.
  ```sh
  docker run --rm -v ".:/app" -w "/app" node:23-alpine3.19 sh -c  \
  "npm install axios jsonwebtoken jwks-rsa"
  docker run --rm --network host -v ".:/app" -w "/app" node:23-alpine3.19 sh -c  \
  "node customer.mjs"

  # Output
  # Access Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImd0eSI6WyJjbGllbnRfY3JlZGVudGlhbHMiXSwia2lkIjoiOGE3NWQ3YzkzIn0.eyJleHAiOjE3MzA0NjQ1MzIsImlhdCI6MTczMDQ2MDkzMiwiaXNzIjoiYWNtZS5jb20iLCJzdWIiOiI0MDQ1MDg5MS0wMjMxLTQ5YzQtODM5Yi1iMmM0NDRmNTdmOWMiLCJqdGkiOiI0ZWRkOGRjMy04YjAwLTQ2YTktOWZhNy1lNTY2YmE2ZGU4ZDUiLCJ0aWQiOiJkN2QwOTUxMy1hM2Y1LTQwMWMtOTY4NS0zNGFiNmM1NTI0NTMifQ.a46p7gVAHKOM4yPIPrvc_WzEd7AdToWPwR0Xguaoxyg
  ```
- Paste the token from your terminal into the textbox on the page at https://fusionauth.io/dev-tools/jwt-decoder.
  ![Decoded JWT](../../../../public/img/articles/authentication/service-to-service/jwt.webp)
- Below is what each of the fields means:
  ```js
  {
    "alg": "HS256",      // Algorithm used for signing the token (HMAC SHA-256)
    "typ": "JWT",        // Type of token (JSON Web Token)
    "gty": [             // Grant type used to obtain this token
      "client_credentials"
    ],
    "kid": "8a75d7c93"   // Key ID - identifies which key was used to sign this token
  }
  {
    "exp": 1730464532,   // Expiration time (Unix timestamp when token expires)
    "iat": 1730460932,   // Issued At (Unix timestamp when token was issued)
    "iss": "acme.com",   // Issuer (who created and signed this token)
    "sub": "40450891-0231-49c4-839b-b2c444f57f9c",  // Subject (whom the token refers to, in this case the client ID)
    "jti": "4edd8dc3-8b00-46a9-9fa7-e566ba6de8d5",  // JWT ID (unique identifier for this token)
    "tid": "d7d09513-a3f5-401c-9685-34ab6c552453"   // Tenant ID (if using multi-tenancy)
  }
  ```

### Authenticate The Access Token

The API needs to authenticate the access token is really from FusionAuth, rather than being sent by an attacker.



  ```js
  Token verification result: {
    active: true,
    exp: 1730466482,
    iat: 1730462882,
    iss: 'acme.com',
    jti: '7cc7151c-aa32-4d4b-b602-072a8584f052',
    sub: '40450891-0231-49c4-839b-b2c444f57f9c',
    tid: 'd7d09513-a3f5-401c-9685-34ab6c552453'
  }
  ```

## curl Command To Update An Entity

Let's run a script to remove the `Read` permission for the API from North University and give it the premium functionality of `StoreLargeData`. Removing the read permission will allow you to test if access tokens really work. The documentation for the grants (permissions) API is [here](https://fusionauth.io/docs/apis/entities/grants#grant-a-user-or-entity-permissions-to-an-entity).

For all APIs, you would expect that the URL refers to the object you are updating, such as `http://localhost:9011/api/entity/09a00bb3-5099-4eff-af10-a1c139e847f9` updating the FileAPI in the code below. But in this FusionAuth API, it's backwards — the Id in the URL is where the permissions point to, and the Id of the object that's actually being updated is inside the JSON, `"recipientEntityId": "40450891-0231-49c4-839b-b2c444f57f9c" `.

```sh
curl -X PUT \
  -H "Authorization: 33052c8a-c283-4e96-9d2a-eb1215c69f8f-not-for-prod" \
  -H "Content-Type: application/json" \
  -d '{
    "grant": {
      "permissions": [
        "Create",
        "Update",
        "StoreLargeData"
      ],
      "recipientEntityId": "40450891-0231-49c4-839b-b2c444f57f9c"
    }
  }' \
  "http://localhost:9011/api/entity/09a00bb3-5099-4eff-af10-a1c139e847f9/grant"
```

The script above is a manual way to change a customer's permissions from free to premium.

Next you're going to run another script to add the `premium` attribute to the North University entity. This allows you to manually add permissions to the access token in a lambda, as discussed earlier. This API is documented [here](https://fusionauth.io/docs/apis/entities/entities#update-an-entity).

```sh
curl -X PATCH \
  -H "Authorization: 33052c8a-c283-4e96-9d2a-eb1215c69f8f-not-for-prod" \
  -H "Content-Type: application/json" \
  -d '{
    "entity": { "data": { "premium": true } }
  }' \
  "http://localhost:9011/api/entity/40450891-0231-49c4-839b-b2c444f57f9c"
```

If you view North University in the FusionAuth web interface entities screen, you'll see it now has updated data and permissions.

## Check The Updated Permissions

Run the customer script from before and you will now see it immediately fail, as expected, because the university requests read permissions to the file API, but they were removed in FusionAuth.

```sh
docker run --rm --network host -v ".:/app" -w "/app" node:23-alpine3.19 sh -c  \
  "node customer.mjs"

# Output: error_description: 'Invalid target-entity scope. The permission names [Read] are invalid.',
```

In `customer.js`, replace the request for the read permission, `"target-entity:09a00bb3-5099-4eff-af10-a1c139e847f9:Read",` with the large data permission, `"target-entity:09a00bb3-5099-4eff-af10-a1c139e847f9:StoreLargeData",`, and rerun the code. It should run successfully again, and in the decoded token you can see the access token now have premium permissions.

## Write A Lambda Function To Add The StoreLargeData Permission To Premium Customers

- In the FA web interface sidebar, browse to Customizations -> Lambdas.
- Click the + button at the top right.
- For name, enter `PremiumPermissions`.
- For type, choose `Client credentials JWT populate`
- Enter the code below and save the new lambda.
  ```js
  function populate(jwt, recipientEntity, targetEntities, permissions) {
    if (recipientEntity.data && recipientEntity.data.premium) {
      if (typeof targetEntities === "object") {
        var targetId = Object.keys(targetEntities)+""; //convert to string
        jwt.scope += ' target-entity:' + targetId + ':StoreLargeData';
      }
    }
  }
  ```
- Browse to Tenants in the sidebar.
- Click the Edit button for the default tenant.
- Select the OAuth tab.
- For Client credentials populate lambda, select PremiumPermissions lambda you just created.
- Click Save at the top right.

Now FusionAuth will run your custom code whenever returning an access token to a client. If the entity has the attribute `premium`, which you added earlier, then the client will be given the `StoreLargeData` permission to the entity it is requesting permission for.

## Test The Lambda Code

Before testing that the lambda populates `StoreLargeData` for North University, you first need to remove the permission you added earlier using the script. Return to the entities screen in FusionAuth and remove the permission there.

In `customer.mjs`, you also need to remove `target-entity:09a00bb3-5099-4eff-af10-a1c139e847f9:StoreLargeData`, because that permission is no longer explicitly set for the entity. If you try to request it from FusionAuth, you will receive an error. Instead, the lambda function will now automatically append the large data permission to any premium customers.

Run the customer script in the terminal again. Note below the permission added the end of the `scope` line by the lambda.

```sh
docker run --rm --network host -v ".:/app" -w "/app" node:23-alpine3.19 sh -c  \
  "node customer.mjs"

# Output:

Access Token: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImd0eSI6WyJjbGllbnRfY3JlZGVudGlhbHMiXSwia2lkIjoibnFSODVDNG9YTHpPX05vNnBDTEc4VEE3dW1ZIn0.eyJhdWQiOiIwOWEwMGJiMy01MDk5LTRlZmYtYWYxMC1hMWMxMzllODQ3ZjkiLCJleHAiOjE3MzA4MDI5NjMsImlhdCI6MTczMDgwMjkwMywiaXNzIjoiYWNtZS5jb20iLCJzdWIiOiI0MDQ1MDg5MS0wMjMxLTQ5YzQtODM5Yi1iMmM0NDRmNTdmOWMiLCJqdGkiOiI2MzRmOGVkNy00Mjg1LTRkODktOTIyYS03OTZiYjExNDVmNzciLCJzY29wZSI6InRhcmdldC1lbnRpdHk6MDlhMDBiYjMtNTA5OS00ZWZmLWFmMTAtYTFjMTM5ZTg0N2Y5OkNyZWF0ZSB0YXJnZXQtZW50aXR5OjA5YTAwYmIzLTUwOTktNGVmZi1hZjEwLWExYzEzOWU4NDdmOTpVcGRhdGUgdGFyZ2V0LWVudGl0eTowOWEwMGJiMy01MDk5LTRlZmYtYWYxMC1hMWMxMzllODQ3Zjk6U3RvcmVMYXJnZURhdGEiLCJ0aWQiOiJkN2QwOTUxMy1hM2Y1LTQwMWMtOTY4NS0zNGFiNmM1NTI0NTMiLCJwZXJtaXNzaW9ucyI6eyIwOWEwMGJiMy01MDk5LTRlZmYtYWYxMC1hMWMxMzllODQ3ZjkiOlsiVXBkYXRlIl19fQ.OKVjv5ygZX5wYjilkStco3QClc4zdOyObFu5NPfMonZsfAoMnWaIQbOvy7NN30P5YpRfJCfY5TWS4vwUJKbRZum8xnihkj7lIMYLfWt6lCbEIEH08PVU_X1MxKD1nlsDJNsvuqPzyhpFXUYNRXtlOJyGc7D-qD4tQ_vjMjlhfIL0fru1m7yte7RO7FUMHCd3vbyU8ZbG8JL74ahpijkGpWcusO96ouYbWAnvDYJu_2OHDbI5Yo1CPtQW9dNELbBXzjk4vFe4BCp46LsEH9m2lc-yj82EJ-ICr6LJ_Gi17sFD_slLAYREYP8bGTOD6Hu_kcuPWoZsrmKU515CsGaI0A
{
  aud: '09a00bb3-5099-4eff-af10-a1c139e847f9',
  exp: 1730802963,
  iat: 1730802903,
  iss: 'acme.com',
  sub: '40450891-0231-49c4-839b-b2c444f57f9c',
  jti: '634f8ed7-4285-4d89-922a-796bb1145f77',
  scope: 'target-entity:09a00bb3-5099-4eff-af10-a1c139e847f9:Create target-entity:09a00bb3-5099-4eff-af10-a1c139e847f9:Update target-entity:09a00bb3-5099-4eff-af10-a1c139e847f9:StoreLargeData',
  tid: 'd7d09513-a3f5-401c-9685-34ab6c552453',
  permissions: { '09a00bb3-5099-4eff-af10-a1c139e847f9': [ 'Update' ] },
  active: true
}

xray.jpg stored successfully
```

<Aside type="hint">
If you encounter errors in lambdas, you can enable the debug switch, add `console.log(` statements, and see their output in System -> Event log.
<Aside>

## Further Reading

- [FusionAuth modern guide to OAuth](https://fusionauth.io/resources/the-modern-guide-to-oauth.pdf)
- https://fusionauth.io/docs/lifecycle/authenticate-users/oauth/endpoints
- https://fusionauth.io/docs/lifecycle/authenticate-users/oauth/endpoints#introspect

## TODO

OA OAuth
FA FusionAuth

FIX error that won't allow you to use server client id to call the introspect endpoint

    client credentials grant
    how to create/manage scopes
    how to think about on behalf of calls
    token expiration time
    what kind of signing key to use (symmetric? asymmetric?)

<Breadcrumb>
<InlineField>
<InlineUIElement>