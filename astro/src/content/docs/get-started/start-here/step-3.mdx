---
title: "Step 3 - Protected pages"
description: Learn how to use FusionAuth by using an example application that has a protected page defined.
section: get started
subcategory: start here
navOrder: 0
codeRoot: https://raw.githubusercontent.com/fusionauth/fusionauth-example-express-start-here/main
---

<div className="border border-green-700 px-3 rounded-md">
  <i className="fa-duotone fa-stopwatch fa-2x mr-2 text-green-700 align-middle"/> Estimated time to complete this step: **5 minutes**
</div>

## Protecting pages

Now that we have the FusionAuth and the example app running, let's take a look at how the application protects pages that require a user to be logged in.

Open the file `app/src/index.mts` and find the route named `/account`. It should look something like this:

```typescript
app.get("/account", async (req, res) => {
  if (!await sdk.userHasAccess(req, res, ["admin", "user"])) {
    res.redirect(302, '/login');
    return;
  }

  res.sendFile(path.join(__dirname, '../templates/account.html'));
});
```

The first check is where the application determines if the user is logged in or not. This is done by calling the SDK function `userHasAccess` (you can ignore the last parameter, which we will cover in the next section). This function returns true if the user has access, which implicitly verifies that they are logged in. Let's take a look at this function.

Open the file `app/src/sdk.ts` and find the function named `userHasAccess`. One note is that this application app uses `jose` which is a Node library used for validating and parsing JWT. If you want to learn more about `jose`, you can visit the project at Github here: https://github.com/panva/jose

The `userHasAccess` method begins by loading the user from the request. This is accomplished by calling the `getUser` function of the SDK. If the user comes back `null`, then this function returns false.

```typescript
async userHasAccess(req: Request, res: Response, roles: Array<string>): Promise<boolean> {
  const jwt = await this.getUser(req, res);

  // ...
}
```

Let's take a quick peek at the `getUser` function of the SDK. This function looks like this:

```typescript
let accessToken = req.cookies[this.configuration.accessTokenCookieName];
if (!accessToken) {
  return null;
}

let payload: JWTPayload;
try {
  payload = (await jose.jwtVerify(accessToken, this.JWKS, {
    issuer: this.configuration.oauthIssuer,
    audience: this.configuration.applicationId,
  })).payload;
} catch (e) {
  // ...
}
```

This function loads a cookie from the request that contains the user's access token. The access token is part of the OAuth specification and FusionAuth access tokens are also JWTs. The second part of this function verifies that the JWT is valid using `jose`'s `jwtVerify` function. This function validates the cryptographic signature of the JWT and also ensures that the JWT is not expired and all of the claims are valid.

We won't go into detail about JWTs and all of the claims here, but you can read our [OAuth token documentation](http://localhost:3000/docs/lifecycle/authenticate-users/oauth/tokens) to learn more.

Finally, this code handles refreshing the access token if it has expired. This is handled in the `catch` block of the function. We won't go into detail about refreshing access tokens here, but this pattern is the standard way that FusionAuth recommends handling user sessions. If you want more details about refreshing access tokens, you can review our [OAuth documentation](/docs/lifecycle/authenticate-users/oauth/).

If the `getUser` function returns `null`, this means that the user is not logged in. The user is then redirected to the login page.

You can also take a look at the `/make-change` route and you'll find that it uses this same approach to ensure that the user is logged in.

In the next step, we'll expand on this and cover role-based access controls.

## Next steps

[\< Go back to step 2 - Login button](step-2) <span class="inline-block mx-6 font-bold">Ready for the next step?</span> [Step 4 - Role-based access controls \>](step-4)


