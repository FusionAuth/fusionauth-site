---
title: Machine To Machine Communication
description: Allow services and software to securely authenticate using FusionAuth
section: get started
subcategory: use cases
---
import APIRequestDiagram from 'src/diagrams/docs/get-started/use-cases/machine-to-machine/api-request.astro';
import M2MCommunicationDescription from 'src/content/docs/get-started/use-cases/_m2m-communication-description.mdx';
import Breadcrumb from 'src/components/Breadcrumb.astro';
import InlineField from 'src/components/InlineField.astro';
import {RemoteCode} from '@fusionauth/astro-components';
import DataFieldDataTypeChanges from 'src/content/docs/_shared/_data-field-data-type-changes.mdx';

## Overview

<M2MCommunicationDescription />

## Problem 

You have software programs, devices or APIs which need to authenticate using the Client Credentials grant and use the corresponding tokens.

You want to let each of the programs have specific permissions and have them all managed by FusionAuth.

## Solution

With the machine to machine (m2m) use case, you model everything inside FusionAuth using Entity Management. Each entity can have permissions against any other entity.

Once you have an entity, you can use the Client Credentials grant to get an access token. This access token can be presented to another piece of software which can validate it and determine if the request is allowed.

## Prerequisites

You have at least two pieces of software that need to securely communicate with each other without any human intervention.

You want to use FusionAuth to create access tokens that can be used to authenticate one machine to another.

## Example Scenario

Suppose you have a hardware business selling internet enabled clock radios. The radio ships with the ability to tell time and tune into the FM stations, but you want recurring revenue as well, so you offer two upsells, a news API and weather API. 

The user can subscribe and provide their zip code. Then the user can press a button on their clock radio for either news or weather.

Basic subscriptions only get weather, and premium plans get news and weather

In this case, you need to tie each radio to a plan. Since users might change from no plan to basic to premium, or vice versa, you also need to have it change over time.

## Actors/Components

* weather API which returns weather
* news API which returns news
* clock radios
* FusionAuth

## Implementation Steps

This is an TODO step implementation process to ensure customers can access all the applications. Steps to take:

Here's the initial set up.

* set up the entity types and permissions
  * APIType with two possible permissions, `news` and `weather`
  * ClockRadioTyp with zero permissions
* set up the API entity

For each clock radio, create a digital twin in an entity:

* create an entity
* set up the proper grants to the API. Include permissions as dictated by the plan.
* put the plan name and the user id in clock radio `data` field for easy searching
* distribute the client Id and secret to the hardware of each clock radio

For each time the user presses the news/weather button:
* the radio retrieves its client Id and secret
* the radio chooses to ask permission for either `weather` or `weather` and `news`
* the radio presents the Id, secret and permission to FusionAuth 
* if the radio doesn't have a plan that supports the permission, an error is returned
* if the radio has a plan, an access token is returned
* the access token is presented to the APIs along with the data request
* the APIs validate the token and return the data
* the radio displays the data

When the plan changes:
* look up the entity representing the radio
* update the plan name in the `data` field
* update the permissions to reflect the new plan

The next time the radio makes a request, the access token will only be granted for the appropriate permissions.

### Why Not Use API Keys

Before you dive into implementation, you might be wondering about API keys. The access token generated by the Client Credentials grant is essentially an API key, proving the clock radio's identity and access. Why not give a static API key to each clock radio and call it good?

By using an access token for machine to machine communication, you get the following benefits:

* the access token is timebound and expires; if someone steals it, they only get limited access to the API
* it's standards based and developers with OAuth experience can reason about it
* the client Id and secret are centrally managed and monitored, but the access tokens can be validated without contacting FusionAuth
* you can include granular permissions and other data within the token

### Setting Up Entity Types

Entity types define permissions. Since you need to know which permissions the radios can make against the APIs, define all your permissions here.

The radio entity type doesn't need any permissions, since nothing is granted permissions against it.

![Entity types for digital twins.](/img/docs/get-started/use-cases/m2m-entity-types.png)

### Creating The Digital Twin

This is something that you should write code for, using [one of the SDKs](/docs/sdks), because you need to do this for every radio.

You'll need to [create an API key](/docs/apis/authentication#api-key-authentication) to automate this.

Here's example code to create the entity and then grant the `news` permission:

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-example-machine-to-machine/refs/heads/main/create-entity/create-entity.js" />

### Making The API Request

When the radio is ready to make the API request, it needs to obtain an access token by communicating with FusionAuth. Then it will make a call against the appropriate API. The API can then validate the token and return the data as needed.

Here's a diagram outlining this request.

<APIRequestDiagram alt="A clock radio making an API request." />

You obtain the access token using [the Client Credentials grant](/docs/lifecycle/authenticate-users/oauth/#example-client-credentials-grant). You validate the access token, which is a JWT, using a library to check the signature and the other claims. Our quickstarts have [examples of how to validate the access token in an API](/docs/quickstarts/#api) across a number of languages.

You can also modify the body of the access token by using a [Client Credentials JWT Populate lambda](/docs/extend/code/lambdas/client-credentials-jwt-populate).

### Changing The Plan

When the user changes their plan, you can update the entity's permissions. Here's sample code to update the plan and permissions.

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-example-machine-to-machine/refs/heads/main/update-plan/update-plan.js" />

The next time an API request is made, the updated permissions will be included in the access token.

## Expected Outcome

Your devices have a digital twin that can be used to manage device authentication and authorization against your APIs and services.

You can change the permissions and capabilities of these devices over time.

## Edge Cases

The admin UI for managing entities can be difficult to use. It's a good idea to use the admin UI to explore the functionality but use the SDKs or API to manage entities in production.

No "on behalf of" semantics are currently supported, where three or more machines communicate in sequence. [Read more on the GitHub issue](https://github.com/FusionAuth/fusionauth-issues/issues/1471).

You can rotate client secrets, but you cannot change the entity Id. If you need to modify that value, create an new entity. Entity Ids are always UUIDs.

The token generated by the Client Credentials grant has a `gty` claim in the header. For some consuming APIs, this may cause a problem. [Read more on the GitHub issue](https://github.com/FusionAuth/fusionauth-issues/issues/2886).

Introspection by an API of the access token obtained via a Client Credentials grant doesn't work as expected. [More details in this GitHub issue](https://github.com/FusionAuth/fusionauth-issues/issues/3010). The workaround is to validate the access token directly, rather than using introspection.

### Limits On The Data Field

<DataFieldDataTypeChanges />

## Other Example Scenarios

Whenever software talks to software without a human in the mix, machine to machine communication is happening. Examples include:

* APIs calling other APIs in a microservices based application
* A cron job making calls against a protected service every night at 11pm
* CI/CD pipelines where you are making calls against remote services to, for example, push a container image
* Authentication for developers building on your platform, with the client Id and secret being shared in your developer portal

## Additional Documentation

* [An example Client Credentials grant](/docs/lifecycle/authenticate-users/oauth/#example-client-credentials-grant)
* [Examples of how to validate the access token in an API](/docs/quickstarts/#api)
* [Entity management](/docs/get-started/core-concepts/entity-management)
* [Lambda to customize the body of the access token](/docs/extend/code/lambdas/client-credentials-jwt-populate)
* [Videos on using the Client Credentials grant for API authentication](https://www.youtube.com/watch?v=rT-VTtgligI&list=PLUOVyt5DYPpNzRdTKrio0P0a4mktqLPN9)
* [Securing your API blog post](/blog/securing-your-api)

[//]: # (Add  service to service guide https://github.com/FusionAuth/fusionauth-site/pull/3411)
