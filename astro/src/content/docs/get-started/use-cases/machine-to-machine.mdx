---
title: Machine To Machine Communication
description: Allow services and software to securely authenticate using FusionAuth
section: get started
subcategory: use cases
---
import APIRequestDiagram from 'src/diagrams/docs/get-started/use-cases/machine-to-machine/api-request.astro';
import M2MCommunicationDescription from 'src/content/docs/get-started/use-cases/_m2m-communication-description.mdx';
import Breadcrumb from 'src/components/Breadcrumb.astro';
import InlineField from 'src/components/InlineField.astro';
import {RemoteCode} from '@fusionauth/astro-components';
import DataFieldDataTypeChanges from 'src/content/docs/_shared/_data-field-data-type-changes.mdx';
import JSON from 'src/components/JSON.astro';

## Overview

<M2MCommunicationDescription />

## Problem 

You have software programs, devices or APIs which need to authenticate and access data or functionality. You want to manage this in a central location. Each of these entities have specific permissions that may change over time.

## Solution

With the machine to machine (m2m) use case, model everything inside FusionAuth using Entity Management. Each entity (the aforementioned software programs, devices or APIs) is granted permissions against any other entity. Permissions against an entity can also be granted to a user.

To test if permissions are granted, use the Client Credentials grant to get an access token, which can be presented to APIs to access data or functionality.

## Prerequisites

You have at least two pieces of software that need to securely communicate with each other without any human in the loop. This could include APIs, AI agents, or devices.

You want to use FusionAuth to create access tokens that can be used to authenticate one machine to another.

## Example Scenario

Machine to machine communication is very flexible, and can include communication between any software entities. If this example doesn't fit your use case, consider [other example scenarios](#other-example-scenarios).

Suppose you have a hardware business selling internet enabled clock radios. The radio ships with the ability to tell time and tune into FM stations, but you want recurring revenue as well, so you offer two upsells, a news API and weather API. A user can subscribe and provide their zip code. Then, in the groggy morning hours, they can press a button on their clock radio for either news or weather. Basic subscriptions get weather, and premium plans get both news and weather.

You need to tie each device to a plan paid for by the user. Since users might change from not having a plan to a basic plan, or from basic to premium you also need to allow the devices permissions to change over time.
'
### Why Not Use API Keys

Before talking implementation, you might be wondering about API keys and why they could not be used to manage the device access to the weather and news APIs. The access token generated by the Client Credentials grant is essentially an API key, proving the clock radio's identity and level of access. Why not simply give a static API key to each clock radio and call it good?

By using an access token for machine to machine communication, you see the following benefits:

* the access token is timebound and expires; if someone steals it, access is limited
* the process is standards based
* the client Id and secret are centrally managed and monitored
* the access tokens can be validated without contacting FusionAuth
* granular permissions and other data can be placed in the token

## Actors/Components

* a weather API which returns weather
* a news API which returns news
* devices: clock radios
* code running on the devices
* FusionAuth

## Implementation Steps

This is an five step implementation process to enable m2m communication. Steps to take:

* set up entity types
* create digital twins for each clock radio
* have the clock radio request the API 
* have the API respond
* modify the digital twin as needed

The next time the radio makes a request, the access token will only be granted for the appropriate permissions.

### Setting Up Entity Types

Entity types define permissions and token lifetime. To set up the entity types and permissions, create an `APIType` Entity Type with two possible permissions, `news` and `weather`. If you needed more permissions later, you could add them to the `APIType` Entity Type.

You'll also need the `ClockRadioType` Entity Type. This doesn't need any permissions, since nothing is granted permissions against this type of entity.

![Entity types for digital twins.](/img/docs/get-started/use-cases/m2m-entity-types.png)

Configure the lifetime of the JWT issued in the Client Credentials grant. Select an asymmetric signing keypair as well, so that the access token can be verified without contacting FusionAuth.

![JWT settings for digital twins.](/img/docs/get-started/use-cases/m2m-configure-entity-type-jwt.png)

Finally, set up one `API` Entity, which has the `APIType` entity type. Access to this API will be granted in the next step.

### Creating The Digital Twin

For each clock radio, create an Entity in FusionAuth which will function as a digital twin. This is something that you should write code for, using [one of the SDKs](/docs/sdks), because you need to do this for every device. You'll need to [create an API key](/docs/apis/authentication#api-key-authentication) to automate this.

Here's example code to create the entity and then grant the `news` permission:

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-example-machine-to-machine/refs/heads/main/create-entity/create-entity.js" lang="javascript" />

Finally, distribute the client Id and secret to each clock radio so that it can request an access token. If you want to do this in reverse order, and set up the device with a known client Id and secret and then set up the entity, you can do that as well, as long as the [client Id is a UUID](/docs/reference/data-types#uuids).

### Making The API Request

When the radio is ready to make the API request, it must obtain an access token. Then it will make a call against the appropriate API endpoint, assing along the token and other data needed for the request. The API can validate the token and return the data. Here's a diagram outlining this flow.

<APIRequestDiagram alt="A clock radio making an API request." />

You obtain the access token using [the Client Credentials grant](/docs/lifecycle/authenticate-users/oauth/#example-client-credentials-grant). If needed, modify the body of the access token by using a [Client Credentials JWT Populate lambda](/docs/extend/code/lambdas/client-credentials-jwt-populate). Here's an example of the grant request made by a clock radio.

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-example-machine-to-machine/refs/heads/main/request-api/request-news.js" tags="requestAccessToken" lang="javascript"/>

Present the access token to the API along with your request. This is typically done using the `Authorization` header, but can be customized based on what the API expects.

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-example-machine-to-machine/refs/heads/main/request-api/request-news.js" tags="fetchNews" lang="javascript"/>

### Building The API Response 

The API validates the access token, using a library to check the signature and the other claims. Here's an example helper middleware validating an access token in an Express API, which reads the token either from a cookie or from the `Authorization` header.

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-example-machine-to-machine/refs/heads/main/apis/services/verifyJWT.js" 
            lang="javascript"/>

This code checks the following parts of the access token:

* signature
* expiration time
* issuer claim
* audience claim

You must further check the permissions from the validated token using code like this helper method:

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-example-machine-to-machine/main/apis/services/hasPermission.js" 
            lang="javascript" 
            tags="verifyToken" />

You can do this in the API route:

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-example-machine-to-machine/main/apis/routes/index.js" 
            lang="javascript" 
            tags="verifyToken" />

Implementation of the actual APIs is incomplete in this example application.

Our quickstarts [show how to validate the access token in an API](/docs/quickstarts/#api) in other languages.

Validate the access token directly, rather than using introspection. Introspection by an API of the access token obtained via a Client Credentials grant doesn't work as you might expect. [More details in this GitHub issue](https://github.com/FusionAuth/fusionauth-issues/issues/3010).

### Changing The User's Plan

When the user changes their plan, you can update the entity's permissions. Here's sample code to update the plan and permissions.

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-example-machine-to-machine/refs/heads/main/update-plan/update-plan.js" 
            lang="javascript" 
/>

The next time an API request is made, updated permissions will be included in the access token.

## Expected Outcome

Your devices now have a digital twin that can be used to securely manage device authentication and authorization against APIs and services.

You can change the permissions and capabilities of these devices over time.

## Edge Cases

The admin UI for managing entities can be difficult to use. It's a good idea to use the admin UI to explore functionality but the SDKs or API to manage entities in production.

No "on behalf of" semantics are currently supported, where machines communicate in sequence. [Read more on the GitHub issue](https://github.com/FusionAuth/fusionauth-issues/issues/1471).

You can rotate client secrets, but you cannot change the device's entity Id. To modify that value, create an new entity.

Entity Ids are always UUIDs.

The token generated by the Client Credentials grant has a `gty` claim in the header. For some APIs, this may cause a problem. [Read more on the GitHub issue](https://github.com/FusionAuth/fusionauth-issues/issues/2886).

### Limits On The Data Field

<DataFieldDataTypeChanges />

## Other Example Scenarios

Whenever software talks to other software without a human in the mix, that's machine to machine communication. Examples include:

* APIs calling other APIs in a microservices based application
* a cron job making calls against a protected service every night at 11pm
* CI/CD pipelines where you are making calls against remote services to, for example, push a container image
* external tooling built by developers integrating with your platform; the client Id and secret can be managed in a developer portal

## Additional Documentation

* [An example Client Credentials grant](/docs/lifecycle/authenticate-users/oauth/#example-client-credentials-grant)
* [Examples of how to validate the access token in an API](/docs/quickstarts/#api)
* [Entity management](/docs/get-started/core-concepts/entity-management)
* [Customize the access token body with a lambda](/docs/extend/code/lambdas/client-credentials-jwt-populate)
* [Videos on using the Client Credentials grant for API authentication](https://www.youtube.com/watch?v=rT-VTtgligI&list=PLUOVyt5DYPpNzRdTKrio0P0a4mktqLPN9)
* [Securing your API blog post](/blog/securing-your-api)
* [Machine to machine GitHub repo](https://github.com/fusionauth/fusionauth-example-machine-to-machine)

[//]: # (Add  service to service guide https://github.com/FusionAuth/fusionauth-site/pull/3411)
