---
title: GitHub Actions With FusionAuth
description: How to use CI/CD with FusionAuth in GitHub
navcategory: get-started
prerequisites: Docker version 20
section: web
url: https://github.com/ritza-co/fusionauth_github_actions
codeRoot: https://raw.githubusercontent.com/ritza-co/fusionauth_github_actions/main
---
import Aside from '/src/components/Aside.astro';
import {RemoteCode} from '@fusionauth/astro-components';

## Notes

Brief - https://docs.google.com/document/d/16ql1wY7kPI4MxESMzMaK2pLCa3ZdSxQcsqbT9tY5qq8/edit

### Brief

- Document how to set up Fusionauth in a CI environment (GitHub actions)
- Use kickstart to set the system up to a known state (example here: https://github.com/FusionAuth/fusionauth-python-client/blob/master/.github/workflows/test.yaml)
- Use Selenium or some other tool (e.g. Playwright) to create an end-to-end  functionality test (e.g. can a user log in?)
- Bonus points if we can figure out how to get Fusionauth available in the GitHub marketplace so users can install it from there instead of manually on the CI runner.
- Resources
  - https://fusionauth.io/community/forum/topic/898/how-do-i-use-fusionauth-in-my-ci-cd-system
  - https://github.com/fusionauth/fusionauth-site/issues/1663
  - https://fusionauth.io/docs/get-started/run-in-the-cloud/

### Todo

- [x] plan project
- [x] read cloud docs on fa docs site
- [x] how does one upgrade fa without losing database? show example with different docker versions on dockerhub
- [x] choose tester:
  - selenium is java based
  - puppeteer is chrome only
  - cypress is complex and has a gui
  - playwright looks good - js. cross browser. headless.
- [x] make article outline
- [x] make test repo - https://github.com/ritza-co/fusionauth_github_actions
- [x] do the same thing in a github action
- [x] how to upgrade FA and backup
- [ ] how to deploy to prod
- [ ] learn about github actions marketplace
- [ ] decide what the marketplace action should do (all 3 os?)
- [ ] write and deploy the action to marketplace
- [ ] write the article
  - [x] target audience - newbies to fa and actions
  - [ ] mention fa cloud paid service
  - [ ] secrets and .env
  - [ ] how to test live site
  - [ ] add images
- [ ] readme for sample app

## Introduction

This article explains:
- How to upgrade FusionAuth
- How to write automated tests of your application login with FusionAuth
- How to run these tests in a [GitHub Action](https://docs.github.com/en/actions) when pushing to the main branch
- How to automate deployment and testing on your live application

To understand this article, you need to know how to create a project in GitHub, but don't need to know anything about FusionAuth, GitHub actions, or automated testing. The basics are explained here.

You will need Docker and Node.js installed if you want to run the example application accompanying this tutorial.

- [Notes](#notes)
  - [Brief](#brief)
  - [Todo](#todo)
- [Introduction](#introduction)
- [Some Definitions And Goals](#some-definitions-and-goals)
- [A Simple Example Using GitHub Actions](#a-simple-example-using-github-actions)
- [How To Upgrade FusionAuth](#how-to-upgrade-fusionauth)
- [Test Your App Login With Playwright](#test-your-app-login-with-playwright)
  - [Write a test for Playwright](#write-a-test-for-playwright)
- [Test Your App In A GitHub Action](#test-your-app-in-a-github-action)
- [Understand GitHub Actions](#understand-github-actions)
- [Compile Your App In A GitHub Action](#compile-your-app-in-a-github-action)
- [Deploy Your App In A GitHub Action](#deploy-your-app-in-a-github-action)
- [Dev, Test, QA, Preprod, And Prod Environments](#dev-test-qa-preprod-and-prod-environments)
- [Use The Action For FusionAuth In The GitHub Action Marketplace](#use-the-action-for-fusionauth-in-the-github-action-marketplace)
- [Further Reading](#further-reading)


## Some Definitions And Goals

FusionAuth provides all login functionality for your web application. It stores users in its own database, separate to the database your app uses to keep its data. Assuming you have built a login page that redirects a user to FusionAuth for login, your system will have the components shown below.

```mermaid
graph LR
  subgraph app [ ]
    direction TB
    1[App website] --> 2[Database]
  end

  subgraph auth [ ]
    direction TB
    3[FusionAuth website] --> 4[Database]
  end

  app <--> auth
```

You might have the following questions:
- How do I deploy all this to production?
- What happens when FusionAuth releases a new version? How do I upgrade it without losing data?
- How can I test that login still works after upgrading my app or FusionAuth?
- How do I separate and manage my development and production environments?
- Where do I keep database passwords safely and include them when deploying?

Automating these tasks above is called continuous integration / continuous deployment (CI/CD).
- CI refers to testing that changes to code you push to the main branch fits in with the existing system and everything still works.
- CD refers to deploying every push to the main branch to your production (live) site.

GitHub provides a tool for automating workflows called GitHub actions. It provides a virtual machine in which you can run scripts to check out your code, compile it, deploy alongside FusionAuth and other services, run tests, and deploy everything.

The flow looks like the diagram below.

```mermaid
graph TD
    1[👨‍💻 Programmer] --> 2[⬆️ Push to main branch on GitHub]
    2 --> 3[🎬 GitHub action triggers]
    3 --> 4[🛠️ Compile app in a virtual machine]
    subgraph Inside GitHub Action
        4 --> 5[🔬 Test app can log in with FusionAuth]
        5 -- Deploy --> 6[☁️ AWS]
        5 -- Deploy --> 7[☁️ Azure]
        5 -- Deploy --> 8[☁️ Virtual server]
    end
```

## A Simple Example Using GitHub Actions

There is a minimal but complete CI/CD example in this [repository](https://github.com/ritza-co/fusionauth_github_actions).

In GitHub, click [uielement]#fork# and add the repository to your own account. Then use `git clone ...` to download it.

Below are the contents.

```bash
├── app
│   ├── app.js
│   ├── .env
│   ├── .github
│   │   └── workflows
│   │       └── playwright.yml
│   ├── package.json
│   ├── playwright.config.js
│   ├── public # css and images
│   ├── routes
│   │   └── index.js
│   ├── services
│   │   └── authentication.js
│   ├── tests
│   │   └── test.spec.js
│   └── views # html templates
├── docker-compose.yml
├── .env
├── .github
│   └── workflows
│       └── test.yaml
└── kickstart
    ├── css
    │   └── styles.css
    └── kickstart.json
```

FusionAuth is managed by the `docker-compose.yml` and `.env` files and `kickstart` directory. FusionAuth runs in a Docker container. Upon starting, it uses the `.env` file to get the database password. The database is stored in files in a Docker volume. If starting for the first time, FusionAuth uses the `kickstart` details to configure its visual style and various settings. If it has run before, FusionAuth attaches to the existing volume and uses that database.

The `app` folder contains a Node.js JavaScript application. The server runs with Express.js and provides a login page that sends the user to FusionAuth, then directs them to the acount page after login. The `tests` folder contains a login test written in [Playwright](https://playwright.dev/docs/intro). Playwright runs tests in an actual web browser to see if all elements and interactions behave as they would with a real user. The tests can all be run from the terminal however, allowing you to test your application on a computer without a graphical environment.

The `.github/workflows/test.yaml` file is the GitHub Action script. There is another script in `app/.github/workflows/playwright.yml` provided by Playwright when creating the app, but it uses more GitHub resources, with a long timeout and saving the test results in a file. GitHub provides 2000 minutes of time for actions per month for free, so the `test.yaml` uses as little as possible.

<Aside type="info">To learn how FusionAuth runs in Docker, please read the [five minute guide](/docs/quickstarts/5-minute-docker). To learn how Express.js connects to FusionAuth, please read this [quickstart](/docs/quickstarts/quickstart-javascript-express-web).</Aside>

## How To Upgrade FusionAuth

Before running the app, let's demonstrate how to upgrade FusionAuth. It should usually be as trivial as changing the version number and restarting FusionAuth.

In this section you will:
- Start an older version of FusionAuth.
- Create a new user.
- Upgrade FusionAuth.
- Check that user is still there.

Open the `docker-compose.yml` file and on line 42 set the FusionAuth image to
```yaml
image: fusionauth/fusionauth-app:1.42.1
```

In a terminal run
```bash
docker compose up
```
FusionAuth will start, and you will be able to log in at http://localhost:9011 with username `admin@example.com` and password `password`. In the Users section of the site, create a new user.

Stop Docker in the terminal. Change the `docker-compose.yml` line to use a new FusionAuth version, `1.48.3`. Again run
```bash
docker compose up
```

The output of the Docker command below shows that FusionAuth silently (without user approval) and successfully runs database migration (upgrade) scripts on the existing database when starting.

```bash
fusionauth_github_actions-fusionauth-1  | ---------------------------------------------------------------------------------------------------------
fusionauth_github_actions-fusionauth-1  | ---------------------------------- Entering Silent Configuration Mode -----------------------------------
fusionauth_github_actions-fusionauth-1  | ---------------------------------------------------------------------------------------------------------
fusionauth_github_actions-fusionauth-1  |
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.337 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Attempting to lock database to support multi-node configurations
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.348 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Obtained a database lock
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.386 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Database Version [1.42.1]
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.393 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Latest Migration Version [1.48.1]
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.401 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Execute migration script [1.43.0]
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.415 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Execute migration script [1.44.0]
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.425 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Execute migration script [1.45.2]
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.432 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Execute migration script [1.46.0]
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.444 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Execute migration script [1.47.0]
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.459 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Execute migration script [1.48.0]
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.472 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Execute migration script [1.48.1]
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.500 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Database Version [1.48.1]
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.500 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Latest Migration Version [1.48.1]
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.500 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Attempting to unlock database to support multi-node configurations
fusionauth_github_actions-fusionauth-1  | 2024-01-05 12:49:04.501 PM INFO  com.inversoft.maintenance.db.JDBCMaintenanceModeDatabaseService - [TW2QyQ] Unlock completed

```

If you browse to FusionAuth again you'll see that the user you created is still there.

The FusionAuth application is separate to the FusionAuth database. In this case, the database is stored in a Docker volume. When the upgrade scripts run, the data should not be broken and upgrading FusionAuth should be unnoticeable. However, mistakes can happen, as well as database crashes, and you should backup both the FusionAuth database and your application database daily. The rest of this article will show you how to automate login tests to check that your system still works after upgrading FusionAuth or your app. If something breaks, you can restore the old version of the database and begin debugging.

For more details on upgrading FusionAuth, including non-silent upgrade, please read this [article](/docs/get-started/download-and-install/docker#upgrading).

## Test Your App Login With Playwright

FusionAuth is already running. To start the app that uses it, run the code below.

```bash
cd app
npm install
npm run start
```

Browse to http://localhost:3000 and log in with the same user as before.

When changing your application, it would be faster to test that login works automatically, rather than by hand. This is called an integration, or end-to-end test, as opposed to a unit test, which tests only a single function. For integration tests in the browser, you can use Playwright.

<Aside type="info">
Playwright was created by Microsoft, runs in JavaScript, and allows you to run tests in multiple browsers. It is a popular successor to Selenium, which used Java, and Puppeteer, which was written by Google and focussed on Chrome.
</Aside>

To start the Playwright tests for this app, open a new terminal and run the code below.

```bash
npx playwright install
npx playwright install-deps # install necessary browsers
npx playwright test --project=chromium;
```

The output should be as below.

```bash
Running 1 test using 1 worker

  ✓  1 [chromium] › test.spec.js:3:1 › Test login (5.1s)

  1 passed (5.8s)
```

The command returns `0` to the terminal if all tests passed, and another number if any tests failed. This allows you (and GitHub Actions) to write shell scripts that perform different tasks if the tests succeed or not.

To see what is happening visually, run the code below.

```bash
npx playwright test --project=chromium --ui
```

You can see that Playwright runs a browser, clicks buttons, and fills in forms.

![Playwright test UI](./github_actions_images/playwright.png)

### Write a test for Playwright

The code for the test Playwright runs is in the file `test.spec.js`.

<RemoteCode url={frontmatter.coderoot + "/app/tests/test.spec.js"}
  lang="js" />

The code should mostly be self explanatory, but there are a few things to note:
- `await` is used frequently as most operations on the page are asynchronous.
- `waitForLoadState('networkidle')` is used to wait for pages to load. `.waitForNavigation()` and `.waitForURL()` failed when this article was written.
- Tests start with `expect()`, such as `expect(emailText).toBe('richard@example.com')`. Without these, your tests won't actually test anything.
- To add a new test of your own, write a new function like `test('Test login', async ({ page }) => {`.

To add Playwright to your own project, follow [their guide](https://playwright.dev/docs/intro). Running `npm init playwright` will create a configuration file and sample test you can use as a starting point.

The configuration file `playwright.config.js` allows you set which browsers to use (which we used in `--project=chromium` earlier), whether to start your app before running the tests, and in which directory to look for test files.

## Test Your App In A GitHub Action

Now that you know how to test your app after a change to it or FusionAuth, let's automate the process in GitHub. Your goal is to have a test run whenever committing to your main branch. GitHub will email you if the test fails.

Open the file `.github/workflows/test.yaml` and change the branch name on line five from

```yaml
      - main_RENAME_THIS_TO_ENABLE_TEST
```

to

```yaml
      - main
```

You've renamed the trigger that causes this Action to execute, from a nonsense name, to the main branch of your application.

Save, commit in Git, and push to GitHub. This will cause the test to execute.

You can browse to the Actions tab in your GitHub repository to see the test run, or view the results in the [original repository]({frontmatter.url + '/actions'}).

![Passed test](./github_actions_images/passedtest.png)

To test that the test works, change the email in `test.spec.js` to `wrong@example.com` and push to GitHub again. You can now verify that the test does detect a broken login.

![Failed test](./github_actions_images/failedtest.png)

If your test runs successfuly, you can be certain that your app and FusionAuth are both running, can speak to each other, and that the user is still present in the database after any migrations have run.

## Understand GitHub Actions

GitHub Actions are a service provided by GitHub that allow you to run workflows that can do anything you can write in a script, triggered by different types of events in your repository. GitHub runs your script in a virtual machine. You are allowed a certain amount of free CPU minutes per month, and set amount of storage. For more details, see the [pricing page](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions).

Let's review the action script to see how it works. All scripts are stored in the `.github/workflows` directory, and the files can be called whatever you want. Here the file is called `test.yaml`.

<RemoteCode url={frontmatter.coderoot + "/.github/workflows/test.yaml"}
  lang="yaml" />

Each action has a name, which is a human-readable label.

```yaml
name: Test FusionAuth login
```

This is followed by an event, which is all the conditions that trigger the action to execute. Events are stored in the `on` object. The most common ones to use are when pushing a commit, or receiving a pull request. For a full list, see the [documentation](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows).

Your action uses the push to main event.

```yaml
  push:
    branches:
      - main
```

Finally, comes the action itself, which is stored in the `jobs` object. This is what will run when the event occurs. Your action has just one job, `run-tests`.

You need to specify the type of operating system the container will run to execute the job steps. Here you use `ubuntu-latest`. It is the cheapest container on GitHub. Windows containers use minutes at twice the rate of Linux, and Mac containers use ten times the rate of Linux.

The service sections says that you need to use Docker (where FusionAuth runs).

```yaml
    services:
      docker:
        image: docker:19.03.12
        options: --privileged # container has full access to host
        ports:
          - 3000:3000
          - 9011:9011
```

The steps consist of two types of code:
- actions, which are existing tasks in GitHub, such as checking out a repository or installing Node.
- custom commands, which run code directly in the container terminal.

This script starts by checking out your repository and installing node in actions.

```yaml
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '18'
```

Custom code then starts Docker, installs Node modules, runs the app, and runs the tests. Note that steps usually run in serial. To run steps simultaneously, you use `-d` in Docker, and `npm run start &` to start the next step without waiting for the first step to exit. If a step fails, the next step will not run.

```yaml
      - name: Start FusionAuth in Docker
        run: docker-compose up -d # -d in background

      - name: Install npm dependencies
        run: |
          npm install
          npx playwright install-deps
          npx playwright install
        working-directory: ./app

      - name: Start app
        run: npm run start & # & in background
        working-directory: ./app

      - name: Run Playwright tests
        run: npx playwright test --project=chromium
        working-directory: ./app
```

## Compile Your App In A GitHub Action

You might have noticed that GitHub did not build your app at any point in this workflow. This is because JavaScript is a dynamic language and does not need to be compiled. If you are using FusionAuth with C#, Go, Rust, or TypeScript, you can add another step to your action to compile the code before running the tests. This might look like the code below.

```yaml
      - name: Compile app
        run: cargo build
        working-directory: ./app
```

## Deploy Your App In A GitHub Action

While building your app is simple, deploying it is more complex. Your production environment might be a physical server, a virtual server such as Digital Ocean, or a large service provider such as AWS or Azure. You might also want to deploy a new version FusionAuth, which might use Docker.




## Dev, Test, QA, Preprod, And Prod Environments

when to run actions - pull, which branches
what to do on failure
- Testing login works should be done in the action. The final test of logging to the deployed app can be done by hand when checking the site is actually up.


## Use The Action For FusionAuth In The GitHub Action Marketplace

## Further Reading