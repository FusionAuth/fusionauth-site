---
title: Device Limiting
description: Learn how to limit the number of devices a user can log in to concurrently.
navcategory: developer
section: extend
subcategory: examples
---
import Aside from 'src/components/Aside.astro';
import InlineField from 'src/components/InlineField.astro';
import ScrollRef from 'src/components/ScrollRef.astro';

This guide will help you limit concurrent logins on user devices with FusionAuth. Many apps limit the number of devices a user can log in to concurrently. 

## Why Limit Device Logins?

There are multiple reasons why you might be interested in limiting concurrent user logins. Here are a few examples.

* For security reasons, to ensure that a user's account isn't compromised. For example, if you create a banking app, it would be unlikely that a user would log need to log in from multiple devices at the same time. However, for an email application, this would not be the case. 

* To prevent account sharing, especially for paid consumer content services. This is common on media streaming services, for example.

* To enforce a licensing agreement for enterprise software. This is common for software that is licensed per user, such as a CRM or project management tool, and the per user cost is significant.

You can also see requests from FusionAuth customers looking to implement device limiting schemes on our GitHub issues page: 

* [Limit a user to a single session](https://github.com/FusionAuth/fusionauth-issues/issues/1363)

* [Limit the number of different devices an account can login from](https://github.com/FusionAuth/fusionauth-issues/issues/1156)  

This guide provides a way to address these requirements and users requests. While FusionAuth does not directly support limiting device logins, you can implement a solution using FusionAuth APIs and custom logic in your application. 

FusionAuth only captures limited information about each device as part of the session information. Devices are not tracked separately, and a user may have multiple sessions on the same device (e.g. on different browsers or in a private browsing mode). So a device is really anything where a user logs in (chrome and firefox on the same computer are two 'devices'). 

## Approaches To Device Limiting

This guide will cover two approaches to limiting concurrent logins. Both approaches rely on the [JWT Retrieve Refresh Tokens API](https://fusionauth.io/docs/v1/tech/apis/jwt#retrieve-refresh-tokens) to retrieve the number of active refresh tokens for a user as a proxy for active logins.

 * Simpler implementation: The user will simply be informed that they are logged in to too many devices and will be asked to log out of one of them manually, and then try logging in again. By logging out of one of the sessions, the refresh token for that session will be revoked by FusionAuth.

 * More user friendly implementation: The list of current logins will be displayed and the user will be able to select which session to end. The application will then call the FusionAuth API to end the session, by [revoking the refresh token](https://fusionauth.io/docs/v1/tech/apis/jwt#revoke-refresh-tokens) for the chosen session. 

 For the second option to work, the user JWTs issued by FusionAuth must be configured to relatively short lifespans to prevent the user from staying logged in on the additional devices long after the corresponding refresh token has been revoked. 

## The ChangeBank Application

To make things a bit more concrete, let's use an example from the [FusionAuth QuickStart Guides](/docs/quickstarts/quickstart-javascript-express-web). The [ChangeBank](https://www.youtube.com/watch?v=CXDxNCzUspM) application is a simple banking application that allows users to convert dollars into coins.

This guide will show two ways to extend the [express based](https://expressjs.com) [ChangeBank application](/docs/quickstarts/quickstart-javascript-express-web) to limit concurrent logins.

The completed applications code is available on GitHub at:
-  [Simple Guide)[https://github.com/FusionAuth/fusionauth-device-limit-guide-simple]
-  [User Friendly Guide)[https://github.com/FusionAuth/fusionauth-device-limit-guide-friendly]


## Login Requirements

Since the crux of the solution relies on the number of active refresh tokens for a user, you will need to ensure that your FusionAuth application is set up to issue refresh tokens, and that your client application requests them when logging in. 

To ensure that your FusionAuth application is set up to issue refresh tokens, navigate to "Applications" -> "Edit" -> "JWT Configuration". Ensure that "Issue Refresh Tokens" is checked.

To ensure that your client application requests refresh tokens when logging in, ensure that the `offline_access` scope is included in the `scope` parameter of the `/oauth2/authorize` request. If you are constructing the request manually, it should look something like this:

```javascript
res.redirect(302, `${fusionAuthURL}/oauth2/authorize?client_id=${clientId}&response_type=code&scope=offline_access&redirect_uri=http://localhost:${port}/oauth-redirect&state=${userSessionCookie?.stateValue}&code_challenge=${userSessionCookie?.challenge}&code_challenge_method=S256`)
```
If you are using Passport.js, you can include the `offline_access` scope in the `scope` key of the options object passed to the `authenticate` method. It should look something like this:

```javascript
passport.authenticate('oauth2', { scope: ['offline_access'] })
```
For other libraries and languages, consult the documentation to see how to include the `offline_access` scope in the authorization request to FusionAuth.

## Using the Refresh Token API

Both solutions depend on calling the FusionAuth API to retrieve the active [refresh tokens](https://fusionauth.io/docs/apis/jwt) for a user, using the [JWT Retrieve Refresh Tokens API](https://fusionauth.io/docs/apis/jwt#retrieve-refresh-tokens). This API requires an API key](https://fusionauth.io/docs/apis/api-keys). You will use it with the GET and DELETE permissions for `/api/jwt/refresh` in this guide.

To create this key, navigate to "Settings" -> "API Keys" and click the "+" button to add a key. Give the key a name, and select the GET and DELETE permissions for `/api/jwt/refresh`. Click "Save API Key".

Once you have the key, you will be able to use it to call the API to retrieve the active refresh tokens for a user. Note that refresh tokens for all applications will be returned, so you will need to filter the tokens by the `applicationId` to get the number of active sessions for a specific application. Also note that refresh tokens without an `applicationId` may also be present. These tokens are used for the "Remember me" feature on FusionAuth itself, and should be ignored when counting the number of active sessions for a user.

Thereafter, the number of filtered active refresh tokens for the particular application can be used as a proxy for the number of active logins for the user. Calling the API using Node and filtering the results looks something like this:

```javascript

const tokenResponse = await fetch(`${fusionAuthURL}/api/jwt/refresh?userId=${userId}`, {
  method: 'GET',
  headers: {
    'Content-Type': 'application
    'Authorization': `${fusionAPIKey}`
  }
});
const tokens: any = await tokenResponse.json();
tokens.refreshTokens = tokens.refreshTokens.filter((t: any) => t.applicationId && t.applicationId === clientId);
const activeSessionCount = tokens.refreshTokens.length;
``` 

The variable `clientId` stores the FusionAuth application ID for the application you are limiting logins for. The `userId` is the ID of the user you are checking the active sessions for.

## Simpler Scheme

This scheme uses the FusionAuth [`user.login.success`](https://fusionauth.io/docs/v1/tech/events-webhooks/events/user-login-success) webhook. This webhook is fired after a user provides valid credentials, but before a session is created and the user logged in. Returning a `2xx` response from this webhook will allow the login to proceed. Returning a `4xx` response will prevent the login from proceeding. Since a FusionAuth webhook is enabled at the tenant level, you will also need to check the application the the user is attempting to log in to when implementing this solution. The `applicationId` is provided in the webhook payload, along with the `userId`, among other information.

This scheme retrieves uses the Refresh Token API explained above to retrieve the number of active sessions for a user. If the user is logged in on too many devices, the login will be prevented by returning a `403` response from the webhook. They will then need to log out of one of their other devices before they can attempt to log in again.

To let the user know that the reason the login failed was because they were logged in to too many devices, the default message for a failed webhook needs to be overridden with a custom message. Note that this message will be displayed for any failed login due to any webhook error, not just for failed logins due to too many concurrent logins. Therefore this solution is not ideal if your application uses other webhooks. 

### Create A Webhook In FusionAuth

TODO: Describe adding a webhook via the UI. Also describe how it is automatically created via the quickstart. Route is `/user-login-success`. Remember docker note on localhost -> host.docker.internal routing. Webhook must be configured to "all succeed" mode. 

To add the webhook to FusionAuth, navigate to <strong>Settings -> Webhooks</strong> in the sidebar. Click the "+" button to add a webhook. Give the webhook a name, and select the <InlineField>user.login.success </InlineField> event. Set the URL to `http://{YOUR_APPLICATION_URL}/user-login-success`. Click <strong>Save Webhook</strong> when you are done. 

<Aside type="note">
In production you should add security to the webhook in the form of Basic Auth and a certificate by navigating to the <strong>Security</strong> tab. This ensures that the webhook can only be called by FusionAuth.
</Aside>

### Listen To The Webhook

In the application, you will need to listen for the `user.login.success` event and check the number of active sessions for the user. Here is an example of how to do this in an Express application, like the ChangeBank application.

```javascript

app.post('/user-login-success', async (req, res, next) => {

  if (req.body.event.applicationId !== clientId) 
    return res.status(200).json(JSON.stringify({ message: `Not a login event for this application.` }));

  const userId = req.body.event.user.id;

  const tokenResponse = await fetch(`${fusionAuthURL}/api/jwt/refresh?userId=${userId}`, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `${fusionAPIKey}`
    }
  });
  const tokens: any = await tokenResponse.json();
  tokens.refreshTokens = tokens.refreshTokens.filter((t: any) => t.applicationId && t.applicationId === clientId);
  const activeSessionCount = tokens.refreshTokens.length;

  if (activeSessionCount >= maxDeviceCount) {
    return res.status(403).json(JSON.stringify({ error: 'You are logged in on too many devices at once. Please log out of one of your other devices and try again.'}));
  } else {
    return res.status(200).json(JSON.stringify({ message: `You are logged in on ${activeSessionCount +1 } of ${maxDeviceCount} devices.` }));
  }

});

```

As described in the [documentation](https://fusionauth.io/docs/extend/events-and-webhooks/events/user-login-success), the event data sent by FusionAuth as JSON in the body of the webhook invcludes the `applicationId` and `userId` among other information. The `applicationId` is used to check that the login event is for the application you are limiting logins for. The `userId` is used to retrieve the active refresh tokens for the user.

Running an application with the webhook connected and logging in with the same user on more than 2 devices. You can simulate multiple devices by logging in with multiple browsers and with private tabs. You should see the following message when trying to log in for the third time:

```
One or more webhooks returned an invalid response or were unreachable. Based on your transaction configuration, your action cannot be completed.
```

This message is very generic, and does not tell the user that the reason they cannot log in is because they are logged in on too many devices. To fix this, override the default message with a custom message. You can do this by customizing the `WebhookTransactionException` message in your FusionAuth theme templates. To do this, navigate to "Customizations" -> "Themes". Click the "Edit" Button next to the `ChangeBank Theme`. Under "Templates", click "Messages". Click the "Edit" button next to the "Default" Locale. Search for `[WebhookTransactionException]` (approx. line 606), and change the message to read `You are already logged in on other devices. Please log out of one of your other devices and try again.`. Click "Save" , and then save the theme as well. <TODO: Is there a way to include this in the kickstart file>

Logging in again with the same user on more than 2 devices should now display the new message.

## The User Friendly Implementation

The previous implementation has the advantage of code simplicity, but it does have a few problems. The first is from the user perspective - they have to manually log out of one of their devices before they can log in again. The second is that the user is not informed of which devices they are logged in on. The third is that the message used to inform the user that they are logged in on too many devices is the same generic message used for all webhook errors. Therefore adding other webhooks to your application will result in the same error message being displayed, regardless of the type of webhook failing. 

This implementation provides a more user friendly way of handling device limits. It saves the user the trouble of having to manually log out of one of their devices. Instead, the user will be presented with a list of their current logins, and will be able to select which session to end. The application will then call the FusionAuth API to end the session, by [revoking the refresh token](https://fusionauth.io/docs/v1/tech/apis/jwt#revoke-refresh-tokens) for the chosen session.

To achieve this, the application will always allow a login to proceed, and once logged in will call the FusionAuth API to retrieve the other sessions to check if the device limit has been reached. Before allowing the user to access the rest of the app, a page will display the user's current logins, and allow them to select which session to end.

To implement this solution, you will need to: 

* Set the lifespan of the ordinary user JWT to a relatively short time to prevent staying logged in even after the corresponding refresh token has been revoked. 

* Create a middleware function to call the FusionAuth API to retrieve the number of active sessions for a user for each request.

* Create a page to display the user's current logins and allow them to select which session to end. The middleware above will redirect the user to this page if they are logged in on too many devices.

* Create a route to handle the user's selection and call the FusionAuth API to revoke the refresh token for the selected session.


### Setting The JWT Lifespan

To set the JWT lifespan navigate to <strong> Applications </strong> in the sidebar of FusionAuth. Select the <InlineField> Edit </InlineField> button next to the application you are limiting logins for. Under the <strong> JWT </strong> tab, set the <InlineField> JWT duration </InlineField>  to a relatively short time, such as 300 seconds (5 minutes). Click <InlineField> Save Application </InlineField> when you are done.

### Create A Middleware Security Function

For any route that you would normally check for authentication, you will need to add an additional middleware function to check the number of active sessions for the authenticated user. The middleware should check for the number of active sessions using the refresh token API as described earlier. If the user is logged in on too many devices, the middleware should redirect the user to a page to display the user's current logins and allow them to select which session to end.

The middleware function should look similar to this:

```javascript
/**
  Middleware to check if the user has exceeded the device limit. Redirects to the device-limit page if so.
 */
async function checkDeviceLimit(req: any, res: any, next: any) {
  const deviceLimit = await getActiveDeviceList(req);
  if (deviceLimit.length >= maxDeviceCount) {
    return res.redirect(302, '/device-limit');
  } else {
    next();
  }
}

async function getActiveDeviceList(req: any): Promise<any> {

  const userDetailsCookie = req.cookies[userDetails];
  const userTokenCookie = req.cookies[userToken];
  const userId = userDetailsCookie.id;
  const tokenResponse = await fetch(`${fusionAuthURL}/api/jwt/refresh?userId=${userId}`, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `${fusionAPIKey}`
    }
  });
  const tokens: any = await tokenResponse.json();

  // Filter tokens that are for this application: 
  tokens.refreshTokens = tokens.refreshTokens.filter((t: any) => t.applicationId && t.applicationId === clientId);
  // remove the current session token
  tokens.refreshTokens = tokens.refreshTokens.filter((t: any) => t.token !== userTokenCookie.refresh_token);

  // Map to a simple object for display, removing token values etc. 
  return tokens.refreshTokens.map((t: any) => ({
    id: t.id,
    deviceName: t.metaData.device.name,
    startInstant: new Date(t.startInstant).toUTCString(), 
    ipAddress: t.metaData.lastAccessedAddress
  }));

}
```
Notice that in the `getActiveDeviceList` function, the current session token is removed from the list of active sessions. This is because it would not make sense to allow the user to end the current session to continue using the application. The userID is also retrieved from the existing authentication cookie. For this reason, the device limit middleware must always be placed after the user authentication and token validation middleware for any secured route. 

The `getActiveDeviceList` function returns a list of active session view models for the user, which will also be used to display the user's current logins and allow them to select which session to end.

The middleware function `checkDeviceLimit` can be used on restricted routes, such as the `make-change` and `account` routes in the ChangeBank app, like this:

```javascript
app.get("/make-change", validateUserToken, checkDeviceLimit, async (req, res) => {
  res.sendFile(path.join(__dirname, '../templates/make-change.html'));
});
```

### Create A Page To Display The User's Current Logins

The middleware above redirects to a route called `/device-limit`. This route should return a web page to display the user's current logins and allow them to select which session to end. To pass the list of active sessions with their details, you will need to use a template engine such as Handlebars to simplify the HTML generation. You can add handlebars to the ChangeBank application using NPM: 

```bash
npm install handlebars
```
Then you can add it to the express app like this:

```javascript
app.set('views', path.join(__dirname, '../templates'));
app.set('view engine', 'hbs');
```

 You will require a `GET` route to render the `device-limit` page. The route should look something like this:

```javascript

app.get("/device-limit", validateUserToken,  async (req, res) => {
    const devices = await getActiveDeviceList(req);
    res.render('device-limit', { devices, maxDeviceCount });
});

```

The handlebars template page should look like this:

```html
<html>

<head>
  <meta charset="utf-8" />
  <title>Device Limit - FusionAuth Express Web</title>
  <link rel="stylesheet" href="/static/css/changebank.css">
</head>

<body>
  <div id="page-container">
    <div id="page-header">
      <div id="logo-header">
        <img src="https://fusionauth.io/assets/img/samplethemes/changebank/changebank.svg" />
        <div class="h-row">
          <p class="header-email"></p>
          <a class="button-lg" href="/logout">Logout</a>
        </div>
      </div>

      <div id="menu-bar" class="menu-bar">
        <a class="menu-link" href="/make-change">Make Change</a>
        <a class="menu-link inactive" href="/account">Account</a>
      </div>
    </div>

    <div style="flex: 1;">
      <div class="column-container">
        <div class="app-container change-container">
          <h3>Device Limit</h3>
          <div class="change-message">
            <p>You have {{devices.length}} devices currently logged in. </p>
            <p>You can only have {{maxDeviceCount}} devices logged in at a time. Please select one or more of the devices below to sign out of.</p>
            <p>You will then be able to continue using the application here.</p>
          </div>


          <form id="device-list" action="/device-limit" method="post">
            {{#each devices}}
            <div class="h-row">
              <label>
                <input type="checkbox" name="deviceIds[]" value="{{id}}"> {{deviceName}}, logged in at {{startInstant}}
              </label>
            </div>
            {{/each}}
            <hr />
            <div class="h-row">
              <input class="change-submit" type="submit" value="Sign Out Selected Devices" />
            </div>
          </form>


        </div>
      </div>
    </div>

    <script>
      // Snag cookie user data
      const user = JSON.parse(decodeURIComponent(document.cookie.split('; ').filter(c => c.includes('userDetails')).at(0).split('=').at(-1)).replace('j:', ''))
      document.querySelector('.header-email').innerHTML = user.email;
    </script>
</body>

</html>
```

### Revoking A Chosen Session

The web page posts back the selected token IDs to the backend. You will need a route that accepts these token IDs, as well as revokes the selected tokens using the 'DELETE' method on the FusionAUth Refresh Token API. 

```javascript
app.post("/device-limit", validateUserToken, async (req, res) => {

  // Get the refresh token id from the form
  const refreshTokenIds = req.body.deviceIds;
  if (!refreshTokenIds) return res.redirect('/device-limit');

  // revoke the refresh tokens for the selected devices
  for (const refreshTokenId of refreshTokenIds) {
    try {
      const result = await fetch(`${fusionAuthURL}/api/jwt/refresh/${refreshTokenId}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `${fusionAPIKey}`
        }
      });
    }
    catch (err) {
      console.error(err);
    }
  }

  res.redirect('/account');
});
```

## Example Applications

You can download, review and run applications for both the simple and user friendly device limiting implementations from the GitHub: 

 * [Simple (Webhook) implementation](https://github.com/FusionAuth/fusionauth-device-limit-guide-simple). 

 * [User Friendly implementation](https://github.com/FusionAuth/fusionauth-device-limit-guide-friendly). 
