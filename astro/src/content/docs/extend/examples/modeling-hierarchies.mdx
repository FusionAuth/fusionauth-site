---
title: Modeling Hierarchies
description: Using the FusionAuth Entity Management feature to model hierarchical organizations and users that belong to organizations.
navcategory: developer
section: extend
subcategory: examples
---

import PremiumPlanBlurb from 'src/content/docs/_shared/_premium-plan-blurb.astro';
import Breadcrumb from 'src/components/Breadcrumb.astro';
import InlineField from 'src/components/InlineField.astro';
import InlineUIElement from 'src/components/InlineUIElement.astro';
import Aside from 'src/components/Aside.astro';
import IconButton from 'src/components/icon/Icon.astro';

<PremiumPlanBlurb />

This guide discusses ways of modeling hierarchical organizations and entities, with users and permissions, and provides a sample application with some starting code you can use in your own app.

## Understand FusionAuth Types And Their Relationships

Let's start by reviewing all the FA types and how they relate. You need to understand these types well to adjust the hierarchical system design in this guide to suit your situation. If you want to read about FA types in more detail, see the [Core Concepts](https://fusionauth.io/docs/get-started/core-concepts) documentation.

To avoid confusion with FA applications in this guide, the service you provide your users will be called your "website", as opposed to an application, app, or service.

The first set of FA types are: Tenants, Applications, Groups, Roles, and Users. These types manage users logging in to an application. (Applications are sometimes called clients in other systems).

The second set of types are: Entity Types, Entities, Permissions, and Entity Grants. These types were added to FusionAuth in 2021, after the original set of types in the previous paragraph. They are used for machine-to-machine authentication, and as a case-specific way to model things (entities), as opposed to organizations.

### Applications And Users

Think of a tenant as an entirely separate instance of FusionAuth, without actually running a separate instance. A tenant completely separates all users and applications from those in any other tenant, even when they have the same names and email addresses.

An application represents an organization, website, or service that a person (a user) logs in to. A user has personal data, an email address, and any amount of custom data stored in JSON. A user is a member of an application through a registration. Users can have registrations to many applications, or none.

Applications have roles. A role is just a string. A registration can add many roles to a user for an application. Your website can use a user's role however it wants: authorize a user to perform special actions or ignore the role entirely.

A group is a collection of users. A user can belong to multiple groups, so you can think of a group as a tag that can be applied to a user. A group can have many roles in many applications. If a user has a group, and the user is also registered with an application, that user will automatically be granted any roles in the application that the group has.

For example, consider an example of a bank website with clients and employees. The bank website is an application in FA. The application has two roles: client and employee. Your clients and employees are users, that each have a single registration in the bank application. Each registration may give the user either the client or employee role, or both.

If you want, you could make groups called client and employee, with the client and employees roles in the application respectively. Then you would add users to either or both groups, and register the users with the application, but would not need to give the users roles manually. This would be useful if you had a lot of roles. Another use of groups is to tag users with certain attributes, such as VIP users.

<Aside type="warning">
Digital security usually involves three types: users, roles, and permissions. A user can have many roles, and roles can have many permissions. The advantage of not granting users permissions directly are:
- You can add (or remove) permissions to a role and they automatically apply to every user in that role. You don't have to add a permission to a million users individually.
- A user can have multiple roles with multiple permissions, and the user automatically gets the superset of permissions from all their roles. You don't have to consider each user as an individual and specify the exact combination of permissions that their job requires.
- Your website can work only with permissions when checking if a user has rights to do something, and doesn't have to worry about mapping users through roles to permissions itself.

However, FA does not have permissions. There is a GitHub feature request to add them. Vote [here](https://github.com/FusionAuth/fusionauth-issues/issues/15) if you want that feature.

There are two workarounds:
- Treat roles as permissions. In other words, instead of the employee role, make roles called "can edit clients", "can adjust salaries", and so on. When a user logs in with FA, your website will receive a list of exactly what "permissions" (roles) the user has. But now you have lost all the advantages of working with roles described above.
- Manage permissions in your website code. Keep the user and role associations in FA, but link roles to permissions in your website database, not in FA. When a user logs in with FA, your website will go the database and retrieve all permissions you have associated with those roles and add them to the user. This treats FA more as an authentication system than an authorization system.
</Aside>

### Entities And Permissions

An entity in FA is just a name, and can represent anything â€” a company, document, or refrigerator. The only functional aspect to an entity is that it can be used for machine-to-machine authentication with the client credentials OAuth flow. In this case, an entity usually represents a service.

An entity has an entity type. The type of an entity cannot be changed once it has been created. An entity type can have many permissions, which are also just strings.

Both users and entities can be linked to entities by entity grants. An entity grant lists which permissions of an entity the linked user or entity has access to.

For example, you could make an entity type called Company with an entity called ChangeBank with permissions ReadAccess and WriteAccess. You could make another Company entity called ChangeInsurance with an entity grant to ChangeBank that has the ReadAccess permission. An employee who is a user, described in the previous section, could also have an entity grant with ReadAccess to the ChangeBank entity.

Like with roles, permissions have no functional meaning in FA. They are just strings passed to your website when a user logs in, and your website can use them however you like.

### A Diagram Of All FusionAuth Types

Below is a diagram illustrating the relationships in the examples from the previous sections, combining the type name with the example object of that type. Read the diagram from bottom to top to see who is a member of what, or who has what attributes.

Note that entities and applications cannot be related, even if they represent the same physical company. Only users can have entity grants to entities.

```mermaid
graph BT
  subgraph Users & Applications
    n1("`*Application*
    **Change Bank**`")
    n2("`*User*
    **Alice**`")
    n3("`*Registration*`")
    n4("`*Role*
    **Employee**`")
    n5("`*Role*
    **Client**`")
    n6("`*User*
    **Bob**`")
    n7("`*Registration*`")
    n8("`*User*
    **Eve**`")
    n9("`*Registration*`")
    n10("`*Group*
    **VIP Clients**`")
  end

  subgraph Entities & Permissions
    n11("`*Entity Type*
    **Company**`")
    n12("`*Entity*
    **Change Bank**`")
    n13("`*Permission*
    **ReadAccess**`")
    n14("`*Permission*
    **WriteAccess**`")
    n15("`*Entity*
    **Change Insurance**`")
    n16("`*Entity Grant*`")
    n17("`*Entity Grant*`")
  end

  n1 --o n4 & n5
  n2 --o n3 & n17
  n3 --o n1 & n4
  n6 --o n7 & n4
  n7 --o n1 & n5
  n8 --o n9 & n10
  n9 --o n1
  n10 --o n1 & n5
  n12 --o n11 & n13 & n14
  n15 --o n11 & n16
  n16 --o n13 & n12
  n17 --o n13 & n12
```

## Representing Hierarchy In FA

None of the FA types are hierarchical. In other words, no types can be nested in any other types. Groups can't be members of groups, applications can't contain other applications, and entities don't have sub-entities.

This is a problem when trying to model organizations that are hierarchical, especially when trying to decide when a user who has permissions to one level of the hierarchy should have permissions to an entity somewhere in the hierarchy.

Let's take an example. Assume that you want to use FA to authorize users in your corporation, Change Corp, to have access to certain documents. Your corporation has two sub-companies: Change Bank and Change Insurance. Each company has many departments, like marketing, sales, finance, operations, and management. Documents belong to a single department in an organization. Companies, departments, and documents have read and write permissions, and an administrative permission (that allows users to change other users' permissions to the department or document). Permissions propagate downwards. So an employee with write permissions to the marketing department in Change Insurance, will have write permissions to all its documents. And an employee with read permissions to Change Corp has read permissions to every document in every department of both sub-companies. But you might have an auditor who you add as a user in FA that has only read access to a specific document in a specific department. This will not give her permissions to any other documents anywhere higher in the organizational hierarchy.

<Aside type="note">
You can probably see some challenges already:
- How do you handle documents that everyone in the corporation needs to read, such as the HR manual, which is managed by the HR department of the top-level corporation? Because permissions don't propagate upwards, you have to individually give read permissions to everyone, instead of relying on the hierarchy to do it automatically.
- What happens when permissions conflict? The operations department might have a passwords document that should have read access only by members of that department, but anyone with read access to the sub-company will have access to the passwords.

There are solutions to these problems, such as including "Deny access" permissions and a "Common" department which has shared documents, and you need to pick what works for your organization. These challenges won't be discussed in this guide, as you can use the techniques shown here to implement your own solution.
</Aside>

Below is a diagram of the company structure to model.

```mermaid
graph BT
  n1[Change Corp]
  n2(Change Bank)
  n3(Change Insurance)

  n4[/Operations/]
  n5[/Finance/]
  n6[/HR/]
  n7[/Operations/]
  n8[/Finance/]
  n9[/HR/]

  n10((Alice))
  n11((Bob))
  n12@{ shape: doc, label: "Passwords doc" }
  n13@{ shape: doc, label: "Financial statements" }
  n14@{ shape: doc, label: "HR manual" }

  n2 --o n1
  n3 --o n1
  n4 --o n2
  n5 --o n2
  n6 --o n2
  n7 --o n3
  n8 --o n3
  n9 --o n3

  n10 --o n4
  n11 --o n5
  n12 --o n4
  n13 --o n5
  n14 --o n9
```

There are a few ways to model this structure in FA. Documents have to be entities and employees have to be users. There are no other types in FA that will work for this. But after that, here are your options:
- Add a finance user to groups representing her company and department, like Change Insurance group and Finance group (with read access). Note the user will have no permissions in the Change Insurance group, otherwise she would have permissions to every document in the company. This group membership shows merely that the user is in the Change Insurance Finance department, and not the Change Bank Finance department. Alternatively, you could have separate groups with compound names, like Change Insurance Finance group and Change Bank Finance group, instead of one group for the company and one group for the department. This will make permissions management simpler, but you will have an exponential number of groups.
- Store every user's company and department as properties in their JSON `user.data` field. This has to be done through the FA API, and cannot be maintained in the FA web interface. You will need to write your own UI app for HR staff to work with FA. TODO json example here



## TODO

- FA -> FusionAuth
- diagram to file
- remove todo

## Brief

Fusionauth wants an example showing how to use permissions in a â€˜complexâ€™ way:

```
Mapping permissions in a hierarchical manner

company -> department -> document
User can be granted permissions (read, write, admin) to any of these.
```
How do you roll it up to know which users have access to document A? Which documents does user B have access to?

Youâ€™d need to store data in the entity.data field to store the tree, then run queries against the document A or user B to find out the answer.

Include a sample app.

Sounds like a bit of a hack, but probably we could do something like a basic Express application that has some concept of `Company -> Group/Department -> Document`, and then show how that information could be stored in Fusionauth instead of within the application itself.

Maybe also some discussion of when it would make sense to do this â€“ reading the example dan provides below, Iâ€™d think that logic should be at the application level rather than in the auth service, so if this is just an example to show off how entity.data can be hacked to add permissions then thatâ€™s fine, but we shoudl add some warning and advise people how to decide what to store in Fusionauth and what should be done in their application database.

