---
title: Modeling Hierarchies
description: Using the FusionAuth Entity Management feature to model hierarchical organizations and users that belong to organizations.
navcategory: developer
section: extend
subcategory: examples
---

import PremiumPlanBlurb from 'src/content/docs/_shared/_premium-plan-blurb.astro';
import Breadcrumb from 'src/components/Breadcrumb.astro';
import InlineField from 'src/components/InlineField.astro';
import InlineUIElement from 'src/components/InlineUIElement.astro';
import Aside from 'src/components/Aside.astro';
import IconButton from 'src/components/icon/Icon.astro';


- [Understand FusionAuth Types And Their Relationships](#understand-fusionauth-types-and-their-relationships)
  - [Applications And Users](#applications-and-users)
  - [Entities And Permissions](#entities-and-permissions)
  - [A Diagram Of All FusionAuth Types](#a-diagram-of-all-fusionauth-types)
- [An Example Company Hierarchy With Permissions](#an-example-company-hierarchy-with-permissions)
- [Options To Model Hierarchy In FA](#options-to-model-hierarchy-in-fa)
- [Evaluating The Options](#evaluating-the-options)
- [Example Node Application](#example-node-application)
  - [Download Example Project And Start FusionAuth](#download-example-project-and-start-fusionauth)
  - [Create Hierarchy Entities](#create-hierarchy-entities)
  - [Grant Entity Permissions To A User](#grant-entity-permissions-to-a-user)
  - [Run Your Website To Calculate All The User Permissions](#run-your-website-to-calculate-all-the-user-permissions)
- [Clean Up](#clean-up)
- [TODO](#todo)



<PremiumPlanBlurb />

This guide discusses ways of modeling hierarchical organizations and entities, with users and permissions, and provides a sample application with some starting code you can use in your own app.

## Understand FusionAuth Types And Their Relationships

Let's start by reviewing all the FA types and how they relate. You need to understand these types well to adjust the hierarchical system design in this guide to suit your situation. If you want to read about FA types in more detail, see the [Core Concepts](https://fusionauth.io/docs/get-started/core-concepts) documentation.

To avoid confusion with FA applications in this guide, the service you provide your users will be called your "website", as opposed to an application, app, or service.

The first set of FA types are: Tenants, Applications, Groups, Roles, and Users. These types manage users logging in to an application. (Applications are sometimes called clients in other systems).

The second set of types are: Entity Types, Entities, Permissions, and Entity Grants. These types were added to FusionAuth in 2021, after the original set of types in the previous paragraph. They are used for machine-to-machine authentication, and as a case-specific way to model things (entities), as opposed to organizations.

### Applications And Users

Think of a tenant as an entirely separate instance of FusionAuth, without actually running a separate instance. A tenant completely separates all users and applications from those in any other tenant, even when they have the same names and email addresses.

An application represents an organization, website, or service that a person (a user) logs in to. A user has personal data, an email address, and any amount of custom data stored in JSON. A user is a member of an application through a registration. Users can have registrations to many applications, or none.

Applications have roles. A role is just a string. A registration can add many roles to a user for an application. Your website can use a user's role however it wants: authorize a user to perform special actions or ignore the role entirely.

A group is a collection of users. A user can belong to multiple groups, so you can think of a group as a tag that can be applied to a user. A group can have many roles in many applications. If a user has a group, and the user is also registered with an application, that user will automatically be granted any roles in the application that the group has.

For example, consider an example of a bank website with clients and employees. The bank website is an application in FA. The application has two roles: client and employee. Your clients and employees are users, that each have a single registration in the bank application. Each registration may give the user either the client or employee role, or both.

If you want, you could make groups called client and employee, with the client and employees roles in the application respectively. Then you would add users to either or both groups, and register the users with the application, but would not need to give the users roles manually. This would be useful if you had a lot of roles. Another use of groups is to tag users with certain attributes, such as VIP users.

<Aside type="warning">
Digital security usually involves three types: users, roles, and permissions. A user can have many roles, and roles can have many permissions. The advantage of not granting users permissions directly are:
- You can add (or remove) permissions to a role and they automatically apply to every user in that role. You don't have to add a permission to a million users individually.
- A user can have multiple roles with multiple permissions, and the user automatically gets the superset of permissions from all their roles. You don't have to consider each user as an individual and specify the exact combination of permissions that their job requires.
- Your website can work only with permissions when checking if a user has rights to do something, and doesn't have to worry about mapping users through roles to permissions itself.

However, FA does not have permissions. There is a GitHub feature request to add them. Vote [here](https://github.com/FusionAuth/fusionauth-issues/issues/15) if you want that feature.

There are two workarounds:
- Treat roles as permissions. In other words, instead of the employee role, make roles called "can edit clients", "can adjust salaries", and so on. When a user logs in with FA, your website will receive a list of exactly what "permissions" (roles) the user has. But now you have lost all the advantages of working with roles described above.
- Manage permissions in your website code. Keep the user and role associations in FA, but link roles to permissions in your website database, not in FA. When a user logs in with FA, your website will go the database and retrieve all permissions you have associated with those roles and add them to the user. This treats FA more as an authentication system than an authorization system.
</Aside>

### Entities And Permissions

An entity in FA is just a name, and can represent anything â€” a company, document, or refrigerator. The only functional aspect to an entity is that it can be used for machine-to-machine authentication with the client credentials OAuth flow. In this case, an entity usually represents a service.

An entity has an entity type. The type of an entity cannot be changed once it has been created. An entity type can have many permissions, which are also just strings.

Both users and entities can be linked to entities by entity grants. An entity grant lists which permissions of an entity the linked user or entity has access to.

For example, you could make an entity type called Company with an entity called ChangeBank with permissions ReadAccess and WriteAccess. You could make another Company entity called ChangeInsurance with an entity grant to ChangeBank that has the ReadAccess permission. An employee who is a user, described in the previous section, could also have an entity grant with ReadAccess to the ChangeBank entity.

Like with roles, permissions have no functional meaning in FA. They are just strings passed to your website when a user logs in, and your website can use them however you like.

### A Diagram Of All FusionAuth Types

Below is a diagram illustrating the relationships in the examples from the previous sections, combining the type name with the example object of that type. Read the diagram from bottom to top to see who is a member of what, or who has what attributes.

Note that entities and applications cannot be related, even if they represent the same physical company. Only users can have entity grants to entities.

```mermaid
graph BT
  subgraph Users & Applications
    n1("`*Application*
    **Change Bank**`")
    n2("`*User*
    **Alice**`")
    n3("`*Registration*`")
    n4("`*Role*
    **Employee**`")
    n5("`*Role*
    **Client**`")
    n6("`*User*
    **Bob**`")
    n7("`*Registration*`")
    n8("`*User*
    **Eve**`")
    n9("`*Registration*`")
    n10("`*Group*
    **VIP Clients**`")
  end

  subgraph Entities & Permissions
    n11("`*Entity Type*
    **Company**`")
    n12("`*Entity*
    **Change Bank**`")
    n13("`*Permission*
    **ReadAccess**`")
    n14("`*Permission*
    **WriteAccess**`")
    n15("`*Entity*
    **Change Insurance**`")
    n16("`*Entity Grant*`")
    n17("`*Entity Grant*`")
  end

  n1 --o n4 & n5
  n2 --o n3 & n17
  n3 --o n1 & n4
  n6 --o n7 & n4
  n7 --o n1 & n5
  n8 --o n9 & n10
  n9 --o n1
  n10 --o n1 & n5
  n12 --o n11 & n13 & n14
  n15 --o n11 & n16
  n16 --o n13 & n12
  n17 --o n13 & n12
```

## An Example Company Hierarchy With Permissions

None of the FA types are hierarchical. In other words, no types can be nested in any other types. Groups can't be members of groups, applications can't contain other applications, and entities don't have sub-entities.

This is a problem when trying to model organizations that are hierarchical, especially when trying to decide when a user who has permissions to one level of the hierarchy should have permissions to an entity somewhere in the hierarchy.

Let's take an example. Assume that you want to use FA to authorize users in your corporation, Change Corp, to have access to certain documents. Your corporation has two sub-companies: Change Bank and Change Insurance. Each company has many departments, like marketing, sales, finance, operations, and management. Documents belong to a single department in an organization. Companies, departments, and documents have read and write permissions, and an administrative permission (that allows users to change other users' permissions to the department or document). Permissions propagate downwards. So an employee with write permissions to the marketing department in Change Insurance, will have write permissions to all its documents. And an employee with read permissions to Change Corp has read permissions to every document in every department of both sub-companies. But you might have an auditor who you add as a user in FA that has only read access to a specific document in a specific department. This will not give her permissions to any other documents anywhere higher in the organizational hierarchy.

Below is a diagram of the company structure to model.

```mermaid
graph BT
  n1[Change Corp]
  n2(Change Bank)
  n3(Change Insurance)

  n4[/Operations/]
  n5[/Finance/]
  n6[/HR/]
  n7[/Operations/]
  n8[/Finance/]
  n9[/HR/]

  n10((Alice))
  n11((Bob))
  n12@{ shape: doc, label: "Passwords doc" }
  n13@{ shape: doc, label: "Financial statements" }
  n14@{ shape: doc, label: "HR manual" }

  n2 --o n1
  n3 --o n1
  n4 --o n2
  n5 --o n2
  n6 --o n2
  n7 --o n3
  n8 --o n3
  n9 --o n3

  n10 --o n4
  n11 --o n5
  n12 --o n4
  n13 --o n5
  n14 --o n9
```

<Aside type="note">
You can probably see some challenges already:
- How do you handle documents that everyone in the corporation needs to read, such as the HR manual, which is managed by the HR department of the top-level corporation? Because permissions don't propagate upwards, you have to individually give read permissions to everyone, instead of relying on the hierarchy to do it automatically.
- What happens when permissions conflict? The operations department might have a passwords document that should have read access only by members of that department, but anyone with read access to the sub-company will have access to the passwords.

There are solutions to these problems, such as including "Deny access" permissions and a "Common" department which has shared documents, and you need to pick what works for your organization. These challenges won't be discussed in this guide, as you can use the techniques shown here to implement your own solution.
</Aside>

## Options To Model Hierarchy In FA

There are a few ways to model this structure in FA. Documents have to be entities and employees have to be users. There are no other types in FA that will work for this. But after that, here are your options:
- **1) Applications and roles**: Add a finance employee, like Alice, to an application representing her company and department, like Change Bank Operations application. Each application will have two roles, read and write, which are effectively permissions not roles. Each department application has to have the company name in its title, instead of being called only Operation, because there is no way to show one application in FusionAuth is linked to another. You will have a combinatorial number of applications, given the number of companies and departments you add. However, you still need to create an application with no department, called Change Bank application, to show that Alice is a member of the company, or you will need to infer it from the department names of which she is a member. You can't use groups instead of applications to model this example because groups do not have permissions. You could use groups to make it easier to link users with applications and roles, but you still need the applications and roles.
- **2) Entities and grants**: Create entity types Company and Department with permissions Read, Write, and IsMember. Read and write are used to show permissions, but IsMember is used to show hierarchy. Create an entity called Change Bank of type Company and entity of Department called Operations. Create an entity grant for Operations to Change Bank with IsMember set to true to show that this Operations entity belongs to the Change Bank entity. Note that it will not be possible to tell departments called Operations in different companies apart by their name alone. You will need to examine each department's entity grant to see which company it belongs to. Create an entity grant for user Alice to entity Change Bank with no permissions, and an entity grant for Alice to Operations with permissions Read and Write. Below is a diagram of this example, which is similar to the earlier types diagram, but includes a department hierarchy now.
  ```mermaid
  graph BT

  subgraph Change Bank
    direction BT
    n0(("`*User*
  **Alice**`"))
    n1@{ shape: doc, label: "*Entity of type Document*
  **Passwords doc**" }
    nBank("`*Entity of type Company*
  **Change Bank**`")
    nOperationsToBanks("*Entity grant*")
    nAliceCompany("*Entity grant*")
    nAliceDepartment("*Entity grant*")
    n16("`*Permission*
    **ReadAccess**`")
    n17("`*Permission*
    **WriteAccess**`")
    n18("`*Permission*
    **IsMember**`")
    nBankOperations[/"`*Entity of type Department*
  **Operations**`"/]
    n19("`*Permission*
    **ReadAccess**`")
    n20("`*Permission*
    **WriteAccess**`")
    n21("`*Permission*
    **IsMember**`")
    n22("*Entity grant*")
    n23("`*Permission*
    **ReadAccess**`")
    n24("`*Permission*
    **WriteAccess**`")
  end

  subgraph Change Insurance
    direction BT
    n5[/"`*Entity of type Department*
  **Operations**`"/]
    n6("*Entity grant*")
    n3("`*Entity of type Company*
  **Change Insurance**`")
    n10("`*Permission*
    **ReadAccess**`")
    n11("`*Permission*
    **WriteAccess**`")
    n12("`*Permission*
    **IsMember**`")
    n13("`*Permission*
    **ReadAccess**`")
    n14("`*Permission*
    **WriteAccess**`")
    n15("`*Permission*
    **IsMember**`")
  end

    n0 --o nAliceCompany & nAliceDepartment
    n1 --o n22 & n23 & n24
    nBank --o n16 & n17 & n18
    n3 --o n10 & n11 & n12
    nBankOperations --o nOperationsToBanks & n19 & n20 & n21
    n5 --o n6 & n13 & n14 & n15
    n6 --o n3 & n12
    nOperationsToBanks --o nBank & n18
    nAliceCompany --o nBank
    nAliceDepartment --o nBankOperations  & n19 & n20
    n22 --o nBankOperations & n21
  ```
  For simplicity's sake this diagram does not include Change Corp entity of entity type Corporation. There are two blocks: one for Change Insurance and one for Change Bank. Ignore the Change Insurance block and concentrate on Change Bank to see how Alice is connected to her department, which is connected to the company. This diagram also shows a document attached to the Operations department. The document itself has needs read and write permissions, for when you want to enable individual access, and is linked to the Operations department via an entity grant with the IsMember permission, in the same way departments are linked to companies.
- **3) User JSON data**: Store every user's company and department as properties in their JSON `user.data` field. This has to be done through the FA API, and cannot be maintained in the FA web interface. You will need to write your own UI app for HR staff to work with FA. With this approach you don't need to use applications, roles, or groups. Below is example JSON data for Alice:
  ```js
  "permissions": {
    "Change Bank": [],
    "Change Bank Operations": ["read", "write"],
    "Change Bank Human Resources manual": ["read"],
  }
  ```
  The last line, regarding permissions to a document, could either be stored manually, as is shown above, or could be an entity grant from Alice to the document. If you remove the last line, you would keep only company permissions in JSON and store document permissions using entities (as shown in the previous option).

## Evaluating The Options

Option 1, using applications, is inferior to the other options and can be discarded. Applications in FA are used to manage user logins, and it will get cluttered and confusing if you have dozens of new applications that are used not for login, but only to track which permissions a user has. This option provides no benefit over using entities instead.

Options 2 and 3, entities versus JSON, are completely opposite approaches. Option 2 explicitly stores the relationship between all organizational departments and all documents and their related permissions in FA. Your website can use the FA API to get a list of all a user's entity grants to the user's documents and departments, and a list of all documents and the department to which they belong, and use both lists to see what a user has access to. Option 3 doesn't use any FA features to store a user's departments and permissions. Instead, you can choose any naming scheme you want to represent your hierarchy. With option 3, it's very important that you are able to map the text in the JSON with the names of your departments stored elsewhere. For instance, your permissions manager code would have to consistently use "Change Bank" and not "ChangeBank" for thousands of lines of JSON across hundreds of users. And how exactly do you know that a document authorization, stored as an entity in FA, called "Change Insurance Financial Statements draft 2042", can be read by a user with the JSON permission `Change Bank: ["read"]`? Do you parse the document title (entity name) to see if it has "Change Bank" in it? This seems extremely error-prone.

Both options 2 and 3 also have a synchronization problem. If you manage document permissions with FA, and name the document entity according to the name the author gives the document in your website, what do you when the document name changes? Or if two documents have the same name?  You can quickly see that relying on a document name won't work. You will have to generate a UUID for a document on your website, and be sure to give the document authorization in FA the same UUID.

Given these problems, option 3 would have to use UUIDs in the user JSON data, and you would have to recreate something very similar to FA's entity management interface in your own website to map UUIDs to hierarchical permissions. Storing some of the user permissions in FA in JSON, and some permissions in the organizational hierarchy in your website database violates the principle of encapsulation. It will result in confusion for your programmers to manage permissions across two different systems. As a result, it would be best to choose between:
- Using FA only for user authentication and keeping all authorization and company structure information in a separate dedicated document management system that uses FA as its authentication gateway. Example document managements systems that can use an external OAuth provider like FA are [Nuxeo](https://doc.nuxeo.com/nxdoc/using-openid-oauth2-in-login-screen) and [M-Files](https://www.m-files.com/products/platform-security). There may be other document managements systems that allow the use of FA, but their documentation does not state it.
- Using option 2 and fully embracing FA to store all permissions and your company structure. Ensure that you use matching UUIDs for the digital document itself, and the authorization to that document stored in FA as an entity.

The next section will provide an example Node application that follows option 2. It uses the FA API to get a list of all documents, and all the logged-in user's direct and hierarchical permissions, and display them.

## Example Node Application


### Download Example Project And Start FusionAuth

Use `git clone` to clone the repository at https://github.com/FusionAuth/fusionauth-example-docker-compose, or download and unzip it.

Open a terminal in the directory containing the repository files.

Run the command below to start FusionAuth.

  ```sh
  cd light
  docker compose up
  ```

<Aside type="note">
  If you have completed any FusionAuth tutorials before, you might need to first delete any existing FusionAuth containers with the same name and the database volumes. Run the command below to do that.

  ```sh
  docker rm fa fa_db; docker compose down -v
  ```
</Aside>

This command started FusionAuth using Kickstart, which automatically creates an example application with an example user called Richard. It saves you the time of having to configure everything yourself when following this tutorial.

- Log in to your FusionAuth web interface at http://localhost:9011/admin and browse to <Breadcrumb>Reactor</Breadcrumb>.
- Enter your license key to activate Reactor and refresh the page.

If you have any trouble with this tutorial, try replacing the FA image in the Docker compose file `fusionauth/fusionauth-app:1.54.0`, in case future versions of FusionAuth introduced a breaking change.

### Create Hierarchy Entities

In this section you'll create the entities and permissions in FA to represent a company hierarchy with documents.

- Browse to <Breadcrumb>Entity Management -> Entity Types</Breadcrumb>.
- Click <InlineUIElement>Add</InlineUIElement>.
- Name the entity type `Company`.
- Add the permissions `Read`, `Write`, and `IsMember` and save the entity type.
- Add another entity type called `Department` with the same permission names and save it.
- Add a final entity type called `Document` with only `Read` and `Write` permissions. Nothing can be a member of a document, so it doesn't need an `IsMember` permission.

![Entity Types in FA](../../../../../public/img/docs/extend/examples/modeling-hierarchy/entityTypes.webp)

Next you'll populate FA with some entities of these types:

- Browse to <Breadcrumb>Entity Management -> Entities</Breadcrumb>.
- Add a new entity.
  - For <InlineField>Name</InlineField> enter `Change Bank`.
  - For <InlineField>Entity type</InlineField> choose `Company`.
  - You don't need to give the entity an Id since FA alone will manage companies and users. Only documents need to share Ids between FA and your website.
  - Save.
- Add another entity of type Company and call it `Change Insurance`.
- Add another entity of type Department and call it `Change Insurance Operations`.
- Add another entity of type Department and call it `Change Bank Operations`.
- Add another entity of type Department and call it `Change Bank Finance`.
- Add another entity of type Document and call it `Passwords`.
  - Give this entity the Id `e52925cb-1072-421f-9f64-a64aacd8a7cb`.
- Add another entity of type Document and call it `Statements`.
  - Give this entity the Id `832bf368-6adc-4ae0-b838-41feeb01ac47`.

![Entities in FA](../../../../../public/img/docs/extend/examples/modeling-hierarchy/entities.webp)

Finally, you need to connect the entities in a hierarchy using permissions as a link.

- In the <InlineUIElement>Select</InlineUIElement> menu for the Change Bank Operations department entity, click <InlineUIElement>Manage</InlineUIElement>.
- Add an entity grant.
- In the search box, enter `Change Bank`, and select it from the dropdown list.
- Enable the <InlineUIElement>IsMember</InlineUIElement> permission.
- Save.
- Return to <Breadcrumb>Entity Management -> Entities</Breadcrumb>.
- Add the Finance department entity to the Change Bank company in the same way as above.
- Add the Change Insurance department entity to the Change Insurance company in the same way as above.
- Change Bank now has two departments and Change Insurance has one.
- Manage the Password document, and give it an entity grant to the Change Bank Operations department with permission IsMember.
  - Notice here that when you search for `Operations`, the search dropdown list provides you only the names `Change Bank Operations` and `Change Insurance Operations`, with no Ids or hierarchical links displayed. So if you had instead called both departments just `Operations`, without indicating the company they belonged to in their name, you wouldn't know which department to choose when trying to add the document to the department. Though it would be more elegant to call the entity by the same name as the real department, just `Operations`, you need to work with the limitations of FusionAuth here to create a makeshift hierarchy. Alternatively, you could create all entities programmatically using the API and entity Ids. That would allow you to use any names you wanted.
- Manage the Statements document, and give it an entity grant to the Change Bank Finance department with permission IsMember.

### Grant Entity Permissions To A User

You haven't used set any read or write permissions yet, because those are linked only to users, or flow implicitly downwards through the company hierarchy set by `IsMember`. So let's add a user to the Operations department.

- Browse to <Breadcrumb>Users</Breadcrumb>.
- From the <InlineUIElement>Select</InlineUIElement> menu for user `Richard`, choose <InlineUIElement>Manage</InlineUIElement>.
- In the <InlineUIElement>Entity grants</InlineUIElement> tab, click <InlineUIElement>Add</InlineUIElement>.
- Search for and add `Change Bank Operations`.
- Enable all three permissions for the user and save.

![User with entity grant in FA](../../../../../public/img/docs/extend/examples/modeling-hierarchy/user.webp)

FA now represents your corporate hierarchy. In the next sections you're going to work with an example website that retrieves and displays all the user's permissions after they have logged in.

### Run Your Website To Calculate All The User Permissions

In this section you'll write a script to get all the direct and indirect (through the company hierarchy) permissions a user has to all documents in FA. All you need is the user's email address or Id. You can use exactly the same code after the user has logged in to your website with FA. (To learn how to make a simple Node.js app that uses FusionAuth, read the [quickstart](/docs/quickstarts/quickstart-javascript-express-web).)

For this script, you'll use TypeScript. It's easy to make errors when working with a tree structure, like these parent and child entities. TypeScript's strong typing will prevent errors, and enable you to see exactly which properties are available on each object. If you prefer JavaScript, you can delete all the type syntax, rename the file with `.js`, and the code will still run fine.

Start by creating the script, called `getPermissions.ts`, and add the type definitions below. Axios will be used to call FA on the network.

```ts
import axios from "npm:axios@1.7.9";

type TUser = {
  id: string,
  email: string,
};

type TEntity = {
  id: string,
  name: string,
  type: {
    id: string,
    name: string,
  }
};

type Grant = {
  id: string,
  permissions: string[]
  entity: TEntity,
};
type TUserGrant = Grant & { userId: string };
type TEntityGrant = Grant & { recipientEntityId: string };

type TPermission = {
  entityId: string,
  entityName : string,
  permissions: Set<string>
}
```

These types show all the objects returned when calling FA, listing only the important properties, and ignoring the other properties. An entity has only a name and a type. There are two types of grants, one for users and one for entities. Note the Id here points to the grant itself. You usually want to use the Id of the entity inside the grant though. A grant's permissions are a list of strings.

The permission type is what you're aiming to find: a document (an entity with a name and Id) and all the permissions a user has to it. These permissions are a set, not an array, to avoid duplicates.

Next, add a function to calculate the user's permissions to every document, which starts with code to get the user from FA, all entities, and all grants from every entity to every other.

```ts
async function getUserPermissions(emailAddress: string): Promise<TPermission[]> {
  // get user, entities, and grants from fusionauth
  const api = axios.create({ baseURL: 'http://fa:9011/api', headers: { 'Authorization': '33052c8a-c283-4e96-9d2a-eb1215c69f8f-not-for-prod' } });

  const { data: { user } }  =              await api.get(`/user`, { params: { email: emailAddress } }) as {data: {user: TUser}};
  const { data: { grants: userGrants } } = await api.get(`/entity/grant/search?userId=${user.id}`) as {data: {grants: TUserGrant[]}};
  const { data: { entities } } =           await api.post(`/entity/search`, { search: { numberOfResults: 10000, queryString: "*" } }) as {data: {entities: TEntity[]}};

  const entityGrants: TEntityGrant[] = [];
  for (const entity of entities) {
    const { data: { grants } } = await api.get(`/entity/grant/search?entityId=${entity.id}`);
    entityGrants.push(...grants);
  }
```

Note that the FA API key is hardcoded into this file and passed to Axios. In reality, you should never commit your key to Git, but keep it in a `.env` file. The rest of the code is simple: it calls the FA API for each type and stores the result returned. Read more about the API for [users](https://fusionauth.io/docs/apis/users), [entities](https://fusionauth.io/docs/apis/entities/entities), and [grants](https://fusionauth.io/docs/apis/entities/grants).

Continue the function above by calculating the permissions for the user for every document, and end the script by calling the function.

```ts
  // the goal: all documents and user's permissions to them
  const permissionsToDocuments: TPermission[] = [];

  // for each document
  for (const document of entities.filter(e => e.type.name == 'Document')) {
    // add document with no starting permissions to list of documents
    permissionsToDocuments.push({ entityId: document.id, entityName: document.name, permissions: new Set() });

    // get list of document and all ancestor entities
    const entitiesWithPermissionsToDocument : TEntity[] = [];
    let currentEntity: TEntity | null = document;
    while (currentEntity != null) {
      entitiesWithPermissionsToDocument.push(currentEntity);
      currentEntity = getEntityParent(currentEntity, entities, entityGrants);
    }

    // if user has permissions to ancestor, add those permissions to document permissions for the user
    for (const entityWithPermissionsToDocument of entitiesWithPermissionsToDocument)
      userGrants.find(grant => grant.entity.id === entityWithPermissionsToDocument.id)
        ?.permissions.map(p => permissionsToDocuments.at(-1)?.permissions.add(p));
  }

  console.log('All documents and permissions to them for ' + emailAddress + '\n');
  console.dir(permissionsToDocuments, { depth: null });
  return permissionsToDocuments;
}

function getEntityParent(entity: TEntity, entities: TEntity[], entityGrants: TEntityGrant[]): TEntity | null {
  for (const entityGrant of entityGrants)
    if (entityGrant.recipientEntityId == entity.id && entityGrant.permissions.includes('IsMember'))
      for (const parentEntity of entities)
        if (parentEntity.id == entityGrant.entity.id)
          return parentEntity;
  return null;
}

await getUserPermissions('richard@example.com');
```

This code is a little tricky if you haven't worked with a tree structure before. Luckily, our example assumes that every entity has only one owner (parent node), so in all searches, once you find a grant with `IsMember` you know you have found the node's only parent. The code starts by looping through every entity that is a document, because we don't care about a user's permissions to other entities. For each document, the code gets all ancestors (the document's department and the department's company). Then it finally checks if the user has any permissions to any of those entities, and adds the permissions to the list of permissions the user has to the document.

In a new terminal, run the commands below to install Axios and run the script to check what permissions Richard has to both documents. Here, to save time, you use Docker again, with the Deno 2 image, which can run TypeScript without any compile step, as well as allowing you to freely mix JavaScript, ES modules, and CommonJS modules. In reality, you could use the TypeScript compiler, and Node, Bun, or any other JavaScript environment you like.

```sh
docker run --platform=linux/amd64 --rm -v ".:/app" -w "/app" denoland/deno:alpine-2.1.3 sh -c  "deno install"

docker run --platform=linux/amd64 --rm --network faNetwork -p 3000:3000 -v ".:/app" -w "/app" -e "PORT=3000" denoland/deno:alpine-2.1.3 sh -c  "deno run --allow-net --allow-read --allow-env --unstable-detect-cjs ./bin/www"
  ```

The result should be as below.

```sh
All documents and permissions to them for richard@example.com

[
  {
    entityId: "e52925cb-1072-421f-9f64-a64aacd8a7cb",
    entityName: "Passwords",
    permissions: Set(3) { "IsMember", "Read", "Write" }
  },
  {
    entityId: "832bf368-6adc-4ae0-b838-41feeb01ac47",
    entityName: "Statements",
    permissions: Set(0) {}
  }
]
```

You can see the user has permissions to the passwords document because he is a member of the Operations department where the document is a member.

The user has no permissions to the financial statements. In the FA web interface, browse to the list of users and manage Richard. Give him an entity grant with permission `Write` to the Change Bank entity.

Now when you run the script again, you'll see he has been given indirect write permissions to the financial statements too.

```sh
All documents and permissions to them for richard@example.com

[
  {
    entityId: "e52925cb-1072-421f-9f64-a64aacd8a7cb",
    entityName: "Passwords",
    permissions: Set(3) { "IsMember", "Read", "Write" }
  },
  {
    entityId: "832bf368-6adc-4ae0-b838-41feeb01ac47",
    entityName: "Statements",
    permissions: Set(1) { "Write" }
  }
]
```

## Clean Up

To remove all the Docker images used in this guide, stop the running containers and run the commands below.

```sh
docker compose down -v
docker rmi postgres:16.0-bookworm fusionauth/fusionauth-app:1.51.2 node:23-alpine3.19
```


## TODO

- FA -> FusionAuth
- diagram to file
- remove todo
- remove admin
- add hlink to this doc from the core concepts doc
- put code in a ritza repo
- add readme
- use sdk. submit bug about user by email error
- use simple script instead of app with login. display result as text

<InlineField></InlineField>
<InlineUIElement></InlineUIElement>