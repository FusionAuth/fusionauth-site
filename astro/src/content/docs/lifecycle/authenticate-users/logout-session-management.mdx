---
title: Logout And Session Management
description: Learn about how FusionAuth handles logout and session management.
navcategory: developer
section: lifecycle
subcategory: authenticate users
codeRoot: https://raw.githubusercontent.com/FusionAuth/fusionauth-example-node-centralized-sessions/main
---
import Aside from 'src/components/Aside.astro';
import Field from 'src/components/Field.astro';
import InlineField from 'src/components/InlineField.astro';
import InlineUIElement from 'src/components/InlineUIElement.astro';
import Breadcrumb from 'src/components/Breadcrumb.astro';
import JSON from 'src/components/JSON.astro';
import {RemoteCode} from '@fusionauth/astro-components';
import ApplicationManagedSessionsStart from 'src/diagrams/docs/lifecycle/authenticate-users/application-managed-sessions-start.astro';
import ApplicationManagedSessionInvalid from 'src/diagrams/docs/lifecycle/authenticate-users/application-managed-session-invalid.astro';
import ApplicationManagedSessionsRequests from 'src/diagrams/docs/lifecycle/authenticate-users/application-managed-sessions-requests.astro';
import ApplicationManagedSessionsLogout from 'src/diagrams/docs/lifecycle/authenticate-users/application-managed-sessions-logout.astro';
import CentralizedSessionsStart from 'src/diagrams/docs/lifecycle/authenticate-users/centralized-sessions-start.astro';
import CentralizedSessionsRequests from 'src/diagrams/docs/lifecycle/authenticate-users/centralized-sessions-requests.astro';
import CentralizedSessionsLogout from 'src/diagrams/docs/lifecycle/authenticate-users/centralized-sessions-logout.astro';
import SSOLogout from 'src/diagrams/docs/lifecycle/authenticate-users/sso-logout.astro';

## Overview

This guide will illustrate logout and session management features in FusionAuth. Logout allows you to revoke access to applications and functionality, while session management lets you manage access to resources.

For web and mobile applications, a session allows servers receiving requests over HTTP to group requests by a single user or application together over time.

[OWASP defines a session](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html) as:

> ... a sequence of network HTTP request and response transactions associated with the same user. Modern and complex web applications require the retaining of information or status about each user for the duration of multiple requests. Therefore, sessions provide the ability to establish variables – such as access rights and localization settings – which will apply to each and every interaction a user has with the web application for the duration of the session.

Each session is tied to a piece of software that is running on a device:

* Richard logs in to ChangeBank with the Chrome browser on his Windows PC. He gets session #1.
* Richard logs in to ChangeBank with the Edge browser on his Windows PC. He gets session #2.
* Richard logs in to the ChangeBank Forum with the Safari browser on his iPhone. He gets session #3.

Applications which delegate authentication to FusionAuth may, but are not required to, delegate session management to FusionAuth. 

## Example Scenario

Consider a system with two applications: 

* ChangeBank 
* ChangeBank Forum

ChangeBank is the same application that you build when [running through our Quickstarts](/docs/quickstarts).

ChangeBank Forum is a forum where people share their favorite stories and advice about getting change.

Both of these applications delegate authentication to FusionAuth. Let's explore sessions and logout through this scenario.

## Types Of Sessions

There are three types of sessions mentioned in this document:

* An **application session** is created after FusionAuth has authenticated a user and the application has completed the token exchange. How this session works (cookie, database entry) is specific to the web or mobile application.
* A **FusionAuth SSO session** is created when a user checks <InlineUIElement>Keep me signed in </InlineUIElement>, or that element is automatically checked. This session is only available when using the [hosted login pages](/docs/get-started/core-concepts/integration-points#hosted-login-pages).
* A **centralized session** is equivalent to a refresh token and is a representation of an application session registered with FusionAuth. This session is available using the API or the hosted login pages.

## Types Of Session Management

When considering session management with FusionAuth, the first question to consider is whether you want to have a centralized session store or not. Another way to think about it is, do you want FusionAuth to know about the sessions for each application? 

This has a number of benefits. With centralized session management, you can:

* capture information about users' sessions across applications such as lifetime or device value
* log users out of application using the FusionAuth admin UI or the API
* have different session lifetimes for different applications, with one place to manage those lifetimes

The downside is that it is more complicated and requires tighter integration with FusionAuth's APIs.

The alternative is to use application managed sessions using the front channel logout. In this situation, FusionAuth doesn't know about the state of the application sessions and relies on the applications to manage them. It has the following attributes:

* No sessions will appear on the <Breadcrumb>Sessions</Breadcrumb> tab.
* You won't be able to revoke sessions via API, though you will still be able to request session revocation. 
* Session timeouts are managed by each application.

### Similarities

Both of these choices support a single logout request affecting many applications, though they use different mechanisms.

Each application delegating authentication to FusionAuth will also have a session which will be used by all requests to that application. This application session may be a cookie based session, a centralized session stored in a database, or you may even use the JWT generated by the authentication event. 

### How To Choose

Here's a table outlining some of the major differences between these two approaches.

| Feature | Centralized Session Store | Application Managed Sessions | 
| -------- | ------- | ------- |
| Level of effort | Medium | Low |
| Revoke sessions across all applications in a tenant on logout | Yes | Yes |
| Revoke sessions for one application on logout | Yes | Yes |
| Revoke sessions for more than one and fewer than all applications on logout | Yes | No |
| Fine grained session revocation, including via API | Yes | No | 
| Precise control of session timeout | Yes | No | 
| Central view of sessions in FusionAuth | Yes | No | 
| Call to FusionAuth required each time a user interacts with your application | Yes | No | 
| Works with FusionAuth SSO, including revocation | Yes | Yes |
| Works with non browser based applications, such as APIs | Yes | No |
| Session revocation webhooks available | Yes | No |
| Can be used without using the hosted login pages | Yes | No |

Let's walk through some scenarios.

## Centralized Session Store

Let's consider a centralized session store and how that would be implemented.

* Make sure to set up the ChangeBank and ChangeBank Forum applications correctly. Make sure the Application has the <InlineField>Refresh token</InlineField> checkbox toggled in the <InlineUIElement>Enabled Grants</InlineUIElement> section. The <InlineField>Generate refresh tokens</InlineField> setting must be enabled as well.
![Configuration of an application to allow the Refresh grant to be used.](/img/docs/lifecycle/authenticate-users/application-configuration-centralized-session-oauth.png)
* Each time you build the authorization URL, request the following scopes. Your `scope` parameter will look something like this: `...&scope=openid%20offline_access&`.
  * `offline_access` which creates the refresh token
  * `openid` which asks for an Id token
* In the ChangeBank and ChangeBank Forum applications, create an **application session** using whatever session solution your web or mobile app framework suggests. Find and store the refresh token Id in this session. The Id is available in the `sid` parameter in the Id token. It is also available in the access token. You should prefer the refresh token Id instead of the refresh token value because the Id will not change even when using one-time use refresh tokens.
  * You could also store this Id in a HttpOnly cookie instead of in a session.
* Whenever a request comes in to either application, call the [Retrieve Refresh Tokens API](/docs/apis/jwt#retrieve-refresh-tokens) to check for the status of the refresh token. This can be done either against the REST API or using one of [the FusionAuth client libraries](/docs/sdks). Pass the Id of the refresh token. If the refresh token doesn't exist or is invalid, deny access and invalidate the application session.
* When a user logs out from either application, revoke the refresh token. You can use the [Revoke Refresh Tokens API](/docs/apis/jwt#revoke-refresh-tokens). You could revoke one or more refresh tokens based on your business logic. See [Flexible Revocation](#flexible-revocation) for more.

### Login Request Flow

<CentralizedSessionsStart alt="Centralized sessions login flow." />

### Normal Request Flow

<CentralizedSessionsRequests alt="Centralized sessions normal request flow." />

### Logout Request Flow

<CentralizedSessionsLogout alt="Centralized sessions logout flow." />

### Checking Session Validity

As mentioned above on each request, you need to check whether or not the refresh token associated with the authentication event on the current device is valid. One way to approach that is with middleware. Here's you you can add middleware to an Express application which will check refresh token validity.

<RemoteCode url={frontmatter.codeRoot + "/changebankforum/src/index.ts"}
  lang="ts"
  tags="redirectmiddleware"/>

The `redirectFunction` is defined in a separate file, which retrieves the Id of the refresh token as a cookie. In this case the refresh token Id is stored as a cookie, but it could also be stored in a session.

<RemoteCode url={frontmatter.codeRoot + "/changebankforum/src/redirectMiddleware.js"}
  lang="ts"
  />

This validity check occurs on every URL by default, but you can ignore certain URLs, either by full path or by path prefix.

Depending on your [session lifetime preferences](#timeouts-and-session-lifetimes) you may need to actually use the refresh token to get the appropriate session lifetime behavior, not just see if it is valid. In that case, you'll want to refresh a JWT using the refresh token rather than simply seeing if it is valid.

### Flexible Revocation

One of the strengths of this approach is that you can determine, based on your business needs, what other refresh tokens need to be revoked.

For example, let's say that when someone logs out of ChangeBank, they are also logged out of the ChangeBank Forum because ChangeBank is the main application. However, if they log out of ChangeBank Forum, you don't usually want to log them out of ChangeBank. Just because someone doesn't want to talk about nickels and dimes doesn't mean they should be logged out of the main application.

An additional requirement is that if you log out of ChangeBank on one device, you are logged out across all devices. The same doesn't hold true with ChangeBank Forum; on that application, logging out only affects the device you logged in on.

In this scenario, whenever the user is logged out of ChangeBank, the code responsible for logging out of ChangeBank should revoke all the refresh tokens for the associated user, including across devices. In contrast, the logout code for the ChangeBank Forum application revokes only one refresh token, that associated with the ChangeBank Forum application on that device.

Handling this kind of complex, flexible revocation scenario is an example of the power of centralized sessions.

Here's example code for the Changebank logout, where all tokens for the user are revoked.

<RemoteCode url={frontmatter.codeRoot + "/changebank/src/index.ts"}
  lang="ts"
  tags="endsession"/>

Here's example typescript code for the Changebank Forum logout. Here you revoke only the refresh token whose Id was previously stored.

<RemoteCode url={frontmatter.codeRoot + "/changebankforum/src/index.ts"}
  lang="ts"
  tags="endsession"/>

TODO review inlinue ui element vs field

There are other possibilities too, beyond complex single-user logout. Since, you can revoke refresh tokens from other systems using the SDKs and APIs, you can code up custom session expiration logic. Scenarios include:

* When building or augumenting a customer service application, adding a button to 'log the user out' to the user details screen.
* If you encountered a [suspicious login based on a FusionAuth webhook](/docs/extend/events-and-webhooks/events/user-login-suspicious), you could revoke the refresh tokens for the user and force them to re-authenticate to ChangeBank but not to the ChangeBank Forum.
* You could revoke the refresh tokens for all users in a group or with a custom attribute if one logs out.
* You can revoke access for a set of users on a schedule, forcing them to login once a week or once every two weeks.

### Use With The Login API

You can also create refresh tokens and use centralized sessions with the [Login API](/docs/apis/login). This is useful if you don't want to use the hosted login pages for your login workflows, but instead want to create your own user interface.

To get refresh tokens with the Login API, configure the Application to allow refresh tokens using the Login API. Make sure the Application has the <InlineField>Enable JWT refres</InlineField> checkbox toggled. The <InlineField>Generate refresh tokens</InlineField> setting must be enabled as well.

![Configuration of an application to allow the Login API to issue refresh tokens.](/img/docs/lifecycle/authenticate-users/application-configuration-centralized-session-login-api.png)

You'll need to build the same refresh token validity check and revocation logic as above into the logout functionality of your application.

### Timeouts And Session Lifetimes

A session can be created by using the Login API, as long as <InlineField>[Generate refresh tokens](/docs/get-started/core-concepts/applications#security)</InlineField> is enabled, or by completing the [OAuth Authorization Code grant](/docs/lifecycle/authenticate-users/oauth/#example-authorization-code-grant) when the `offline_access` scope is requested.

A session will end when:

* It expires.
* It is deleted using the [JWT APIs](/docs/apis/jwt#revoke-refresh-tokens).
* Optionally, as a result of a user changing their password or having their account locked.

When a refresh token is no longer valid, the associated refresh token can't be used to create new JWTs. The JWTs themselves are valid until they expire.

The timeout of refresh tokens are controlled at the Tenant level, under <Breadcrumb>Tenants -> Your Tenant -> JWT</Breadcrumb> in the <InlineUIElement>Refresh token settings</InlineUIElement>. They can be set to the second. Timeouts can be overriden at the Application level as well.

The session lifetime is defined by the Tenant or Application refresh token expiration policy. You can have a fixed lifetime, a lifetime which resets each time the refresh token is used, or a lifetime which resets on use up to a maximum limit. Please review the [Tenant API](/docs/apis/tenants) for more information about the policy and its options.

Ensure that the timeouts of whatever session solution you are using in each application (the session or cookie which stores the refresh token after authentication) is longer than the timeouts of the refresh tokens so you don't inadvertently log someone out.

### Sample Project

Here's [an example application with centralized sessions](https://github.com/FusionAuth/fusionauth-example-node-centralized-sessions). While this shows two web applications, this solution is well suited to APIs or non-browser based applications as well.

## Application Managed Sessions

Application managed sessions are simpler to understand and implement, but don't give you centralized control of sessions. Instead, you are delegating session management to each application.

This approach is simple to set up. To do so:

* Make sure to set up the ChangeBank and ChangeBank Forum Applications correctly.
  * Make sure each application has a <Field>Logout URL</Field>, which is configured under <Breadcrumb>Applications -> Your Application -> OAuth</Breadcrumb>. The code running when the logout URL receives a GET request must destroy the application session. It should be idempotent.
  * Configure each application's <InlineUIElement>Logout behavior</InlineUIElement> to be either <InlineUIElement>All applications</InlineUIElement> or <InlineUIElement>Redirect only</InlineUIElement>. The former logs the user out of all applications in a tenant and the latter logs the user out of only the current application.
* When a user logs out of either the ChangeBank or the ChangeBank Forum application, redirect the user's browser to the [Front-channel Logout endpoint](/docs/lifecycle/authenticate-users/oauth/endpoints#logout).

The Front-channel Logout endpoint will attempt to log the user out of applications based on the <Field>Logout behavior</Field>.

With this option, you still get single logout, though it is less granular. 

If a user logs out of ChangeBank and you don't route them through the Front-channel Logout endpoint, no other applications will be informed of the logout event. In addition, if the user has a FusionAuth SSO session, the next time the user visits FusionAuth (by clicking a login link from the application) they'll be transparently logged back in. 

Let's look at some flows, where the following holds true.

* The <InlineUIElement>Keep me signed in</InlineUIElement> is checked.
* The FusionAuth SSO session has a longer lifetime than the application session.

If you want to review code, the [single sign-on guide walks you through building an example application](/docs/lifecycle/authenticate-users/single-sign-on).

### Login Request Flow

Here's how a login flow would look, where someone moves between the ChangeBank and ChangeBank Forum applications, with the <InlineUIElement>Keep me signed in </InlineUIElement> checked.

<ApplicationManagedSessionsStart alt="Application managed sessions login flowaa." />

If you don't have the <InlineUIElement>Keep me signed in </InlineUIElement> checked, then the user will be prompted to authenticate every time they are sent to FusionAuth, because there will be no [FusionAuth SSO session](#fusionauth-sso). 

### Normal Request Flow

Here's how a normal requests flow would go. Note that FusionAuth is not consulted at all during normal requests.

<ApplicationManagedSessionsRequests alt="Application managed sessions normal requests flow." />

### Request Flow With Invalid Application Session

Only when an application session is invalid is the user sent to FusionAuth. However, FusionAuth still has a valid SSO session, so the user is logged in transparently.

<ApplicationManagedSessionInvalid alt="Application managed sessions when application session is invalid." />

### Logout Request Flow

Here's how a logout flow would look, where someone is logged out of both the ChangeBank and ChangeBank Forum applications.

<ApplicationManagedSessionsLogout alt="Application managed sessions logout flow." />

You can configure whether or not to log out of all applications or only the requested application. Each application must implement an endpoint which knows how to kill the application's session.

### Working With Refresh Tokens

Since you are setting up code at the logout URL endpoint for each application, you could also revoke any refresh tokens associated with the application or user. This is not required, however. This lets you combine this method with the centralized session store scenario. TODO

### Timeouts

With this approach, each application manages its own session timeouts, including idle timeout values. FusionAuth has no insight into the session length.

### Redirecting Users On Logout

Adding the `post_logout_redirect_uri` parameter to the Front-Channel Logout endpoint allows developers to send different users to different logout pages. Each URL that might be used must be included in the authorized redirect URLs list. [Learn more about adding URLs to that list.](/docs/get-started/core-concepts/applications#oauth).

Let's look at a scenario where this would be useful. Suppose you have three tiers of users in the ChangeBank application:

* Enterprise
* Premium
* Free

After a user has logged out, you need to send them to a different page based on their tier. Register these three URLs as authorized redirect URLs:

* `https://changebank.com/logout/thank-you-so-much` for the enterprise customers.
* `https://changebank.com/logout/thanks` for the premium customers.
* `https://changebank.com/logout/consider-paying-us` for the free tier customers.

Then you can, in the method that generates the logout URL, URL escape the correct value and then add it as a `post_logout_redirect_uri` to the Front-Channel Logout endpoint. The user will then be sent to the appropriate thank you page.

### Sample Project

Here's [an example application with application managed sessions](https://github.com/FusionAuth/fusionauth-example-node-sso/).

## FusionAuth SSO 

Let's discuss the FusionAuth SSO session. This session is managed by FusionAuth and is only available if you are using the hosted login pages. It is not available if you are using APIs, though there is an [open feature request](https://github.com/fusionauth/fusionauth-issues/issues/1515).

You can use FusionAuth with or without the SSO session. If you do not use the SSO session, users will be required to authenticate every time their application session expires or if they switch to a different application.

To enable the SSO session, set the `rememberDevice` parameter on the login page to `true`. This value can be enabled by the end user (using a checkbox), or hard coded as a hidden field in the form. You'll also need configure a lifetime for this session, under <Breadcrumb>Tenants -> Your Tenant -> OAuth</Breadcrumb>. The <InlineUIElement>Session Timeout</InlineUIElement> should be set to a non-zero number.

<Aside type="note">
SSO, or single sign-on, in this context is the ability to move between different applications delegating authentication to FusionAuth without signing in repeatedly. [Here's a guide walking through this functionality in more detail](/docs/lifecycle/authenticate-users/single-sign-on).

FusionAuth SSO is not the same as single sign-on to Google, Facebook, or another remote identity provider. Such functionality, also called federation, is handled in FusionAuth by [Identity Providers](/docs/lifecycle/authenticate-users/identity-providers/).
</Aside>

When `rememberDevice` is `true`, FusionAuth creates a session for the user **within FusionAuth**. This means that when the same device visits the Fusionauth hosted login page and the SSO session is valid, the user is automatically logged in. This means they'll be sent to the configured redirect URL with an authorization code which can be exchanged for tokens.

This authentication follows all the same process as an initial login where the user presents credentials. For example, if the application requires the user to be registered and they are not, they'll be presented with an error screen. If the new application requires email verification and the user has not done that yet, they'll be prompted to do so.

The SSO will continue to allow login behavior will continue on this device until one of the following happens:

* the user is logged out by being sent to the Front-Channel logout endpoint
* the SSO session expires
* the SSO session refresh token is revoked via an API call or the admin UI 

Always make sure to revoke the SSO session, as represented by a refresh token, if you want to truly log the user out. You can either redirect the user's browser through the front channel logout or revoke the refresh token.

### Capturing Additional Information At Login

You can pass additional information about the login when using the FusionAuth SSO session by using the `metaData.device.description` attribute. This is added as a hidden form field. Here's an example of what you'd add to the login form if you wanted to capture `yourdatahere`:

```
[@helpers.hidden name="metaData.device.description" value="yourdatahere" /]
```

You can also write JavaScript on the hosted login pages ([only when using advanced themes](https://fusionauth.io/docs/customize/look-and-feel/advanced-theme-editor)) 

This metadata is only available to the SSO session and is not stored in any other refresh tokens. The values can be read by retrieving the SSO refresh token, which is a refresh token with no associated application Id. Here's an example of what that looks like:

<JSON title="Example Response JSON For a Single Refresh Token With Custom Data" src="jwt/refresh-token-custom-data-get-response.json" />

TODO do we want to document this? people already depend on this workaround.

### Session Timeouts and Lifetime

An SSO session will end if you log out of SSO using Front-Channel Logout or if the session expires.

As mentioned above, the liftime of the SSO session is configured at the Tenant level. You can configure it by navigating to <Breadcrumb>Tenants -> Your Tenant -> General</Breadcrumb> and updating the <Field>OAuth session timeout</Field> timeout. Because the SSO session lets users log into all applications, there is no Application level override of the SSO session value.

<Aside type="note">
Previous to version 1.52, setting the SSO session to a low value and enabling other post authentication workflows such as an OAuth consent screen could cause a login workflow to be restarted. See this [GitHub issue for more details](https://github.com/FusionAuth/fusionauth-issues/issues/2736)
</Aside>

### Disabling FusionAuth SSO

If you don't want FusionAuth SSO to be enabled, set the `rememberDevice` parameter to `false`. In this case, there will be no SSO session. You can also set the <InlineUIElement>Session Timeout</InlineUIElement> should be set to zero. 

#### Selectively Disabling FusionAuth SSO

You may want to selectively disable FusionAuth SSO. For example, if you have five applications which delegrate authentication to FusionAuth, you might want to let users transparently migrate between four of them, but have one that is not available to be SSOed into. Let's say that four of the applications are consumer facing, but the fifth is a business application.

Options for preventing this include:

* Putting the business application in a separate tenant.
* Requiring registration for the business application and turning off self-service registration for that application.
* Setting up a transactional webhook, listening for the `PING` `authenticationType` and returning an non `2xx` status to stop the login.

## SAML Single Logout

If you are using FusionAuth as a [SAML IdP](/docs/lifecycle/authenticate-users/saml) you can also enable SAML Single Logout. This lets you work with off the shelf commercial applications which support the [SAMLv2 Single Logout profile](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0-cd-02.html#5.3.Single%20Logout%20Profile|outline).

You can learn more about configuring [SAML Single Logout here](/docs/lifecycle/authenticate-users/saml#logout-request).

## Session Analytics
 
For application managed sessions or SAML sessions, there are no analytics options. 

FusionAuth has limited prebuilt session reporting when using centralized session management. You can view current sessions for a given user by navigating to the <Breadcrumb>Users -> A User</Breadcrumb> and then looking at the <Breadcrumb>Sessions</Breadcrumb> tab.

TODO SCREENSHOT

If you need more in-depth understanding of your sessions and you are using centralized sessions, set up webhooks for [User login](/docs/extend/events-and-webhooks/events/user-login-success), [Refresh Token use](/docs/extend/events-and-webhooks/events/jwt-refresh) and [Refresh Token revocation](/docs/extend/events-and-webhooks/events/jwt-refresh-token-revoke). These events can be stored and correlated based on the user Id to generate statistics around the average length of a session or number of sessions.

## Other Ways To Logout

You can logout using the /api/logout endpoint. This is designed for situations where you store the refresh token in a cookie and want to revoke it from the client without an API key. This is not a typical use case. Using this API does not end the FusionAuth SSO session nor does it give you the ability to revoke other refresh tokens for the user.

## Other Resources

* The [Device Limiting guide](/docs/extend/examples/device-limiting) discusses sessions as well.
* The [Applications Core Concepts](/docs/get-started/core-concepts/applications) covers many of these settings.
* The [Single Sign-on guide](/docs/lifecycle/authenticate-users/single-sign-on) discusses FusionAuth SSO session usage in detail.

