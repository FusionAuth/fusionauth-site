---
title: Logout And Session Management
description: Learn about how FusionAuth handles logout and session management.
navcategory: developer
section: lifecycle
subcategory: authenticate users
codeRoot: https://raw.githubusercontent.com/FusionAuth/fusionauth-example-node-centralized-sessions/main
---
import Aside from 'src/components/Aside.astro';
import Field from 'src/components/Field.astro';
import InlineField from 'src/components/InlineField.astro';
import InlineUIElement from 'src/components/InlineUIElement.astro';
import Breadcrumb from 'src/components/Breadcrumb.astro';
import JSON from 'src/components/JSON.astro';
import {RemoteCode} from '@fusionauth/astro-components';
import ApplicationManagedSessionsStart from 'src/diagrams/docs/lifecycle/authenticate-users/application-managed-sessions-start.astro';
import ApplicationManagedSessionInvalid from 'src/diagrams/docs/lifecycle/authenticate-users/application-managed-session-invalid.astro';
import ApplicationManagedSessionsRequests from 'src/diagrams/docs/lifecycle/authenticate-users/application-managed-sessions-requests.astro';
import ApplicationManagedSessionsLogout from 'src/diagrams/docs/lifecycle/authenticate-users/application-managed-sessions-logout.astro';
import CentralizedSessionsStart from 'src/diagrams/docs/lifecycle/authenticate-users/centralized-sessions-start.astro';
import CentralizedSessionsRequests from 'src/diagrams/docs/lifecycle/authenticate-users/centralized-sessions-requests.astro';
import CentralizedSessionsLogout from 'src/diagrams/docs/lifecycle/authenticate-users/centralized-sessions-logout.astro';
import CentralizedSessionsSessionInvalid from 'src/diagrams/docs/lifecycle/authenticate-users/centralized-sessions-session-invalid.astro';
import SSOLogout from 'src/diagrams/docs/lifecycle/authenticate-users/sso-logout.astro';
import SessionsExpiration from 'src/content/docs/lifecycle/authenticate-users/_sessions-expiration.mdx';

## Overview

This guide will illustrate logout and session management features in FusionAuth. Logout allows you to revoke users' access to applications and functionality, while session management lets you manage and control the access. For web and mobile applications, a session is what allows servers receiving requests over HTTP to group requests by a single user or application together over time. OWASP, an open-source security project, [defines a session](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html) as:

> ... a sequence of network HTTP request and response transactions associated with the same user. Modern and complex web applications require the retaining of information or status about each user for the duration of multiple requests. Therefore, sessions provide the ability to establish variables – such as access rights and localization settings – which will apply to each and every interaction a user has with the web application for the duration of the session.

Applications which delegate authentication to FusionAuth may, but are not required to, delegate session management to FusionAuth.

## Example Scenario

Consider a system with two applications, ChangeBank and ChangeBank Forum. ChangeBank is the same application that you build when [running through FusionAuth Quickstarts](/docs/quickstarts) and lets you make change. ChangeBank Forum is a forum where people share their favorite stories and advice about getting change.

Both of these applications delegate authentication to FusionAuth. Let's explore sessions and logout through this scenario.

Every session is tied to software running on a device. Here are some examples of sessions:

* Richard logs in to ChangeBank with the Chrome browser on his Windows PC. He gets session A.
* Richard logs in to ChangeBank with the Edge browser on his Windows PC. He gets session B.
* Richard logs in to the ChangeBank Forum with the Safari browser on his iPhone. He gets session C.
* Malia logs in to the ChangeBank Forum with the Safari browser on her iPhone. She gets session D.

Each user can have more than one session. Each device can have more than one session (the Windows PC has two). Each hardware device/user-agent pair has a unique session.

## Types Of Sessions

There are three types of sessions relevant to this guide:

* An **application session** is created after FusionAuth has authenticated a user and the application has completed the token exchange, thus logging the user into the application. How exactly this session works (a cookie or database entry) is specific to each web or mobile application.
* A **FusionAuth SSO session** is created when a user checks <InlineUIElement>Keep me signed in </InlineUIElement> or the theme hardcodes that value. This session is available when using the [hosted login pages](/docs/get-started/core-concepts/integration-points#hosted-login-pages) and allows for transparent, automatic authentication between applications that delegate authentication to FusionAuth.
* A **centralized session** is equivalent to a FusionAuth refresh token. It is a representation of an application session registered with FusionAuth. This session can be read or revoked using the API. It can be created during a login event by the hosted login pages or the Login API.

When this guide refers to sessions without any of these prefixes, the statement can apply to any type of session.

## Types Of Session Management

When considering session management with FusionAuth, first consider whether you want to have a centralized session store or not. Do you want FusionAuth to know anything about the sessions for each application? This approach has a number of benefits. With centralized session management, you can:

* capture information about users' sessions across applications such as lifetime, device, or acquisition channel
* log users out of application using the FusionAuth admin UI or the API with fine grained control
* have different session lifetimes for different applications yet retain one location to view or manage lifetimes

The downside of centralized sessions is complexity and tighter integration with FusionAuth's APIs.

The alternative to centralized sessions is application managed sessions. These use the Front-Channel logout. With application managed sessions, FusionAuth doesn't know about anything about session lifetime or other characteristics. Instead, FusionAuth relies on the applications to manage each application session as they see fit. With this approach:

* No values will appear on the <Breadcrumb>Sessions</Breadcrumb> tab under the user details screen in the admin UI.
* You can't use the API to view or manage application sessions.
* You won't be able to revoke application sessions via the API, though you will still be able to request application session revocation. 
* Timeouts are managed by each application and will need to be configured there.

Both options support logging out a user across multiple applications, though they use different mechanisms.

Each application delegating authentication to FusionAuth will also have an application session, as mentioned above. This session is used by all requests to that particular application. In our example, ChangeBank and ChangeBank Forum will each have application sessions. This may be cookie based, stored in a database, or even the JWT generated by the authentication event. These are all viable options.

### Choosing A Session Management Approach

Here's a table outlining some of the major differences between centralized sessions and application managed sessions.

| Feature | Centralized Sessions | Application Managed Sessions | 
| -------- | ------- | ------- |
| Level of effort | Medium | Low |
| Revoke sessions across all applications in a tenant on logout | Yes | Yes |
| Revoke sessions for one application on logout | Yes | Yes |
| Revoke sessions for more than one and fewer than all applications on logout | Yes | No |
| Fine grained session revocation, including via API | Yes | No | 
| Precise control of session timeout | Yes | No | 
| Central view of sessions in FusionAuth | Yes | No | 
| Call to FusionAuth required each time a user interacts with your application | Yes | No | 
| Works with FusionAuth SSO, including revocation | Yes | Yes |
| Works with non browser based applications, such as APIs | Yes | No |
| Session revocation webhooks available | Yes | No |
| Can be used without using the hosted login pages | Yes | No |

Let's examine each of these approaches in more detail.

## Centralized Sessions

Here's how you would implement a centralized session store using FusionAuth. To make this concrete, let's use the example ChangeBank and ChangeBank Forum applications mentioned above.

* Make sure to set up the ChangeBank and ChangeBank Forum Applications correctly inside FusionAuth. Ensure the Application config has the <InlineField>Refresh token</InlineField> checkbox toggled in the <InlineUIElement>Enabled Grants</InlineUIElement> section. The <InlineField>Generate refresh tokens</InlineField> setting must be enabled as well.
![Configuration of an application to allow the Refresh grant to be used.](/img/docs/lifecycle/authenticate-users/application-configuration-centralized-session-oauth.png)
* Each time you request the authorization URL, make sure to your `scope` parameter includes the following scopes. It will look something like this: `&scope=openid%20offline_access`.
  * `offline_access` which creates the refresh token.
  * `openid` which asks for an Id token.
* In the ChangeBank and ChangeBank Forum web or mobile applications, create an application session using whatever session solution your web or mobile app framework prefers. 
* After authentication completes, store the refresh token Id in the application session. The Id is in the `sid` parameter in the Id token. It is also available in the access token. Prefer the refresh token Id instead of the refresh token value. The Id will not change even when using one-time use refresh tokens.
  * You could also store the refresh token Id in a HttpOnly cookie instead of in a session.
* Whenever a request comes in to either the ChangeBank and ChangeBank Forum application, call the [Retrieve Refresh Tokens API](/docs/apis/jwt#retrieve-refresh-tokens) with the stored refresh token Id to check the status of the refresh token. You can cal the REST API directly or using one of [the FusionAuth client libraries](/docs/sdks). If the refresh token doesn't exist or is invalid, deny access and invalidate the application session.
* When a user logs out from either the ChangeBank and ChangeBank Forum application, revoke the refresh token. Use the [Revoke Refresh Tokens API](/docs/apis/jwt#revoke-refresh-tokens). How many tokens and the logic around revocation depends on your business needs. See [Flexible Revocation](#flexible-revocation) for more.

With this approach, you are using the refresh token to tie the ChangeBank or ChangeBank Forum applications to FusionAuth, and checking in with FusionAuth each time a request comes in to either application.

Let's look at some diagrams.

### Flow Diagrams Of Common Use Cases

Let's look at some flow diagramds for a user who:

* logs into ChangeBank and ChangeBank Forum
* interacts with ChangeBank
* logs out of ChangeBank
* tries to access ChangeBank Forum

#### Login Request Flow

This is the flow of a user who logs in to both the ChangeBank and ChangeBank Forum applications who checks the <InlineUIElement>Keep me signed in</InlineUIElement> checkbox on the hosted login pages. The refresh token Id is stored in an application session.

<CentralizedSessionsStart alt="Centralized sessions login flow." />

#### Normal Request Flow

This is the flow of a user who has a valid ChangeBank application session and is interacting with the application. Note that FusionAuth is not consulted at all during normal requests.

<CentralizedSessionsRequests alt="Centralized sessions normal request flow." />

#### Logout Request Flow

This is the flow of a user who is logging out of ChangeBank.

<CentralizedSessionsLogout alt="Centralized sessions logout flow." />

#### Request Flow With Invalid Centralized Session 

This is the flow of a user who was logged into ChangeBank Forum but who has logged out of ChangeBank. They have had their refresh tokens revoked and thus their centralized sessions invalidated.

<CentralizedSessionsSessionInvalid alt="Centralized sessions with a request when sessions have been invalidated." />

### Checking Session Validity

As mentioned above on each request, you must check whether or not the refresh token associated with the authentication event on the current device is valid. How you do that depends on your application, but one approach is to use middleware. Here's example code adding such middlware to an Express application.

<RemoteCode url={frontmatter.codeRoot + "/changebankforum/src/index.ts"}
  lang="ts"
  tags="redirectmiddleware"/>

`redirectFunction` is defined in a separate file. This code retrieves the Id of the refresh token as a cookie. (In this case the refresh token Id is stored as a cookie, but it could also be stored in a session.)

<RemoteCode url={frontmatter.codeRoot + "/changebankforum/src/redirectMiddleware.js"}
  lang="ts"
  />

This check occurs on every request by default, but you can ignore certain URLs, either by full path or by path prefix.

Depending on your [session lifetime preferences](#timeouts-and-session-lifetimes), checking the refresh token is valid using the API may not be enough. 

If you want a rolling window of session validity, for example, you need to use the refresh token to get the appropriate behavior. In that case, you'll want to refresh a JWT using the refresh token rather than simply seeing if the refresh token is valid. This will extend the lifetime of the refresh token. It will also trigger a webhook if one is configured, which can be useful for [analytics](#session-analytics). You can then throw the resulting JWT away.

### Flexible Revocation

One of the strengths of the centralized session approach is customization of refresh token revocation and therefore session invalidation. You can determine, based on your business needs, what other refresh tokens need to be revoked.

For example, let's say that when Richard logs out of ChangeBank, he is also logged out of the ChangeBank Forum. However, if he logs out of ChangeBank Forum, he is *not* logged out of ChangeBank. Just because someone doesn't want to talk about nickels and dimes doesn't mean they should be logged out of the main application.

An additional requirement is that if Richard logs out of ChangeBank on one device, he is logged out across all devices. But for ChangeBank Forum, logging out only affects the device he logged in on.

In this scenario, whenever any user is logged out of ChangeBank, the code responsible for handling that logout event should revoke all the refresh tokens for the associated user, including across devices. In contrast, the logout code for the ChangeBank Forum application revokes only one refresh token, the one associated with the ChangeBank Forum application on that device.

Here's example typescript code for the Changebank logout, where all tokens for the user are revoked.

<RemoteCode url={frontmatter.codeRoot + "/changebank/src/index.ts"}
  lang="ts"
  tags="endsession"/>

Here's example code for the Changebank Forum logout. Here you revoke only the refresh token whose Id was previously stored.

<RemoteCode url={frontmatter.codeRoot + "/changebankforum/src/index.ts"}
  lang="ts"
  tags="endsession"/>

TODO review inlinue ui element vs field

Other revocation scenarios, beyond complex single-user logout, are supported. Since you can revoke refresh tokens from other applications using the SDKs and APIs, with this approach you can have custom session expiration logic. Some example scenarios:

* When building or augumenting a customer service application, add a button to 'log the user out' to the user details screen. The FusionAuth admin UI provides this functionality. See [Session Analytics](#session-analytics) for a screenshot.
* When a [suspicious login](/docs/extend/events-and-webhooks/events/user-login-suspicious) occurs, revoke the refresh tokens for the affected user, and force them to re-authenticate to ChangeBank. You can even set an attribute on the user and [force them to MFA using step up auth](/docs/lifecycle/authenticate-users/multi-factor-authentication#step-up-auth).
* Revoke the refresh tokens for all users in a group or with a custom attribute if any one user logs out.
* Enforce a schedul. Revoke access for users every Friday night, forcing them to login once a week.

All of these are possible because you have programmatic control of the centralized sessions via API and have configured all your applications to check in with FusionAuth.

### Using The Login API

You can also create refresh tokens and therefore use centralized sessions when users log in using the [Login API](/docs/apis/login). If you don't want to use the hosted login pages for your login workflows, but instead want to create your own user interface, you'll use the Login API.

To obtain refresh tokens, configure the Application to allow refresh tokens using the Login API. Make sure the Application has the <InlineField>Enable JWT refresh</InlineField> checkbox toggled. The <InlineField>Generate refresh tokens</InlineField> setting must be enabled too.

![Configuration of an application to allow the Login API to issue refresh tokens.](/img/docs/lifecycle/authenticate-users/application-configuration-centralized-session-login-api.png)

You must build the same refresh token validity check and revocation logic into the logout functionality of your application as was shown above.

### Timeouts And Session Lifetimes

A centralized session can be created by using the Login API, when configured as documented in [Using The Login API](#using-the-login-api), or by completing the [OAuth Authorization Code grant](/docs/lifecycle/authenticate-users/oauth/#example-authorization-code-grant) with the `offline_access` scope requested.

A centralized session will end when:

* It expires.
* It is deleted using the [JWT APIs](/docs/apis/jwt#revoke-refresh-tokens).
* Optionally, as a result of a user changing their password or having their account locked.

The timeout of refresh tokens are controlled at the Tenant level, under <Breadcrumb>Tenants -> Your Tenant -> JWT</Breadcrumb>. In the <InlineUIElement>Refresh token settings</InlineUIElement>, there is a <InlineField>Duration</InlineField> field. Durations have a unit of minutes. The minimum lifetime of a centralized session is one minute. Timeouts can be overriden at the Application level if different web applications need different session durations.

The actual centralized session lifetime is controlled by the Tenant or Application refresh token expiration policy as well as timeout settings. You can have a fixed lifetime, a lifetime which resets each time the refresh token is used, or a lifetime which resets on use up to a maximum duration. Please review the [Tenant API](/docs/apis/tenants) for more information about the policy and its options.

Make sure your application session timeouts is longer than the timeout of the centralized session so you don't inadvertently log someone out before their centralized session expires.

### Testing Logins

If a user is repeatedly logging in and creating a refresh token, they should log out or revoke the tokens periodically. This often happens in automated testing. The list of tokens is visible in the admin UI. Here's an example:

![User session details.](/img/docs/lifecycle/authenticate-users/users-session-tab-centralized-session.png)

If the list of sessions is long in a production or QA context, there may be an issue.

### But Aren't Refresh Tokens Used For Minting JWTs?

Yes. Yes they are.

But for FusionAuth, refresh tokens serve two purposes.

* Refresh tokens represent a user/device pair as a session, as documented above.
* Refresh tokens also can be used as plain RFC 6749 compatible refresh tokens, only for creating access tokens via the Refresh grant. These access tokens would then be presented to your APIs or servers for access.

### Working With The FusionAuth SSO Session

If you are using the FusionAuth SSO session as well as centralized sessions, you can delete it by deleting all the refresh tokens associated with a user, or by send the user to the Front-Channel Logout endpoint as well as revoking refresh tokens.

### Sample Project

Here's [an example application showing how to use centralized sessions](https://github.com/FusionAuth/fusionauth-example-node-centralized-sessions). While this example focuses on two web applications, the centralized sessions approach is well suited to APIs or non-browser based applications as well.

## Application Managed Sessions

Application managed sessions, the other main approach, are simpler to understand and implement. However, they don't offer centralized control of your users' sessions. Instead, you delegate session management to each application.

Let's discuss the ChangeBank and ChangeBank Forum applications again. To set up application managed sessions for these application:

* Set up the ChangeBank and ChangeBank Forum Applications correctly.
  * Give each application a <Field>Logout URL</Field>, configured under <Breadcrumb>Applications -> Your Application -> OAuth</Breadcrumb>. The endpoint running at that endpoint receives a GET request when a user logs out. This endpoint must destroy the application session and should be idempotent.
  * Configure each application's <InlineUIElement>Logout behavior</InlineUIElement> to be either <InlineUIElement>All applications</InlineUIElement> or <InlineUIElement>Redirect only</InlineUIElement>. The former choice logs the user out of all applications in a tenant by making a request to each application's configured <InlineField>Logout URL</InlineField>. The latter logs the user out of the application for which the logout request was initiated.
* When a user logs out of either the ChangeBank or the ChangeBank Forum application, redirect the user's browser to the [Front-channel Logout endpoint](/docs/lifecycle/authenticate-users/oauth/endpoints#logout).

The Front-channel Logout endpoint will attempt to log the user out of other applications based on the <Field>Logout behavior</Field>. You still get logout of multiple applications, though it is less granular than the centralized sessions approach. If a user logs out of ChangeBank and you don't route them through the Front-channel Logout endpoint, no other applications will be informed of the logout event. In addition, if the user has a FusionAuth SSO session, the next time the user tries to log in, they'll be sent to FusionAuth which will transparently log them in. 

If you want to review code around this behavior, the [single sign-on guide walks you through building an example application](/docs/lifecycle/authenticate-users/single-sign-on).

Let's look at some example flows of a user logging into the ChangeBank and ChangeBank Forum applciations.

### Flow Diagrams Of Common Use Cases

Let's look at some flow diagrams for a user who:

* logs into ChangeBank and ChangeBank Forum
* interacts with ChangeBank
* logs out of ChangeBank
* tries to access ChangeBank Forum

In these diagrams, the ChangeBank application is configured to log users out of all applications on logout. That is, <InlineUIElement>Logout behavior</InlineUIElement> is <InlineUIElement>All applications</InlineUIElement>.

#### Login Request Flow

This is the flow of a user who logs in to both the ChangeBank and ChangeBank Forum applications who checks the <InlineUIElement>Keep me signed in</InlineUIElement> checkbox on the hosted login pages.

<ApplicationManagedSessionsStart alt="Application managed sessions login flowaa." />

If you don't have the <InlineUIElement>Keep me signed in </InlineUIElement> checked, then the user will be prompted to authenticate every time they are sent to FusionAuth, because there will be no [FusionAuth SSO session](#fusionauth-sso). 

### Normal Request Flow

This is the flow of a user who has a valid ChangeBank application session and is interacting with the application. Note that FusionAuth is not consulted at all during normal requests.

<ApplicationManagedSessionsRequests alt="Application managed sessions normal requests flow." />

### Request Flow With Invalid Application Session

This is the flow when an application session expires. The user is then sent to FusionAuth. However, FusionAuth still has a valid SSO session, so the user is logged in transparently.

<ApplicationManagedSessionInvalid alt="Application managed sessions when application session is invalid." />

### Logout Request Flow

This is the flow of a user who is logging out of ChangeBank, and 

<ApplicationManagedSessionsLogout alt="Application managed sessions logout flow." />

### Timeouts And Session Lifetimes

With this approach, each application manages session timeouts, including idle timeouts.

FusionAuth has no information on the application session duration.

### Redirecting Users On Logout

Adding a `post_logout_redirect_uri` parameter to the [Front-Channel Logout endpoint](/docs/lifecycle/authenticate-users/oauth/endpoints#logout) request allows you to send different users to different logout pages. 

Each URL that might be added as a value must be included in the Application's <InlineField>Authorized redirect URLs</InlineField> list. [Learn more about adding URLs to that list.](/docs/get-started/core-concepts/applications#oauth).

Let's look at a scenario where this would be useful. Suppose you have three tiers of users in the ChangeBank application:

* Enterprise
* Premium
* Free

After a user has logged out, you need to send them to a different page based on their tier. Create these URLs with the appropriate messaging and register them as authorized redirect URLs.

* `https://example.com/logout/thank-you-so-much` for the enterprise customers, where you thank them profusely for using your software.
* `https://example.com/logout/thanks` for the premium customers, where you thank them.
* `https://example.com/logout/consider-paying-us` for the free tier customers, where you thank them but also try to upsell them.

Then, in the method that generates the link to the Front-Channel logout URL, add the correct value as a `post_logout_redirect_uri`. Make sure you URL escape the url. The user will then be sent to the appropriate thank you page.

For example, if FusionAuth is running at `https://auth.example.com`, the ChangeBank application has a client id of `e9fdb985-9173-4e01-9d73-ac2d60d1dc8e`, and the user is a premium user, you'd build a URL like this: `https://auth.example.com/oauth2/logout?client_id=e9fdb985-9173-4e01-9d73-ac2d60d1dc8e&post_logout_redirect_uri=https%3A%2F%2Fexample.com%2Flogout%2Fthanks`.

### Working With Centralized Sessions

The code at the <InlineField>Logout URL</InlineField> which has to terminate the application session can also make API calls and revoke FusionAuth refresh tokens. This is not required, but doing so lets you combine this approach with centralized sessions.

### Sample Project

Here's [an example application with application managed sessions](https://github.com/FusionAuth/fusionauth-example-node-sso/).

## FusionAuth SSO 

In [Types of Sessions](#types-of-sessions), you learned briefly about the FusionAuth SSO Session. Let's discuss it in more depth. This session is managed by FusionAuth and is only available if you are using the hosted login pages. It is not available if you are using the Login APIs, though there is an [open feature request](https://github.com/fusionauth/fusionauth-issues/issues/1515) to change that.

You can use FusionAuth with or without the FusionAuth SSO session. If you do not use this session, users must authenticate every time their application session expires or if they switch to a different application.

To enable the SSO session, set the `rememberDevice` parameter on the login page to `true`. This is the <InlineUIElement>Keep me signed in </InlineUIElement> checkbox in the default theme. This parameter can be set by the end user with a a checkbox, or hard coded as a hidden field in the login form.

You may want to customize the lifetime for this session, under <Breadcrumb>Tenants -> Your Tenant -> OAuth</Breadcrumb>. The <InlineUIElement>Session Timeout</InlineUIElement> should be set to a positive integer. The unit is seconds. Since the FusionAuth SSO session lets users log into every application in a tenant, there is no application level override of the SSO session duration.

<Aside type="note">
In this context, SSO or single sign-on, is the ability of a user to switch between different applications without authenticating each time. It is accomplished by delegating authentication to FusionAuth. [Here's a guide walking through this functionality in more detail](/docs/lifecycle/authenticate-users/single-sign-on).

FusionAuth SSO is not the same as single sign-on to Google, Facebook, or another external identity provider. Such functionality, also called federation, is handled in FusionAuth by [Identity Providers](/docs/lifecycle/authenticate-users/identity-providers/).
</Aside>

When `rememberDevice` is `true`, FusionAuth creates a session for the user **within FusionAuth**. When the same device visits the Fusionauth hosted login page with a valid SSO session, the user is transparently logged in. They'll be sent to the configured application redirect URL with an authorization code which can be exchanged for tokens.

This authentication flow follows the same process and rules as any login where the user is required to present credentials. For example, if the second application requires the user to be registered and they are not, they'll be presented with an error screen. If the new application requires email verification and the user has not completed such a verificaiton, they'll be prompted to do so.

### Capturing Additional Information At Login

You can pass additional information about the login when using the FusionAuth SSO session by using the `metaData.device.description` attribute. This should be a hidden form field added to the login page. Here's an example of what you'd add to the login form if you wanted to capture `yourdatahere`:

```
[@helpers.hidden name="metaData.device.description" value="yourdatahere" /]
```

You can write JavaScript to run on the login page [only when using advanced themes](/docs/customize/look-and-feel/advanced-theme-editor), so the hidden field value could be dynamically set. For example, you could pull a value from the URL parameter list and place it in that hidden field.

This metadata is only available to the FusionAuth SSO session. It is not stored in any other refresh tokens generated during a user authentication.

TODO is this something we want to document 

The values can be read by retrieving the FusionAuth SSO refresh token, which has no associated application Id. Here's an example of what that looks like:

<JSON title="Example Response JSON For a Single Refresh Token With Custom Data" src="jwt/refresh-token-custom-data-get-response.json" />

### Session Timeouts and Lifetime

The FusionAuth SSO session allows transparent authentication on one browser or device until one of the following happens:

* the SSO session expires
* the user is logged out by being sent to the Front-Channel logout endpoint
* the refresh token representing the FusionAuth SSO session is revoked via an API call or the admin UI 

<Aside type="note">
Previous to version 1.52, setting the SSO session to a low value and enabling other post authentication workflows such as an OAuth consent screen could cause a login workflow to be restarted. See this [GitHub issue for more details](https://github.com/FusionAuth/fusionauth-issues/issues/2736).
</Aside>

<SessionsExpiration />

### Disabling FusionAuth SSO

If you don't want FusionAuth SSO to be enabled, set the `rememberDevice` parameter to `false` in the login page. In this case, there will be no SSO session. You can also set the <InlineUIElement>Session Timeout</InlineUIElement> to zero. 

You may want to selectively disable the FusionAuth SSO session. For example, if you have five applications which delegrate authentication to FusionAuth, you might want to let users transparently log in between four of them, but have one that is not available to be SSOed into. Let's say that four of the applications are consumer facing, but the fifth is a business application.

Options to implement this behavior include:

* Place the business application in a separate FusionAuth tenant. This works, but now your users need to manage two separate logins and there might be credential drift. You can work around this by having users who need access to the business application and the consumer facing applications use the same Identity Provider to log in across tenants.
* Require registration for the business application and turning off self-service registration for that application. Then you'll need to add a registration for all users who need access to the business application manually or using the API.

## Session Analytics
 
For application managed sessions, there are no analytics options, as FusionAuth doesn't capture any metrics.

FusionAuth has limited prebuilt session reporting when using centralized session management. View current sessions for a user by navigating to <Breadcrumb>Users -> A User</Breadcrumb> in the administrative user interface. Then look at the <Breadcrumb>Sessions</Breadcrumb> tab.

![User session details.](/img/docs/lifecycle/authenticate-users/users-session-tab-centralized-session.png)

If you need more in-depth insights into sessions, set up webhooks for:

* [User login](/docs/extend/events-and-webhooks/events/user-login-success), sent when a session is created.
* [Refresh Token use](/docs/extend/events-and-webhooks/events/jwt-refresh), sent when a session is extended. 
* [Refresh Token revocation](/docs/extend/events-and-webhooks/events/jwt-refresh-token-revoke), sent when a session is revoked.

These events can be stored and correlated based on the user Id to generate statistics around the average duration of a session, data attributes, or number of sessions.

## Other Ways To Logout

While refresh token revocation, calling the <InlineField>Logout URL</InlineField> and using the Front-Channel Logout are the main ways of logging a user out of FusionAuth, there are some other options too.

### SAML Single Logout

If you are using FusionAuth as a [SAML IdP](/docs/lifecycle/authenticate-users/saml) you can also enable SAML Single Logout. FusionAuth will then work with off the shelf commercial applications which support the [SAMLv2 Single Logout profile](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0-cd-02.html#5.3.Single%20Logout%20Profile|outline).

Learn more about configuring [SAML Single Logout here](/docs/lifecycle/authenticate-users/saml#logout-request).

### Logging Out Of Identity Providers

FusionAuth does not support logging the user out of Identity Providers used to authenticate. In other words, if someone logs in using a [Google Identity Provider](/docs/lifecycle/authenticate-users/identity-providers/social/google), then logs out of FusionAuth, they won't be logged out of Google. This is typically the behavior you want.

You could work around this if the Identity Provider has a well known logout endpoint and you add that as a `post_logout_redirect_uri`.

### the `/api/logout` Endpoint

You can use the [`/api/logout` endpoint](/docs/apis/login#logout-a-user) in certain circumstances.

This is designed for situations where you store the refresh token in a cookie and want to revoke it from the client without an API key.

Using this endpoint is not a common use case. 

## Other Resources

* The [Device Limiting guide](/docs/extend/examples/device-limiting) discusses sessions as well.
* The [Applications Core Concepts](/docs/get-started/core-concepts/applications) covers many of these settings.
* The [Front-Channel Logout Endpoint](/docs/lifecycle/authenticate-users/oauth/endpoints#logout) documents this form of logout.
* The [Single Sign-on guide](/docs/lifecycle/authenticate-users/single-sign-on) discusses FusionAuth SSO session usage in detail.


TODO https://github.com/FusionAuth/fusionauth-site/issues/2551

