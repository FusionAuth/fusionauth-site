---
title: Migration From Ping Identity
description: Learn how to migrate your users to FusionAuth from Ping Identity.
section: lifecycle
subcategory: migrate users
category: bulk
---
import MappingUserAttributes from 'src/content/docs/lifecycle/migrate-users/bulk/_mapping-user-attributes.mdx';
import SocialLoginNote from 'src/content/docs/lifecycle/migrate-users/bulk/_social-login-note.mdx';
import SocialLoginMigration from 'src/content/docs/lifecycle/migrate-users/bulk/_social-login-migration.mdx';
import OtherEntitiesIntro from 'src/content/docs/lifecycle/migrate-users/bulk/_other-entities-intro.mdx';
import Aside from 'src/components/Aside.astro';
import InlineField from 'src/components/InlineField.astro';
import ScrollRef from 'src/components/ScrollRef.astro';
import SetUpFusionauth from 'src/content/docs/lifecycle/migrate-users/bulk/_set-up-fusionauth.mdx';
import CreateTestTenant from 'src/content/docs/lifecycle/migrate-users/bulk/_create-test-tenant.mdx';
import CreateTestApplication from 'src/content/docs/lifecycle/migrate-users/bulk/_create-test-application.mdx';
import CreateApiKeySocial from 'src/content/docs/lifecycle/migrate-users/bulk/_create-api-key-social.mdx';
import InlineUIElement from 'src/components/InlineUIElement.astro';
import GetScript from 'src/content/docs/lifecycle/migrate-users/bulk/_get-script.mdx';
import VerifyImport from 'src/content/docs/lifecycle/migrate-users/bulk/_verify-import.mdx';
import FinalDestination from 'src/content/docs/lifecycle/migrate-users/bulk/_final-destination.mdx';
import WhatNext from 'src/content/docs/lifecycle/migrate-users/bulk/_what-next.mdx';
import AdditionalSupport from 'src/content/docs/lifecycle/migrate-users/bulk/_additional-support.mdx';

export const migration_source_name = 'Ping Identity';
export const migration_source_dir = 'pingidentity';
export const script_supports_social_logins = 'true';
export const add_tenant_image_role = 'bottom-cropped';

## Overview

This document will help you migrate from Ping Identity to FusionAuth.

This guide assumes you have installed FusionAuth. If you have not, please [view our installation guides](/docs/get-started/download-and-install) and install FusionAuth before you begin. For more general migration information, please view the [FusionAuth migration guide](/docs/lifecycle/migrate-users/bulk/general).

There are a number of different ways applications can be integrated with Ping IdentityServer, and it would be difficult to cover them all. This guide focuses on migrating user data, including profile data and passwords. However, Ping IdentityServer does not allow for password hash export. Therefore, you must perform a slow migration if you donâ€™t want to force users to reset their passwords.

Alternatively, you can do a bulk migration and force everyone to reset their passwords. This option is discussed below, but the primary focus of this guide is enabling you to migrate your users from Ping IdentityServer without requiring any password resets.

## Planning Considerations

### Slow Migration or Bulk Migration

To preserve your users' passwords, you need to perform a slow migration. Users log in to FusionAuth with their Ping IdentityServer credentials, and FusionAuth transparently migrates their data. Slow migrations in FusionAuth use Connectors, a paid feature.

If, on the other hand, resetting user passwords is acceptable, a <ScrollRef target="Bulk Migration" /> can work for you. Review that section for more details on the required steps. You may also perform a bulk migration after a slow migration has run for a while. Active users can be transparently migrated and infrequent users may not mind resetting their password.

You can learn more about the [types of migrations that FusionAuth supports here](/docs/lifecycle/migrate-users/bulk/general#types-of-migrations).

### Mapping User Attributes

<MappingUserAttributes migration_source_name={migration_source_name} />

### One Tenant or Many

The PingIdentity platform uses an organization-based model to define tenant accounts and their related entities. The organization is the top-level identifier. It defines your entire enterprise within the platform.
(https://docs.pingidentity.com/r/en-us/pingone/p1_c_introduction). FusionAuth  has the concept of [Tenants](/docs/get-started/core-concepts/tenants). Both of these include data about users, applications and other configuration.

Each tenant in FusionAuth is a distinct user space. You may choose to merge multiple PingOne organizations into one FusionAuth tenant or keep them separate.

Learn more about [FusionAuth tenants](/docs/extend/examples/multi-tenant).

### Identity Providers

With PingIdentity , you can use the PingOne user directory or an external identity provider (IdP). Using an external IdP allows linked users to authenticate using the credentials provided by the external IdP. An external IdP includes mapping PingOne user attributes to attributes from the IdP(https://docs.pingidentity.com/r/en-us/pingone/p1_c_identityproviders). 
With FusionAuth, these are also called [Identity Providers](/docs/lifecycle/authenticate-users/identity-providers/).

Review the supported FusionAuth [Identity Providers](/docs/lifecycle/authenticate-users/identity-providers/) to ensure any you need are supported. At this time, while there is considerable overlap between the supported identity providers, there are a number of differences.

If not supported explicitly, a provider may work with an OIDC or SAML connection. Otherwise, please open a [feature request](https://github.com/fusionauth/fusionauth-issues/).

<Aside type="note">
Importing PingIdentity users stored in an external identity provider is more straightforward because you can use the Import API; you don't have to perform a slow migration. Many of the steps in <ScrollRef target="Bulk Migration" /> will apply.
</Aside>

To retrieve the user information, use the approach documented in the <ScrollRef target="Export User Data From PingIdentity" /> section.

<SocialLoginNote migration_source_name={migration_source_name} script_supports_social_logins={script_supports_social_logins} />

<SocialLoginMigration />

## Other Entities

<OtherEntitiesIntro other_migrated_entities="app clients or password policies" />

* PingIdentity uses Flows in DaVinci. A flow is a user journey, such as registration or authentication, built from a set of capabilities and logical operators(https://docs.pingidentity.com/r/en-us/davinci/davinci_flows). FusionAuth has a similar concept called [Lambdas](/docs/extend/code/lambdas/). FusionAuth also has [webhooks](/docs/extend/events-and-webhooks/) fired at certain points in the user lifecycle; in certain configurations, they can also stop a particular authentication flow.
* In PingIdentity a role is a collection of permissions that can be assigned to a user, application, or connection(https://docs.pingidentity.com/r/en-us/pingone/p1_c_roles). FusionAuth has [roles](/docs/get-started/core-concepts/roles) that are configured on an application by application basis and made available in a token after a successful authentication.
* PingIdentity also allows using groups to organize a collection of user identities can make it easier to manage access to applications(https://docs.pingidentity.com/r/en-us/pingone/p1_c_groups).
* PingIdentity also makes use of populations:A population defines a set of users and can help you make user management simple(https://docs.pingidentity.com/r/en-us/pingone/p1_c_populations).
* PingIdentity uses DaVinci, an orchestration platform that lets you create flows using connections and logical operators. These flows guide users through defined processes that can present customized pages, modify values, or perform other actions(https://docs.pingidentity.com/r/en-us/davinci/davinci_landing_page). In FusionAuth, [Applications](/docs/get-started/core-concepts/applications) are a similar construct, but users are associated with them through [Registrations](/docs/get-started/core-concepts/registrations). 
* PingIdentity sends emails on your behalf, such as forgot password notifications. FusionAuth can do so too; [the templates are customizable](/docs/customize/email-and-messages/).
* PingIdentity Client Credentials grant. FusionAuth offers a constrained version of this using [Entity Management](/docs/get-started/core-concepts/entity-management); this is available in all paid editions.
* PingIdentity allows for custom attributes, but they must be configured at the Directory level. In FusionAuth, as mentioned above, custom user attributes are stored on the `user.data` field and are dynamic, searchable and unlimited in size. Any valid JSON value may be stored in this field.
* PingIdentity supports MFA. FusionAuth also [supports MFA](/docs/lifecycle/authenticate-users/multi-factor-authentication), which may be enabled for a tenant and configured for a user at any time.

<Aside type="note">
In FusionAuth, users are explicitly mapped to applications with a [Registration](/docs/get-started/core-concepts/registrations).
In PingIdentity 
    * Users gets assigned to a directory in the environment as part of an organization.
    * These users then by default gets access to the applications defined in the this environment. but might be dependent on certain roles.
</Aside>

#### Differences

In addition to the different names for common functionality outlined above in <ScrollRef target="Other Entities" />, there are some fundamental differences between FusionAuth and PingIdentity. If your application relies on PingIdentity specific functionality, please review this section carefully.

* PingIdentity has certain pricing limitations (https://www.pingidentity.com/en/company/contact-sales.html), like number . FusionAuth has no user limit. Instead, you are limited by the resources provided to a FusionAuth instance, such as memory, CPU and database capacity.
* FusionAuth does not support custom scopes. There is an [open feature request](https://github.com/FusionAuth/fusionauth-issues/issues/275).

Once you've planned the migration of other entities, the next step is to set up FusionAuth to connect to PingIdentity to import users during login.

### Login UI

PingIdentityServer allows custom branding and theming on the ui. Login pages are highly variable across  PingIdentity instances(https://docs.pingidentity.com/r/en-us/pingone/p1_c_branding_themes).This is beyond the scope of this document.

FusionAuth's login experience follows two paths. You can choose to build your own login pages or use FusionAuth's hosted login pages. [Read more about these choices](/docs/get-started/core-concepts/integration-points#login-options).

### Bulk Migration
## Export User Data From PingIdentity

PingIdentity provides a rest api to perform management functions.(https://apidocs.pingidentity.com/pingone/platform/v1/api/#get-read-user-or-users). 
One of these endpoints allow you to read the user information in json format,

We recommend exporting your user information in JSON format so that you can import the data into FusionAuth using the FusionAuth API. 

## Creating the user file
We've created a sample python export program to export users from a PingIdentity Server  to a JSON file.  

Clone the repo and open the solution in Visual Studio Code. Make modifications appropriate to your environment and needs.

The following fields need to be populated from your environment:
* envID = the id of the environment from where the users will be exported.
* access_token = To connect to the api and export the users, you will need to create a worker Application in your Ping environment.Some samples of how to do it is provided here(https://docs.pingidentity.com/r/en-us/pingone/p1az_adding_worker_app).
  Provide sufficient permissions to access your user data and also generate a access token, to use in the Export application.  

Below find the sample python export application. Make changes for your environment and needs 
- ExportPingUsers.py
```python

#python -m venv venv
#.\venv\Scripts\activate
#pip install requests
import requests
from requests.auth import HTTPDigestAuth
import json

apiPath ='https://api.pingone.com/v1'

method_call = 'users'
envID ='ADD YOUR ENVIRONMENT ID'
access_token = "ADD YOUR ACCESS TOKEN"
base_url =F'{apiPath}/environments/{envID}/'

 
#This method can be enhance to add more or less data from the main export i.e. Custom Attributes 
def transform_json(input_json):
    transformed_users = []
  
    for user in input_json["_embedded"]["users"]:
        transformed_user = {
            "active": user["enabled"],
            "birthDate": None,
            "insertInstance": None,  # Replace with appropriate value
            "data": {
                "migrated": True,  # Replace with appropriate value
                "favoriteColors": None,  # Replace with appropriate value
            },
            "email": user["email"],
            "expiry": None,
            "firstName":'',# ["name"]["family"],
            "fullName": '',#user["name"]["formatted"],
            "id": user["id"],
            "lastLoginInstant": 0,
            "lastName": user["name"]["family"],
            "middleName": "",
            "mobilePhone": "",
            "password": None,  # Replace with appropriate value
            "salt": None,  # Replace with appropriate value
            "factor": 10000,
            "encryptionScheme": "salted-pbkdf2-hmac-sha256",
            "passwordChangeRequired": False,
            "passwordLastUpdateInstant": 0,
            "preferredLanguages": ["en"],
            "identityProviders": {},
            "timezone": None,
            "twoFactorEnabled": False,
            "username": user["username"],
            "verified": True,  # Replace with appropriate value
        }

        transformed_users.append(transformed_user)

    result_json = {"users": transformed_users}
    return result_json


def main():
    url = base_url + method_call
    data = {}

    headers = {
        'Authorization': 'Bearer ' +access_token,
    }

    response = requests.get(
        url,
        
        headers=headers,
        timeout=30
    )

    print(response.status_code)  

    result = response.json()
    with open("org.json", "w") as json_file:
        json.dump(result, json_file, indent=2)


    output = transform_json(result) 

    with open("users.json", "w") as json_file:
        json.dump(output, json_file, indent=2)



if __name__ == "__main__":
    print("Exporting data....")
    main()
    print("Exporting done.")

```
Make sure the requirements (#pip install requests) for the python script is installed. 
Execute the script.  
``` powershell
    python ExportPingUsers.py
```

The data received from PingIdentity looks like below:

```json
{
    "_links": {
        "self": {
            "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users?limit=100"
        }
    },
    "_embedded": {
        "users": [
            {
                "_links": {
                    "password": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c/password"
                    },
                    "password.set": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c/password"
                    },
                    "account.sendVerificationCode": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c"
                    },
                    "linkedAccounts": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c/linkedAccounts"
                    },
                    "self": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c"
                    },
                    "password.check": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c/password"
                    },
                    "password.reset": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c/password"
                    },
                    "password.recover": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c/password"
                    }
                },
                "id": "916b9057-1de6-4718-931d-91f9e886316c",
                "environment": {
                    "id": "24f17b5b-a458-4238-973e-0f77401897ed"
                },
                "account": {
                    "canAuthenticate": true,
                    "status": "OK"
                },
                "address": {
                    "streetAddress": "115 Randy Park",
                    "locality": "Cookshire-Eaton",
                    "countryCode": "CA"
                },
                "createdAt": "2024-02-14T16:28:27.845Z",
                "email": "hearthfield_berengere@example.com",
                "enabled": true,
                "identityProvider": {
                    "type": "PING_ONE"
                },
                "lifecycle": {
                    "status": "ACCOUNT_OK"
                },
                "mfaEnabled": false,
                "name": {
                    "formatted": "Hearthfield BÃ©rengÃ¨re",
                    "given": "Hearthfield",
                    "family": "BÃ©rengÃ¨re"
                },
                "population": {
                    "id": "5a899957-18d8-4a62-9a15-e7d4a5265bf8"
                },
                "updatedAt": "2024-02-14T16:28:27.845Z",
                "username": "hearthfield_bÃ©rengÃ¨re",
                "verifyStatus": "NOT_INITIATED"
            }, .......
```

but the script transforms it  to something similar to this below, which is then saved to users.json file in the same folder as the script.

```json
{
	"users": [
		{
			"active": true,
			"birthDate": null,
			"insertInstance": null,
			"data": {
				"migrated": true,
				"favoriteColors": null
			},
			"email": "hearthfield_berengere@example.com",
			"expiry": null,
			"firstName": "",
			"fullName": "",
			"id": "916b9057-1de6-4718-931d-91f9e886316c",
			"lastLoginInstant": 0,
			"lastName": "",
			"middleName": "",
			"mobilePhone": "",
			"password": null,
			"salt": null,
			"factor": 10000,
			"encryptionScheme": "salted-pbkdf2-hmac-sha256",
			"passwordChangeRequired": false,
			"passwordLastUpdateInstant": 0,
			"preferredLanguages": [
				"en"
			],
			"identityProviders": {
			},
			"timezone": null,
			"twoFactorEnabled": false,
			"username": "hearthfield_bÃ©rengÃ¨re",
			"verified": true
		},
		{
			"active": true,
			"birthDate": null,
			"insertInstance": null,
			"data": {
				"migrated": true,
				"favoriteColors": null
			},
			"email": "wingar_helena@example.com",
			"expiry": null,
			"firstName": "",
			"fullName": "",
			"id": "a7ff34b6-dfa1-4d60-abd7-5614eb21c8dc",
			"lastLoginInstant": 0,
			"lastName": "",
			"middleName": "",
			"mobilePhone": "",
			"password": null,
			"salt": null,
			"factor": 10000,
			"passwordChangeRequired": false,
			"passwordLastUpdateInstant": 0,
			"preferredLanguages": [
				"en"
			],
			"identityProviders": {
			},
			"timezone": null,
			"twoFactorEnabled": false,
			"username": "wingar_hÃ©lÃ¨na",
			"verified": true
		}
	]
}
```

Check the output for any errors and to make sure the data looks correct. 
If you have any issues, you can modify the export program to output more information about the users being exported.

### Importing Users 

<Aside type="note">
This section is only needed if you decided not to do the slow migration from the next section. Be aware that this section  will not export password hashes and users will need to change it manually on fusion auth.
</Aside>

Remember the bulk migration does not allow the password hashes to be exported, so this method requires the user to change password on FusionAuth manually.

Next, import the user data. Here are the steps we need to take.

1. Set Up FusionAuth.
2. Get the Script.
3. Install Needed Gems.
4. Use the Script.
5. Verify the Import.
6. The Final Destination of Imported Users.

### Set Up FusionAuth

<SetUpFusionauth />

#### Create a Test Tenant

<CreateTestTenant migration_source_dir={migration_source_dir} migration_source_name={migration_source_name} add_tenant_image_role={add_tenant_image_role} />

#### Create a Test Application

<CreateTestApplication migration_source_dir={migration_source_dir} migration_source_name={migration_source_name} />

#### Add an API Key

<CreateApiKeySocial migration_source_dir={migration_source_dir} />

### Get the Script

```ruby
#!/usr/local/bin/ruby -w

require "date"
require "json"
require "csv"
require "fusionauth/fusionauth_client"
require "optparse"
require "securerandom"

# option handling
options = {}

# default options
options[:usersfile] = "users.json"
options[:fusionauthurl] = "http://localhost:9011"


OptionParser.new do |opts|
  opts.banner = "Usage: import.rb [options]"

  opts.on("-l", "--link-social-accounts", "Link social accounts, if present, after import. This operation is slower than an import.") do |linksocial|
    options[:linksocial] = true
  end

  opts.on("-r", "--register-users APPLICATION_IDS", "A comma separated list of existing applications Ids. All users will be registered for these applications.") do |appids|
    options[:appids] = appids
  end

  opts.on("-o", "--only-link-social-accounts", "Link social accounts with no import.") do |siteurl|
    options[:onlylinksocial] = true
  end

  opts.on("-u", "--users-file USERS_FILE", "The exported JSON user data file from IdentityServer. Defaults to users.json.") do |file|
    options[:usersfile] = file
  end

  opts.on("-f", "--fusionauth-url FUSIONAUTH_URL", "The location of the FusionAuth instance. Defaults to http://localhost:9011.") do |fusionauthurl|
    options[:fusionauthurl] = fusionauthurl
  end

  opts.on("-k", "--fusionauth-api-key API_KEY", "The FusionAuth API key.") do |fusionauthapikey|
    options[:fusionauthapikey] = fusionauthapikey
  end

  opts.on("-t", "--fusionauth-tenant-id TENANT_ID", "The FusionAuth tenant id. Required if more than one tenant exists.") do |tenantid|
    options[:tenantid] = tenantid
  end

  opts.on("-h", "--help", "Prints this help.") do
    puts opts
    exit
  end
end.parse!

users_file = options[:usersfile]

$fusionauth_url = options[:fusionauthurl]
$fusionauth_api_key = options[:fusionauthapikey]

# Optionally specify the target tenant. If only one tenant exists this is optional and the users
# will be imported to the default tenant. When more than one tenant exists in FusionAuth this is required.
$fusionauth_tenant_id = options[:tenantid]

puts "FusionAuth Importer : IdentityServer"
puts " > User file: #{users_file}"

# ids pulled from https://github.com/FusionAuth/fusionauth-java-client/blob/master/src/main/java/io/fusionauth/domain/provider/IdentityProviderType.java
idp_identifiers_to_identityserver_type = {
  "facebook" => "56abdcc7-8bd9-4321-9621-4e9bbebae494",
  "google" => "82339786-3dff-42a6-aac6-1f1ceecb6c46",
  "twitter" => "45bb233c-0901-4236-b5ca-ac46e2e0a5a5",
# add others as we have test data.
}

# Map a ping user to a FusionAuth user
def map_user(id, identityserver_user, options)
  user = {}
  is_identityserver_user = identityserver_user["identityProviders"].length === 0; 
  is_idp_user = identityserver_user["identityProviders"].length > 0

  user["id"] = identityserver_user["id"] #NOTE: If your users don't have a UUID as an id, you'll need to leave this blank, and store the old id in the data section
  user["active"] = identityserver_user["active"]
  user["email"] = identityserver_user["email"]
  user["verified"] = identityserver_user["verified"]
  user["insertInstant"] = identityserver_user["insertInstance"]
  if identityserver_user["expiry"] != nil 
    user["expiry"] = identityserver_user["expiry"]
  end

  if is_identityserver_user
    user["encryptionScheme"] = identityserver_user["encryptionScheme"] 
    user["factor"] = identityserver_user["factor"] #TODO: Check that iterations is === factor? not sure of terminology
    user["salt"] = ''#identityserver_user["salt"]
    user["password"] = SecureRandom.hex #identityserver_user["password"]

    # Preserve the identityserver Unique Id
    user["data"] = {}
    user["data"]["identityserver"] = {}
    user["data"]["identityserver"]["id"] = identityserver_user["id"]
  end

  if is_idp_user
    # random string, we don't care as users won't use it
    user["password"] = SecureRandom.hex

    # preserve idp id provided by identityserver
    user["data"] = {}
    user["data"]["identityserver"] = {}
    user["data"]["identityserver"]["identityProviders"] = identityserver_user["identityProviders"]
  end

  if options[:appids]
    regids = options[:appids].split(",")
    user["registrations"] = []
    regids.each do |rid|
      application_registration = {
        applicationId: rid.strip(),
      }
      user["registrations"].push(application_registration)
    end
  end

  return user
end

def find_user_id(client, u)
  querystring = nil
  if u["email"]
    querystring = u["email"]
  elsif u["username"]
    querystring = u["username"]
  end
  querystring = u["id"]
  results = client.search_users_by_query({ search: { ids: querystring } })
  if results && results.success_response
    users = results.success_response.users
    if users.length > 1
      puts "> Found multiple users matching " + querystring + ". Not linking."
      return nil
    end
    return users[0].id
  else
    puts "> Couldn't find " + querystring + ". Have they been imported?"
  end

  return nil
end

# import function
def import(users, options)
  if options[:onlylinksocial]
    # no importing
    return
  end

  puts " > Call FusionAuth to import users"

  import_request = {}
  import_request["users"] = users
  import_request["validateDbConstraints"] = false

  # FusionAuth Import API
  # https://fusionauth.io/docs/v1/tech/apis/users#import-users
  client = FusionAuth::FusionAuthClient.new($fusionauth_api_key, $fusionauth_url)
  if $fusionauth_tenant_id
    client.set_tenant_id($fusionauth_tenant_id)
  end
  begin
    response = client.import_users(import_request)
  rescue Exception => e
    puts "> Error: " + e.message
  end
  if response.was_successful
    puts " > Import success"
  else
    puts " > Import failed. Status code #{response.status}. Error response:\n #{response.error_response}"
    exit 1
  end
end



# Initialize a user array to hold chunks of 10k users before calling the Import API
identityserver_users = {}
users = []
emails = []
user_names = []
idp_users_needing_link = []
duplicate_emails = []
duplicate_user_names = []

count = 0
duplicate_count = 0

f2 = File.open(users_file, "r")

identityserver_users = JSON.parse(f2.read)
f2.close
puts "  >> " + identityserver_users["users"].length.to_s + " users found in JSON file"
# process users with passwords
identityserver_users["users"].each { |identityserver_user|
  u = map_user(identityserver_user["localId"], identityserver_user, options)

  unless u["email"].nil?
    unless emails.include? u["email"]
      emails.push u["email"]
    else
      duplicate_emails.push u["username"]
      duplicate = true
    end
  end

  unless u["username"].nil?
    unless user_names.include? u["username"]
      user_names.push u["username"]
    else
      duplicate_user_names.push u["username"]
      duplicate = true
    end
  end

  unless duplicate
    count = count + 1
    users.push u
    if identityserver_user["identityProviders"].length > 0
      idp_users_needing_link.push identityserver_user
    end
  else
    duplicate_count = duplicate_count + 1
  end

  # In chunks of 10k, request a bulk insert
  if count % 10_000 == 0
    import(users, options)
    users = []
  end
}

# Complete the import for anything that did not make the 10k threshold
if users.length > 0
  import(users, options)
  users = []
end

if options[:linksocial] || options[:onlylinksocial]
  puts "Linking " + (idp_users_needing_link.length.to_s) + " social accounts"

  client = FusionAuth::FusionAuthClient.new($fusionauth_api_key, $fusionauth_url)
  if $fusionauth_tenant_id
    client.set_tenant_id($fusionauth_tenant_id)
  end

  # https://fusionauth.io/docs/v1/tech/apis/identity-providers/links/
  idp_users_needing_link.length > 0 && idp_users_needing_link.each do |u|
    u["identityProviders"].each do |link|
      link_request = {}
      link_request["identityProviderId"] = idp_identifiers_to_identityserver_type[link[0]]
      link_request["identityProviderUserId"] = link[1]

      user_id_in_fusionauth = find_user_id(client, u)
      unless user_id_in_fusionauth
        # couldn't find user?
        next
      end
      link_request["userId"] = user_id_in_fusionauth

      response = client.create_user_link(link_request)
      if response.was_successful
        puts " > Link success"
      else
        puts " > Link failed for user id: " + link_request["userId"] + ". Status code #{response.status}. Error response:\n #{response.error_response}"
      end
    end
  end
end

puts "Duplicate users #{duplicate_count}"
unless duplicate_emails.size == 0
  duplicate_emails.each { |email| puts " > #{email}" }
end
unless duplicate_user_names.size == 0
  duplicate_user_names.each { |user_name| puts " > #{user_name}" }
end
puts "Import complete. #{count} users imported."
```


### Install Needed Gems

The following gems must be available to the import script:

* `date`
* `json`
* `optparse`
* `securerandom`
* `fusionauth_client`

It is likely that all of these will be on your system already, except the `fusionauth_client` gem.

If you have `bundler` installed, run `bundle install` in the `ping` directory. Otherwise, install the needed gems another way.

### Use the Script

You can see the output of the script by running it with the `-h` option:

```sh title="Running the import script with the help command line switch"
ruby ./import.rb -h
```

The output will be similar to this:

```sh title="The help output of the import.rb script"
Usage: import.rb [options]
    -l, --link-social-accounts       Link social accounts, if present, after import. This operation is slower than an import.
    -r APPLICATION_IDS,              A comma separated list of existing applications Ids. All users will be registered for these applications.
        --register-users
    -o, --only-link-social-accounts  Link social accounts with no import.
    -u, --users-file USERS_FILE      The exported JSON user data file from IdentityServer. Defaults to users.json.
    -f FUSIONAUTH_URL,               The location of the FusionAuth instance. Defaults to http://localhost:9011.
        --fusionauth-url
    -k, --fusionauth-api-key API_KEY The FusionAuth API key.
    -t TENANT_ID,                    The FusionAuth tenant id. Required if more than one tenant exists.
        --fusionauth-tenant-id
    -h, --help                       Prints this help.
```

For this script to work correctly, set the following switches, unless the defaults work for you:

* `-u` should point to the location of the user export file you obtained, unless the default works.
* `-f` should point to your FusionAuth instance. If you are testing locally, it will probably be `http://localhost:9011`.
* `-k` should be set to the value of the API key created above.
* `-t` should be set to the Id of the testing tenant created above.

The `-o` and `-l` switches will attempt to create links for any users authenticated via Google or another social identity provider found in the users data file.

If you are loading users with social account authentication, you must create the social identity providers in FusionAuth beforehand or the links will fail. Additionally, creating a link is not currently optimized in the same way that loading a user is. It may make sense to import all the users in one pass (omitting the `-l` switch) and then create the links using the `-o` switch in a second pass, after the users are imported.

<Aside type="note">
The social account linking functionality will only work with FusionAuth version 1.28 or above. The `fusionauth_client` library must be >= 1.28.
</Aside>

When you run the script, you should get an output similar to the following:

```shell title="Import script output"
$ ruby ./import.rb -f http://localhost:9011 -k '...' -t '...' -u users.json
FusionAuth Importer : IdentityServer
 > User file: users.json
 > Call FusionAuth to import users
 > Import success
Duplicate users 0
Import complete. 2 users imported.
```

#### Enhancing the Script

You may want to migrate additional data. Currently, the following attributes are migrated:

* `user_id`
* `email`
* `email_verified`
* `username`
* `insertInstance`
* the password hash and supporting attributes, are not available
* `registrations`, if supplied

The migrated user will have the original Ping IdentityServer user Id. If you have additional user attributes to migrate, review and modify the `map_user` method.

You may also want to assign Roles or associate users with Groups by creating the appropriate JSON data structures in the import call. These are documented in the [Import User API docs](/docs/apis/users#import-users). This will require modifying the `import.rb` code.

### Verify the Bulk Import

Next, log in to the FusionAuth administrative user interface. Review the user entries to ensure the data was correctly imported.

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/list-users.png`} alt="List imported users." width="1200" role="bottom-cropped" />

### The Final Destination of Bulk Imported Users

<FinalDestination migration_source_dir={migration_source_dir} />

Now that you have all the users imported, you must reset their passwords.

### Reset Passwords

Users may reset their password using the `Forgot Password` link on the login page, or you can use the API calls documented below to do it.

<Aside type="caution">
This script will send an email to every imported user. Ensure your SMTP server, configured in <strong>Tenants -> Your Tenant -> Email</strong>, is able to handle the volume.
</Aside>

Review the `Change Password` template to ensure the messaging is correct. Here is [more information on modifying the template](/docs/customize/email-and-messages/templates-replacement-variables#forgot-password).

Retrieve the `loginId` from the PingIdentity JSON export files and place it in a single file. The `loginId` will either be the username or the email address. Update the script below to use the API key created in <ScrollRef target="Set Up FusionAuth For a Bulk Migration" /> step.

The script below will call the [forgot password API](/docs/apis/users#start-forgot-password-workflow) for every user. It sleeps periodically to avoid overloading the SMTP server.

```shell title="Example User Password Reset"
#!/bin/bash
API_KEY=...
LOGIN_ID_FILE=...
FA_HOST=...

for loginId in `cat $LOGIN_ID_FILE`; do
  sleep $[( $RANDOM % 10 > 8)] # sleeps 1 second ~10% of the time
  RES=`curl --max-time 600 \
       -s -w "%{http_code}" \
       -H "Authorization: $API_KEY" \
       -H "Content-type: application/json" \
       -XPOST \
       $FA_HOST/api/user/forgot-password \
       -d '{"loginId": "'$loginId'","sendForgotPasswordEmail": true}'`
  if [ "$RES" -ne "200" ]; then
    echo "Error: $RES";
    exit 1;
  fi
done
```

At the end of this process, you have imported the user data and enabled users to reset their passwords to a known value.

### Slow Migration

<Aside type="note">
This section is only if you decided to do the slow migration and can be ignored if the users changed their passwords as in the previous section
</Aside>

### Set Up PING Identity Stub to Authenticate users

There are three main components you need to set up to enable this migration.

The first is public available api/endpoint that can be called from the FusionAuth connector(Configuring Endpoints). Here we have a few options.
    ## - If You want to go the Azure Route , this can ba a http trigger on the function app below in point(https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook-trigger?tabs=python-v2%2Cisolated-process%2Cnodejs-v4%2Cfunctionsv2) .(beyond the scope of this guide)
    ## - You gan  Can also use a api gateway on AWS of you want to go the Amazon Route (https://aws.amazon.com/api-gateway/).(beyond the scope of this guide)
    ## - For the purpose of this guide I created a selfHosted endpoint locally that was made public via the Ngrok service(https://ngrok.com/). 

Secondly, you will need to set up a PingIdentity Authentication "stub" to retrieve the user's details, in order to import them to FusionAuth(Setting Up Authentication Logic).
    ## - If you decided on the Microsoft AZURE route this will be a Microsoft AZURE function app (https://learn.microsoft.com/en-us/azure/azure-functions/functions-overview).(beyond the scope of this guide)
    ## - AWS uses Lambda function which is similar to Azure functions apps.(https://docs.aws.amazon.com/lambda/latest/dg/welcome.html).(beyond the scope of this guide)
    ## - For the purposes of the guide we will create a python app, the expose a flask endpoint that will be used with Ngrok. This will be configure as a connector on fusionAuth to enable the slow migration
    The Purpose of this is to accept login requests from FusionAuth over TLS and perform an [ROPC login] request on Ping Identity, and return the relevant user data via the PingOne API.

<Aside type="caution">
FusionAuth Connectors will send user credentials to PingIdentity, via an Flask\python app for demonstration purposes. In production migrations it is important to secure both the data in transit and the various endpoints that forms part of the solution.

In this guide, all communication is over TLS and the python Flask app can use  a unique query string code for security purposes. Regardless of implementation chosen, security in production migrations should be the highest priority and proper review and planning regarding this should be done.

PingIdentity also uses a Access token thats needs certain administrative permissions to perform the functions needed. Please bear in mind that it can expire after a while and might need to be renewed.
</Aside>

#### Configuring EndPoints
As stated above we will create a Ngrok endpoint to use in this example. FusionAuth will send login requests to the endpoint and it will try to validate the users credentials, via the the flask api. It will also retrieve the users PingIdentity profile from thePingOne API.

<Aside type="note">
    Ngrok can be downloaded at:(https://ngrok.com/). There are free and paid plans available. For Demo Purposes a free plan will be used.
    This guide will assist you to get ngrok up and running https://ngrok.com/docs/getting-started/
</Aside>

When Ngrok is installed, we can start it with 
'''powershell
    ngrok http 5000   
'''
and if you see the screen below the first step is completed successfully.
<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/ngrok.png`} alt="Running Ngrok." width="1200" role="bottom-cropped" />
Take note of this url : 'https://fa77-105-214-52-47.ngrok-free.app' we will need that later again.This will vary for your instance.

### Setting Up Authentication Logic

The python flask app receives the login request from FusionAuth, attempts to log the user in via ROPC, and then returns a FusionAuth user object on success. 
The Function will call the [Users] API endpoint on PingIdentity (https://apidocs.pingidentity.com/pingone/main/v1/api/#getting-started-with-the-pingone-apis) after successful authentication to get additional user attributes, which will then be transformed into a FusionAuth compatible format.
When setting this up, modify the example Function code provided in this guide. 

## Flask/Python Authenticator python code


```python
import requests
import json 
from flask import Flask, render_template,  jsonify, request

app = Flask(__name__)

authPath = 'https://auth.pingone.com'
apiPath ='https://api.pingone.com/v1'
envID = 'YOUR ENVIRONMENT ID'
appId = 'YOUR PING IDENTITY APP ID' 
accessToken = "YOUR ACCESS TOKEN"
 

def sentAuthRequest(appId):
    url = f"{authPath}/{envID}/as/authorize?response_type=code&client_id={appId}&redirect_uri=https://www.google.com&scope=openid"
    payload = {}
    headers= {}
    response = requests.request("GET", url, headers=headers, data = payload, allow_redirects=False)

    if response.status_code!=302:
        print(response.status_code)    
        print(response.text.encode('utf8'))
    else:
        return  response.headers['Location'].split("flowId=")[1] 

def getFlowId(flowId):
    
    url = f"{authPath}/{envID}/flows/{flowId}"
    payload = {}
    headers = {}
    response = requests.request("GET", url, headers=headers, data = payload)
    if response.status_code!=200:
        print(response.status_code)    
        print(response.text.encode('utf8'))
        return None
    else:
        return flowId

def submitCredentials(flowID,username,userPassword):
    url = f"{authPath}/{envID}/flows/{flowID}"
    payload = "{\n    \"username\": \""+ username +"\",\n    \"password\": \""+ userPassword+"\"\n}"
    headers = {
    'Content-Type': 'application/vnd.pingidentity.usernamePassword.check+json'
    }
    response = requests.request("POST", url, headers=headers, data = payload)

    if response.status_code!=200:
        print(response.status_code)    
        print(response.text.encode('utf8'))
    else:
        result = transform_json_user(response.content)
        return result


def transform_json_user(input_json):
    dataJson = json.loads(input_json)
    userId = dataJson["_embedded"]['user']['id']
    dataJson =  readUserInfo(userId)
    transformed_user = {
    "active": dataJson.get("enabled", False),
    "birthDate": None,
    "data": {
        "migrated": True,  
        
    },
    "email": dataJson.get("email", ""),
    "expiry": None,
    "firstName": dataJson["name"].get("given", ""),
    "fullName": "",  # user["name"]["formatted"],
    "id": dataJson.get("id", ""),
    "lastLoginInstant": 0,
    "lastName": dataJson["name"].get("family", ""),
    "middleName": "",
    "passwordChangeRequired": False,
    "passwordLastUpdateInstant": 0,
    "preferredLanguages": ["en"],
    "timezone": None,
    "username": dataJson.get("username", ""),
    "verified": dataJson.get("verifyStatus", False)==True,
   }
        
    
    result_json = {"user": transformed_user}
    return result_json

def readUserInfo(userId):
    url =F'{apiPath}/environments/{envID}/users/{userId}?expand=population'
    data = {}
    headers = {'Authorization': 'Bearer ' +accessToken }

    response = requests.get(url,headers=headers,timeout=30)

    if response.status_code!=200:
            print(response.status_code)    
            print(response.text.encode('utf8'))
    else:
        jsonData = response.json()
        return jsonData

    
@app.route('/api/RopcProxy', methods=['POST'])
def rocp_proxy():
    # Extract the 'code' query parameter from the URL
    code = request.args.get('code')

    if not code:
        return jsonify({'error': 'Missing code parameter'}), 400

    # Extract the 'loginId' and 'password' from the JSON body
    data = request.get_json()

    if not data or 'loginId' not in data or 'password' not in data:
        return jsonify({'error': 'Invalid or missing JSON body'}), 400

    login_id = data['loginId']
    password = data['password']

    response_data = TestCredentialLogin(appId,login_id,password)
    #print(json.dumps(response_data,indent=3))
    return response_data

def TestCredentialLogin(appId,usename,password):
    print("--> Send auth request")
    flowId =sentAuthRequest(appId)
    print(flowId)
    print("--> Get Flow")
    flowId2=getFlowId(flowId)
    print(flowId2)
    print("--> Validating Credentials")
    result = submitCredentials(flowId2,usename,password)
    print("--> Done")
    return result  

 
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000,debug=True)
    
```
Please make sure the requirements like requests  , flask, etc is install with pip before running the script.

You can now run the application with 
```powershell
    python.exe pingIdentityAuth.py
```
<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}flaskApp.png/`} alt="Running flask python app." width="1200" role="bottom-cropped" />

You should see all running like the screen shot above.

#### Testing The Deployed API

You will need to modify the `transform_json_user` function to match the properties of the users that you want to import. This converts the JSON returned from PingIdentity into the JSON format FusionAuth requires. You can see samples of both below. To modify this procedure, clone or fork the [repo for the full Function project](pingIdentityAuth.py), then make the changes in your local copy of the project.

The exact implementation depends on your PingIdentity's custom attributes and business logic. You could, for example, give users certain FusionAuth roles, register them for more than one application or add them to a previously created FusionAuth group.
<Aside type="note">
    Please note that the  FusionAuth connector will require the following url:https://fa77-105-214-52-47.ngrok-free.app/api/RopcProxy?code=s0ndU863xdbXsFO4dLZAJQXLzyTU789iaUJ43uLAtIkXm_AzFuFWP1zg== in its configuration.
    this is the url exposed by Ngrok and the FLASK API
<Aside/>

```powershell
    curl -X POST 'https://fa77-105-214-52-47.ngrok-free.app/api/RopcProxy?code=s0ndU863xdbXsFO4dLZAJQXLzyTU789iaUJ43uLAtIkXm_AzFuFWP1zg=='  -H 'Content-type: application/json' -d '{
    "loginId": "Richard",
    "password": "myPassword123!"
    }'
```
If the authorization header or account credentials are incorrect, a 404 HTTP status code is returned, along with a message in the body. You can view the status code by running `curl` with the `-v` switch.

Other wise the following wil be returned

```json title="Sample User Data Response from PingIdentity"
    {
    "_links": {
        "self": {
            "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0/users/cffa5359-aa0a-4d4c-8a1c-4cc18a36a529"
        },
        "environment": {
            "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0"
        },
        "population": {
            "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0/populations/fbfccbc2-f853-4539-a2f1-c4210d155c51"
        },
        "devices": {
            "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0/users/cffa5359-aa0a-4d4c-8a1c-4cc18a36a529/devices"
        },
        "roleAssignments": {
            "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0/users/cffa5359-aa0a-4d4c-8a1c-4cc18a36a529/roleAssignments"
        },
        "password": {
            "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0/users/cffa5359-aa0a-4d4c-8a1c-4cc18a36a529/password"
        },
        "password.reset": {
            "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0/users/cffa5359-aa0a-4d4c-8a1c-4cc18a36a529/password"
        },
        "password.set": {
            "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0/users/cffa5359-aa0a-4d4c-8a1c-4cc18a36a529/password"
        },
        "password.check": {
            "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0/users/cffa5359-aa0a-4d4c-8a1c-4cc18a36a529/password"
        },
        "password.recover": {
            "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0/users/cffa5359-aa0a-4d4c-8a1c-4cc18a36a529/password"
        },
        "linkedAccounts": {
            "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0/users/cffa5359-aa0a-4d4c-8a1c-4cc18a36a529/linkedAccounts"
        },
        "account.sendVerificationCode": {
            "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0/users/cffa5359-aa0a-4d4c-8a1c-4cc18a36a529"
        },
        "memberOfGroups": {
            "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0/users/cffa5359-aa0a-4d4c-8a1c-4cc18a36a529/memberOfGroups"
        }
    },
    "_embedded": {
        "population": {
            "_links": {
                "self": {
                "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0/populations/fbfccbc2-f853-4539-a2f1-c4210d155c51"
                },
                "environment": {
                "href": "https://api.pingone.com/v1/environments/de6b5f05-a95b-4ada-85bb-d8892700d1a0"
                }
            },
            "id": "fbfccbc2-f853-4539-a2f1-c4210d155c51"
        }
    },
    "id": "cffa5359-aa0a-4d4c-8a1c-4cc18a36a529",
    "environment": {
        "id": "de6b5f05-a95b-4ada-85bb-d8892700d1a0"
    },
    "account": {
        "canAuthenticate": true,
        "status": "OK"
    },
    "createdAt": "2024-02-18T07:00:18.420Z",
    "email": "richard.hendricks@piedpiper.com",
    "enabled": true,
    "identityProvider": {
        "type": "PING_ONE"
    },
    "lastSignOn": {
        "at": "2024-02-18T19:17:47.061Z",
        "remoteIp": "105.214.52.47"
    },
    "lifecycle": {
        "status": "ACCOUNT_OK"
    },
    "mfaEnabled": false,
    "name": {
        "given": "Richard",
        "family": "Hendricks"
    },
    "population": {
        "id": "fbfccbc2-f853-4539-a2f1-c4210d155c51"
    },
    "updatedAt": "2024-02-18T19:17:47.086Z",
    "username": "Richard",
    "verifyStatus": "NOT_INITIATED"
    }
```

but The `transform_json_user` will transform the above into a FusionAuth compatible format, as displayed below:

```json title="Sample Successful Login JSON"
    "user": {
            "active": true,
            "birthDate": null,
            "data": {
            "migrated": true
            },
            "email": "richard.hendricks@piedpiper.com",
            "expiry": null,
            "firstName": "Richard",
            "fullName": "",
            "id": "cffa5359-aa0a-4d4c-8a1c-4cc18a36a529",
            "lastLoginInstant": 0,
            "lastName": "Hendricks",
            "middleName": "",
            "passwordChangeRequired": false,
            "passwordLastUpdateInstant": 0,
            "preferredLanguages": [
            "en"
            ],
            "timezone": null,
            "username": "Richard",
            "verified": false
            }
    }

```
<Aside type="note">
    Once you have the custom function logic updated, it is time to configure the fusion Connector. if you have use AWS/AZure for the above this is the time where you will deploy you function/lambda apps.
</Aside>

### Set Up the Connector

Now you need to set up a Connector to use the Ngrok /Flask API you created. 

Log back into the FusionAuth administrative user interface if needed.

<PremiumEditionBlurb />

Connectors are a feature limited to paid editions, so you must ensure you have a valid reactor license. Learn more about [activating reactor](/docs/get-started/core-concepts/licensing).

Next:

* Configure the Connector with the API URL and authorization header
* Configure the Tenant to use the Connector

#### Configure a Connector

Create and configure the Connector. Navigate to <strong>Settings -> Connectors</strong> and add a new Generic Connector.
<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/create Connector 1-Settings.png`} alt="Navigate to Settings." width="1200" role="bottom-cropped" />
<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/create Connector 2-Connector.png"} alt="Navigate to Connector." width="1200" role="bottom-cropped" />


Click on the Add Generic button on the right hand top.
<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/create Connector 3 - Add Generic Connector.png} alt="Click on Add Connector." width="1200" role="bottom-cropped" />

Configure the Connector:

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/create Connector 4 - Enter ID-Name-Auth-url.png"} alt="Configuring a Generic Connector." width="1200" role="bottom-cropped" />
* Add a name like `PingIdentity migration`.
* Set the <InlineField>Authentication URL</InlineField> to the value of the in  URL endpoint created above i.e. https://fa77-105-214-52-47.ngrok-free.app/api/RopcProxy?code=s0ndU863xdbXsFO4dLZAJQXLzyTU789iaUJ43uLAtIkXm_AzFuFWP1zg==.
* You don't need to set any headers, as you might need a code passed in to your functions in the querystring as per sample.

At the end, you should have a screen like this:

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/create Connector 5 -final.png`} alt="Configuring a Generic Connector." width="1200" role="bottom-cropped" />

Save the Connector. Next, configure your tenant to use this Connector. Note that if you have problems with the connector, you can enable the debug setting, to get errors/warnings logged in the fusion auth system eventlog

#### Configuring the Tenant

Navigate to your tenant settings: <strong>Tenants -> PingIdentity import tenant -> Connectors</strong>.

Click the <InlineField>Add policy</InlineField> button to set up a new Connector policy.

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/connector-policies.png`} alt="Connector policies for this Tenant." width="1200" role="bottom-cropped" />

Set the <InlineField>Connector</InlineField> field value to the name of the Connector created previously. Make sure that the <InlineField>Migrate user</InlineField> field is enabled. You can leave the <InlineField>Domains</InlineField> field with the value of `*`, which will apply this Connector to every user.

After configuration, the Policy entry form should look similar to this:

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/add-connector-policy.png`} alt="Add Connector policy." width="1200" />

Save it.

Next, ensure this Connector Policy is in the correct order by using the arrows in the administrative user interface to put it at the top. With this configuration, all users are checked against this Connector the first time they are seen. If they log in, they'll be migrated to the FusionAuth user database.

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/connector-policy-list-after-adding.png`} alt="PingIdentity Connector policy added and in list." width="1200" role="bottom-cropped" />


### Log In With a Test User

To test that users will be migrated, log in as a test user via the FusionAuth interface with a valid user from your Ping Identity instance.

When you set up the test application, you recorded the <InlineField>OAuth IdP login URL</InlineField>.

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/find-login-url.png`} alt="Finding the login URL." width="1200" />

Copy this URL and open it in a new incognito browser window. (If you don't use an incognito window, the admin user session will interfere with the test.) You should see the login screen:

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/user-login.png`} alt="The login page." width="1200" role="bottom-cropped" />

Enter credentials for a PingIdentity user account; it can be the same one you used to test the API with curl and log in. The user will be transparently migrated over to FusionAuth.

If the user was not migrated or the login was unsuccessful, you can troubleshoot. In the administrative user interface, enable the <InlineField>Debug enabled</InlineField> field in the Connector configuration by navigating to <strong>Settings -> Connectors</strong> and editing the Generic Connector you added.

After enabling enhanced debug messages, try to log in again with the test user. In the administrative user interface, navigate to <strong>System -> Event Log</strong> and look for useful messages.

<Aside type="note">
After a successful test login, the user will be redirected to a URL like `https://fusionauth.io/?code=2aUqU0ZhQCjtz0fnrFL_i7wxhIAh7cTfxAXEIpJE-5w&locale=en&userState=AuthenticatedNotRegistered`. 

This occurs because you haven't set up a web application to handle the authorization code redirect yet.

That is an important next step but is beyond the scope of this document. Consult the [5 minute setup guide](/docs/quickstarts/5-minute-setup-guide) for an example of how to do this.
</Aside>

Let's check that the import succeeded in another way: by viewing the user in the administrative user interface.

### Verify the Migration

<VerifyImport migration_source_dir={migration_source_dir} />


At this point, you've successfully migrated a user from PingIdentity into FusionAuth. Any further changes for this user will occur against the FusionAuth database; this includes profile and password changes.
<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/migrated-user-.png`} alt="The login page." width="1200" role="bottom-cropped" />

### Clean Up Your Test Environment

After you are done testing, deploy these same configuration changes to production.

Depending on your architecture, you can choose to migrate users into the default tenant or a new tenant of the production instance. Whichever you choose, configure the Connector policy of the destination tenant.

If you aren't keeping users in the test tenant, delete it. This is also useful if you want to start over because you need to tweak a setting such as the default application registration. In either case, delete the tenant you created.

This will remove all the users and other configuration for this tenant, giving you a fresh start. To delete a tenant, navigate to <strong>Tenants</strong> and choose the red trash can icon corresponding to the tenant to be deleted.

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/list-of-tenants-delete-highlighted.png`} alt="Deleting a tenant." width="1200" role="bottom-cropped" />

Confirm your desire to delete the tenant. Depending on how many users exist in that tenant, this may take some time. If it is easier, you may also delete migrated users one at a time using the administrative user interface.

### Migrate Everything Else

<WhatNext />

<WhatNextAzureAdB2c />

### Estimate the Slow Migration Timeline

When using a slow migration, you can estimate how many accounts will be migrated in a given period of time.

<SlowMigrationTimeline />

After this period of time, you may want to bulk migrate the rest of the users, or treat them as inactive and not migrate them. Plan to disable the Connector and remove the tenant's Connector Policy after the slow migration is complete.

Learn more about [general slow migration considerations](/docs/lifecycle/migrate-users/bulk/general#slow-migration-implementation).

### Additional Support

<AdditionalSupport />

