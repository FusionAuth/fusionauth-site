---
publish_date: 2023-10-17 
title: Vue, React and Angular SDKs
description: SDKs to make implementing FusionAuth easier
authors: Dan Moore
excerpt_separator: "{/* more */}"
image: /img/blogs/hackfest/hackfest-fusionauth.png
categories: Company
tags: javascript, sdks, angular, vue, react, client libraries
---
import { YouTube } from '@astro-community/astro-embed-youtube';
import RemoteCode from "../../components/RemoteCode.astro";

FusionAuth is, at its core, an architectural component. I like to say "no one ever builds a full application with FusionAuth". Your application needs authentication and authorization, but there are always other critical components. For example, the unique features of your application which actually make users want to register and log in.

{/* more */}

But here at FusionAuth, we want simple, secure authentication to be easy to add to your application. FusionAuth can run anywhere, so it makes sense to make integration easy for any application. Applications which work with FusionAuth include:

* JavaScript single pages applications (SPAs)
* traditional webapps
* server side applications
* APIs
* mobile apps

You can see our [list of quickstarts](/docs/quickstarts/) for examples of all of these.

Pretty much anything that can either use OIDC, SAML, or an HTTP based API should work.

Recently, the team build software development kits (SDKs) to make it easier for SPA developers. The new SDKs support the following JavaScript front end frameworks:

* [Angular](/docs/v1/tech/client-libraries/angular-sdk)
* [React](/docs/v1/tech/client-libraries/react-sdk)
* [Vue](/docs/v1/tech/client-libraries/vue-sdk)

This post will discuss the nitty gritty of using these SDKS, but first, let's discuss the difference between an SDK and a [client library](/docs/v1/tech/client-libraries/).

## Client Libraries vs SDKs

At FusionAuth, a client library is different than an SDK, even though many people use the terms interchangably.

### Client Libraries

A client library is a wrapper over [FusionAuth APIs](/docs/v1/tech/apis/). Client libraries support all public FusionAuth API endpoints, and offer a convenient native way to interact with the API in whatever language you choose. At time of writing, there are eight supported languages, including TypeScript. There's also an OpenAPI definition, which is useful for viewing API changes over time or generating a client library for an unsupported language.

If you want to compare a client to a child's toy, it is like tinker toys. Calls to a client library can be assembled by engineers to extend or configure FusionAuth. Here are examples of tasks well suited to a client library:

* [rotating client secrets or API keys](/docs/v1/tech/tutorials/key-rotation) to improve your security posture
* pulling user data every night to ingest into a data warehouse
* creating a new FusionAuth tenant every time a new client signs up for your app
* offering a unique, custom login or registration experience not supported by the [FusionAuth hosted login pages](/docs/v1/tech/core-concepts/integration-points#hosted-login-pages)

Requests made with client libraries require an API key as well as a URL for a FusionAuth instance.

### SDKs

An SDK, in contrast, is an opinionated collection of abstracted functionality. To continue the toy metaphor, an SDK is a doll or a toy truck. Less assembly, but less flexibility. SDKs are designed to allow front-end engineers add authentication to their application. A FusionAuth SDK includes:

* a button and JavaScript function for logging a user in
* a button and JavaScript function for logging a user out
* a button and JavaScript function for user registration
* filters to lock down content by role or authentication state
* token refresh and management functionality

SDKs are configured to work with an application in FusionAuth using a client Id.

### Better Together?

If you want both the front-end SDK based solutions and the management access provided by a client library, you can use both.

## Examples

The [FusionAuth SPA quickstarts](/docs/quickstarts/#spa) use the corresponding SDKs. Let's look at some code:

Here's a sample component from the [Angular quickstart](/docs/quickstarts/quickstart-javascript-angular-web).

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-quickstart-javascript-angular-web/main/complete-application/src/app/app.component.ts" lang="typescript" />

Here's an example dynamic header from the [React quickstart](/docs/quickstarts/quickstart-javascript-react-web).

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-quickstart-javascript-react-web/main/complete-application/src/components/LogoHeader.js" lang="javascript" />

And, finally, here's code from the [Vue quickstart](/docs/quickstarts/quickstart-javascript-vue-web) showing `<RequireAuth>` usage.

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-quickstart-javascript-vue-web/main/complete-application/src/components/LogoHeader.vue" lang="vue" />

## More about SDKs

The SDKs provided are open source and the code is linked from the documentation pages. In general, there are two components for each SDK.

* a client side package installed via a package manager like npm into your SPA
* a server side component which runs in node

### The Server Side Component

The server side component has a number of endpoints that map to the [hosted backend APIs](/docs/v1/tech/apis/hosted-backend). You could implement the server side component in any other language if that's preferable. The default server side code sets access tokens and refresh tokens as `HTTPOnly`, `Secure` cookies. This is a great token storage choice for first party API requests, because such cookies are not vulnerable to JavaScript exfiltration. The cookies are presented on every request from the SPA to an API in a given domain, as long as you set the [`credentials` property correctly](https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials). APIs should be designed to read from either the `Authorization` header or the cookie; you can see examples in our [API quickstarts](/docs/quickstarts/#api). 

For SPAs which make requests across multiple domains, the backend for frontend pattern is recommended. Here's a video about the insecurity of storing tokens in any JavaScript front end code.

<YouTube id="2nVYLruX76M" />

You can read more about [OAuth token storage in this article](/articles/oauth/oauth-token-storage). Using a server side component gives you flexibility to store the token wherever makes more sense.

### The Client Side Package

The client side package offers, as mentioned above, pre-built buttons or functions which you can attach to UI elements. Each of these performs a redirect to FusionAuth's hosted login pages for the desired operations, including the Authorization Code grant for login. While others 

This is the recommended approach for two reasons:

* functionality
* security

Let's discuss each of these in turn.

### Functionality

When you use the authorization code grant for authentication, or similiar redirects for other authentication related events, the user interacts only with FusionAuth and FusionAuth provided functionality. This means that your application immediately gains all that functionality. This includes, but is not limited to:

* forgot password
* email verification
* MFA
* magic link authentication
* password expiration
* enterprise single sign-on (SAML, OIDC)
* social sign-on (Google, Facebook, etc)
* profile management (with a paid license)
* passkeys (with a paid license)

and more. You will have to configure FusionAuth, but the functionality is present, tested, and maintained over time.

Redirects work with any language, framework and browser, which make sure your application's login page is never a barrier to your users.

### Security

When using a redirect, the only application which sees sensitive user credentials is FusionAuth. FusionAuth has additional security features such as:

* the ability to lock user accounts
* password rules
* webhook notifications when a user has failed to login
* in certain plans, rate limiting and email notification for security related events

FusionAuth is an architectural component solely designed to protect users data and enable the right users to login to your application. By redirecting to it, you don't have to worry about any other JavaScript resident in your application getting access to sensitive information or credentials.

### Look and Feel

However, security and functionality are all well and good, but you typically want your login page to look like your application. Doesn't a redirect to an entirely separate application make that difficult?

Well, no. FusionAuth allows for complete control over the look and feel of the hosted login pages, including allowing you to add or remove HTML, CSS, images and JavaScript to the pages. You can learn more about [themes](/docs/v1/tech/themes/), including an [example in Tailwind CSS](/docs/v1/tech/themes/tailwind).

It's pretty common to allow user to log in from multiple states in your SPA. You should send the user back to the same state after successful log in. You can use the `state` parameter to deep link from a certain page in your SPA to the login page and then right back to that page. Here's a video about that:

<YouTube id="-vx5rdy-mvY" />

And here's some code from an [example application](https://github.com/FusionAuth/fusionauth-example-node-deeplink/) which extracts a URL from a `state` parameter.

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-example-node-deeplink/main/routes/index.js" lang="javascript" tags="extractURLFromState" />

### Redirects Don't Work, Help!

If your application cannot handle redirects to the user, you can use the [Login API](/docs/v1/tech/apis/login) to directly pass user credentials to FusionAuth. 

You'll miss out on the functionality and security benefits above. At the curent time there's no SDK support for this approach, but people can and have built out their own user interface using the Login API.

## In Conclusion

These SDKs can help you integrate FusionAuth into your Angular, React or Vue application more quickly while still leveraging the undifferentiated login workflows and security of an isolated authentication server.
