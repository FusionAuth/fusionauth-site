---
publish_date: 2024-07-12
title: "Android App End-to-End Testing With FusionAuth"
description: 'How to end-to-end test a Android App including FusionAuth.'
authors: Aaron Ritter
image: /img/blogs/android-end-to-end-testing/android-end-to-end-testing-blog-header.png
categories: Tutorial
tags: android, sdk, testing, oauth, automation, github workflow
excerpt_separator: "{/* more */}"
---

import RemoteContent from 'src/components/RemoteContent.astro';
import Aside from '/src/components/Aside.astro';

Using OAuth2 with a browser popup for Authentication can be tricky to use during automated testing in an [Android Emulator](https://developer.android.com/studio/run/emulator).

{/* more */}

We made some efforts in the development of the FusionAuth Android SDK and made the test available in the [Android Kotlin - Fusionauth SDK Quickstart](/docs/quickstarts/quickstart-android-kotlin-native) too.

In this blog, we go in to detail on why to implement a end-to-end test, how to create the test with a real FusionAuth backend and what to look for in an automated testing environment. The latest details on the live implementation you can find in [Android Kotlin - Fusionauth SDK Quickstart - Testing](https://github.com/FusionAuth/fusionauth-quickstart-kotlin-android-native/blob/main/TESTING.md) documentation.

# Why

Implementing FusionAuth as the authentication and authorization platform allows you to seamlessly integrate various features across your application. This includes essentials like identity management, authentication, and authorization, as well as advanced functionalities such as detailed user profiles, role management, or custom registrations. Consequently, many user-facing functionalities provided in the Android App will heavily depend on FusionAuth.

To ensure reliability of our Android SDK, we wanted to verify that all SDK functionalities integrated into our Android App are working correctly with each new FusionAuth release and across multiple versions of Android. This is done in an automated fashion, ensuring that every new update is thoroughly tested for compatibility and functionality.

And once the end-to-end test suite has been thoroughly run against a variety of updates and releases over the time of development. We can be confident to use it as well as a fail/pass criteria for any pull request and a test before the release workflows in the GitHub project.

# How

Initially, the test needed to function within the IDE, where development occurs. By automating the frequent manual clicks performed by an SDK developer when testing the Android app, we converted these interactions into a script. This script can be executed repeatedly, ensuring consistent and efficient testing.

During that stage we need to consider that testing OAuth2 with a browser popup for Authentication in combination with a Android App can be tricky during automated testing in an [Android Emulator](https://developer.android.com/studio/run/emulator) and requires some testing libraries which are capable of both.

In the second step we add this test in to GitHub workflows to fully automate it on every new pull request and release. Where we need to choose the different GitHub actions to implement the workflow. As well as choose the right dependabot configuration to help with automated dependency management.

This involves additional consideration, ensuring the tests function reliably across different Android versions which involves repeatedly setting up multiple emulators and testing environments to test in various scenarios.

# What

In this section we now focus on what we had to do to build the automated test. We first needed to understand the specific test cases and required test data, along with the necessary prerequisites for successful automated execution. Additionally, we ensured that in the event of a failure, sufficient data would be collected for effective debugging.

## Test Cases

We intend to test all use cases relevant for this SDK, which include: `Login` `Refresh Token` `User Info` `Logout` in combination with certain [Test Data](#test-data).

At first glance, these may seem like trivial tests, but we are seeking specific results for each use case and use them repeatedly in automated testing.

### Login

* Does it redirect to FusionAuth?
* Does a successful login result in a redirect to the Home screen?

### Refresh Token

* Is it refreshing the Token?

### User Info

* Is the User Info received?
* Depending on the different User Info returned, are all the different data sets handled properly?

### Logout

* Does it redirect to FusionAuth?
* Does it invalidate the user session?
* Does it return to the Login screen?

## Test Data

All the relevant data for testing is defined in FusionAuth which includes multiple flavors of Applicatoins and Users.

### Kickstart Details

<RemoteContent url="https://raw.githubusercontent.com/FusionAuth/fusionauth-quickstart-kotlin-android-native/main/TESTING.md"
    tags="forDocSiteKickstart" />

#### Why 10.0.2.2

Usually the Tenant Issuer is set to your developer machine or localhost, but in the case of Android Emulator this work slightly differently as its a virtual machine. [Set up Android Emulator networking](https://developer.android.com/studio/run/emulator-networking) explains in more details how it works, and in our case we want to use the android emulator to standardise the development environment and more importantly be able to create a test automation in GitHub workflows.

And in the case of Android Emulator case 10.0.2.2 is a special alias to your host loopback interface (127.0.0.1 on your development machine) where FusionAuth is running. Or in the case of the GitHub the virtual machine the workflow runs on.

## Test Automation

The Quickstart includes a [Full End 2 End Test](complete-application/app/src/androidTest/java/io/fusionauth/sdk/FullEnd2EndTest.kt) that uses all the different functionalities provided by the example App.

### Test Automation Prerequisites

#### Emulator Image

Starting the emulator requires the right image for the test, we’re using the `google_apis` images for the last 5 API level.

In particular 29, 30, 31, 33, and 34, the 32 API level is skipped as it is a special [Android 12L release](https://blog.google/products/android/12l-larger-screens/) for tablets and foldables with different layouts we're not concerned about.

Android Studio offers you to configure and handle emulators within the IDE, but you can go via the [emulator commandline](https://developer.android.com/studio/run/emulator-commandline) too.

If you’re automating your tests with a test matrix, it is important to know the change of the architecture starting at API Level 31 to `x86_64` from previously `x86`.

Which results in our case in the following five emulator configurations:

| api-level | target      | arch   |
|-----------|-------------|--------|
| 29        | google_apis | x86    |
| 30        | google_apis | x86    |
| 31        | google_apis | x86_64 |
| 33        | google_apis | x86_64 |
| 34        | google_apis | x86_64 |

An example of such an automation you can find in the [e2e-test workflows](https://github.com/FusionAuth/fusionauth-android-sdk/tree/main/.github/workflows) of the FusionAuth Android SDK.

#### Browser

Every time an emulator is started for the first time the Browser setup is not suitable for Testing as it will popup different modals like `Welcome to Chrome` or `Sign in to Chrome`, which are changing with every Chrome version.

To prevent chrome displaying any of these modals no matter the version, we execute the following commands once the emulator is started:

```
adb shell pm clear com.android.chrome
adb shell am set-debug-app --persistent com.android.chrome
adb shell 'echo "chrome --disable-fre --no-default-browser-check --no-first-run" > /data/local/tmp/chrome-command-line'
```

This is something you have to do only once for your emulator. But gets important during fully automated testing scenarios in a workflow, where the emulator is setup from scratch with every test.

With Android Studio you can start the emulator and start chrome manually to skip the modals, or use the `adb` command ([Android Debug Bridge](https://developer.android.com/tools/adb)) which can be found in your Android SDK installation:

```
$HOME/Android/Sdk/platform-tools/adb
```

#### Recording

All thought there are a lot of log details in your IDE and automated workflow to help to debug a failed test. It makes sense to watch the test in the emulator or to record the test as a video for further debugging input and context.

If you automate your test in a workflow you can pass this before starting the test command:

```
adb emu screenrecord start --time-limit 300 ./recording_video.webm
```

Depending on the build time of your App you might see only a Mobile screen for some time untill your App is started and displayed.

### Test Automation Setup

The `setUp` test initialization includes the following steps:
- Initializes `Intents`.
- Sets up `uiAutomation` to interact with the system UI.

### Automated End-to-End Test (`e2eTest`)

This test validates the application by executing the following steps, as a user would:

1. Taps the login button(`start_auth`).
2. Waits for the login form to appear.
3. Fills in the username(`richard@example.com`) and password(`password`) in the login form.
4. Submits the form using the enter key.
5. Waits for the token view to be shown(`sign_out`).
6. Checks the refresh token functionality by comparing the token expiration time before and after the refresh.
7. Taps the logout button(`sign_out`).
8. Waits for the login activity to be displayed again.
9. Repeats steps 3-8 for a second user, using username `gilfoyle@example.com` and their password.

This test is then repeated a second time with `RepeatRule` to ensure logout was successful and the login form is displayed again.

Helper methods are used throughout the test to interact with the UI:

- `closeKeyboardIfOpen`: Closes the system's keyboard if it's open, preventing it from obscuring the UI elements being interacted with.

### Test Teardown

The test concludes by releasing the initialized intents in the `tearDown` method.

### Constants

The constants used in the test include:
- `USERNAME`, `PASSWORD`: Credentials of the first user.
- `USERNAME2`, `PASSWORD2`: Credentials of the second user.
- `TIMEOUT_MILLIS`: The duration for which the test waits for the UI elements to appear in the system, expressed in milliseconds.

Please note that the username, password, and timeouts would typically be environment-specific and not part of the test code.

## GitHub Automation

Once the automation in Android Studio works as expected we can continue to automate the workflows in GitHub.

### Workflow

In the case of the Android SDK we created 3 different workflows:

| Name | Android | FusionAuth | Purpose |
|---|---|---|---|
| e2e-test-fusionauth-latest-android-latest.yml | Latest Android API Level | Latest FusionAuth Version (Latest Tag) | Weekly Testing |
| e2e-test-fusionauth-latest-android-matrix.yml | Last 5 Android API Level | Latest FusionAuth Version (SemVer Tag) | Pull Request Testing |
| e2e-test-fusionauth-matrix-android-latest.yml | Latest Android API Level | Last 6 Months of FusionAuth (SemVer Tags) | Pre-Release and Release Testing |

The Weekly Testing makes sure that as soon as a new version of FusionAuth is released it gets automatically tested. Where the Pull Request Testing makes sure that any changes are backward compatible with multiple versions of Android and the latest successfully tested FusionAuth version. And the Pre-Release and Release Testing will make sure a certain level of backward compatibility with FusionAuth is guaranteed.

With the Latest Android API Level we follow the minimum requirement of [Target API level requirements for Google Play apps](https://support.google.com/googleplay/android-developer/answer/11926878).

In all the workflows we use certain actions to setup and run the end-to-end test in GitHub.

#### Create and start FusionAuth containers used by E2E test

As we are testing against a real FusionAuth backend we use the [fusionauth-action](https://github.com/marketplace/actions/fusionauth-action) to create a running instance.

```
- name: Start FusionAuth
  uses: fusionauth/fusionauth-github-action@v1.0.4
  with:
    FUSIONAUTH_VERSION: ${{ env.fusionauth-docker-image-version }}
    FUSIONAUTH_APP_KICKSTART_DIRECTORY_PATH: fusionauth/${{ env.fusionauth-docker-image-version }}/kickstart
```

#### Android Emulator Runner

Running the Android emulator, configuring chrome, recording and running the test is done using [Android Emulator Runner](https://github.com/marketplace/actions/android-emulator-runner).

```
- name: run tests
  uses: reactivecircus/android-emulator-runner@v2.31.0
  with:
    api-level: ${{ matrix.api-level }}
    target: ${{ matrix.target }}
    arch: ${{ matrix.arch }}
    script: |
      adb shell pm clear com.android.chrome
      adb shell am set-debug-app --persistent com.android.chrome
      adb shell 'echo "chrome --disable-fre --no-default-browser-check --no-first-run" > /data/local/tmp/chrome-command-line'
      adb emu screenrecord start --time-limit 300 ./recording_video.webm
      ./gradlew connectedAndroidTest
```

#### Upload E2E Test recording

And we upload the screen recording in case of a failure with [Upload a Build Artifact](https://github.com/marketplace/actions/upload-a-build-artifact) for additional context while debugging.

```
- name: Upload recording
  uses: actions/upload-artifact@v4.3.3
  if: ${{ failure() }}
  with:
    name: 'E2E Test recording - ${{ matrix.api-level }} ${{ matrix.target }} ${{ matrix.arch }} ${{ env.fusionauth-docker-image-version }}'
    path: recording_video.webm
```

### Dependabot

Once the end-to-end tests are fully automated in GitHub workflows which get triggered on each pull request to main, the next step is to create a dependabot configuration with [grouped dependencies](https://docs.github.com/en/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file#groups) checks for github-actions and gradle.

This helps to verify changes to the github workflows itself and automatically test them as dependabot creates pull requests with all dependencies updated at once. Which is even more important if it comes to gradle dependencies, where updates are frequently published for a whole group of packages at once.

#### Maintain dependencies for GitHub Actions

For GitHub Actions we create a dependabot configuration to check dev and prod dependencies weekly. All thought that at the moment all actions are treated as prod dependencies by dependabot this behaviour could change in the future and we leave both in to make sure both are caught.

The benefit of versioning your GitHub Actions to MAJOR.MINOR.PATCH is a more stable testing environment, and dependabot handles the otherwise problematic disadvantage of not having to keep the tests up to date manually.

```
- package-ecosystem: "github-actions"
  directory: "/" # Uses default location of GitHub Workflows
  schedule:
    interval: "weekly"
  groups:
    prod-github-actions:
      dependency-type: "production"
    dev-github-actions:
      dependency-type: "development"
```

#### Maintain dependencies for Gradle

For Gradle we decided to start with a simple rule to create a weekly check which groups all minor and patch releases together into one pull request and separate major version changes in individual PRs. It is important to know that once dependabot uses a dependency in a Pull Request it won't be used in another PR at the same time.

This way we have a simple configuration which handles most of the cases without needing to go in to detail of gradle dependency management. And major versions most of the time have breaking changes which require manual interventions anyway.

```
- package-ecosystem: "gradle"
  directory: "/"
  schedule:
    interval: "weekly"
  groups:
    gradle-minor-dependencies:
      update-types:
        - "minor"
        - "patch"
```

# Conclusion

Implementing FusionAuth enables seamless integration of various features, from basic identity management to advanced functionalities like detailed user profiles and role management. Given the reliance of user-facing functionalities on FusionAuth, it is crucial to verify that all features work correctly with each new release. And automated end-to-end testing ensures a thorough validation of compatibility and functionality.

All thought automating End-to-End testing a Android App with OAuth can be complex. We successfully built a integrated it for our SDK.

Our end-to-end test suite has been tested in the meantime against numerous updates and releases during the SDK development, serving as a pass/fail criteria for pull requests and pre-release checks in our GitHub project. With this we already successfully identified fully automated and pro actively functional issues, one in the [compatibility with the new scope feature of FusionAuth](https://github.com/FusionAuth/fusionauth-android-sdk/pull/60) and as well with [external libraries](https://github.com/FusionAuth/fusionauth-android-sdk/pull/88).

With these robust automated tests in place, we maintain consistent standards of quality and reliability for our Android SDK, providing a seamless and secure user experience.
