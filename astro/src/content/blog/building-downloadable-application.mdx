---
publish_date: 2024-07-08 
title: Building a downloadable product in 2024
description: In this tutorial, you'll create User Actions to coordinate events around a customer purchase.
authors: Dan Moore
categories: Education
tags: download, product, architecture, air gapping
image: /img/blogs/fusionauth-user-actions/user-actions.png
excerpt_separator: "{/* more */}"
---

In this article, you'll learn about the architecture, business model, and software design choices necessary to create a downloadable developer tool. FusionAuth the product is designed to be [downloaded and run locally](/download). While you can pay FusionAuth, the company, to run FusionAuth, the product, [for you in the cloud](/docs/get-started/run-in-the-cloud/cloud) as a SaaS offering, many users run FusionAuth on their own servers or laptops.

This article will focus on developer tools that are sold and require integration in an existing application, rather than standalone developer tools such as an IDE or products given away for free. Examples of the types of tools that this post applies to include:

* a message queue
* an analytics tool
* authorization as a service
* a database
* an identity provider offering authentication

{/* more */}

But first, why would you do this? Isn't the future SaaS, where you are consuming software as a service over the internet?

## Why Build A Downloadable Developer Tool

There are a number of reasons to build a downloadable, self-hostable developer tool that integrates with other parts of an application.

### Control

The main reason to build a downloadable product is to allow develoers to have more control. Developers like control. With a SaaS solution, especially one built using a typical multi-tenant SaaS architecture, developers have limited control. The list of items that they cede control over when using such a SaaS offering includes, but is not limited to:

* data locality
* performance
* software versions
* availability

As a SaaS provider, you can work around some of these limits. For example, APIs can be versioned and you can offer a SaaS in multiple geographic areas. But there will be limits. You are unlikely to be able to stand up a server in Greece or Zimbabwe. TODO brandur article about API versioning as does AWS).

For the typical SaaS offering, developers don't have as much control as they do if they self-host.

If you, on the other hand, offer a downloadable piece of software that can be hosted on any Linux or Windows server, developers regain control. Users can run the product on their own hardware, using their own datastores, in their own network. If there's a performance issue, they can troubleshoot it. If they want to minimize network hops between your product and their service, they can configure the network properly. If the service or product is unavailable, they have control over the fix. If they want to pin your product to a certain version, they can do so by not upgrading. They can treat the product like a library dependency, switching versions when it is convenient.

There are privacy benefits too. The customer, by examining the network, can know exactly what data is sent to the product company. By locking down ext or preventing any data from being sent.

Data locality is one aspect of control that is becoming more important, though how criticial it is depends on the data your product holds. For personally identifiable information about customers in certain localities, such as Europe or California, you want to know exactly where the data is going. Not doing so can lead to harsh penalties.

If you have a product that operates on large amounts of data or highly proprietary and closely held data, it can be easier to bring the product to the data, rather than force the customer to bring data to the product. Building a downloadable product enables this delivery mechanism.

**By operating a product themselves, you can offer customers control.** That can be very appealing to a certain kind of customer.

There are other benefits as well.

### CI/CD Simplicity

While many CI/CD environments are connected to the internet, having them self contained makes it easier to stand up many copies. Each test run can configure the local software installation just as it needs to and independently run the tests.

Depending on the number of developers running against it, a SaaS solution can be slower and more fragile to test against. You are going over the network and your configuration may collide with other developers' needs.

### Discovery And Distribution

By offering a downloadable product in various developer friendly installation formats, you can let developers discover and integrate with your product without ever talking to anybody. This lets developers find out if your solution will work for them, using their own hardware and in their own environments, at near zero cost to you.

Some of these installation formats include:

* Homebrew
* Docker
* RPMs/DEBs
* Windows Installation Packages
* MacOS Disk Images
* Ruby Gems
* Maven Packages

You'll need to discuss how to make money from some of these users somehow; that'll be examined later on.

### Business Continuity

Self-hosting decreases business continuity risks for your customers. If your company fails, is acquired or otherwise ceases to operate, customers can continue to run your product. It won't necessarily be an easy path since the product won't improve. But if they depend on your product for critical business processes, your users can keep your product running as they search for and evaluate alternatives.

After they find a solution, they can schedule migration work when it makes sense, depending on the level of integration effort and other obligations.

Contrast this with a pure SaaS product that goes away. Customers completely lose access to the functionality. Additionally, customers are at the mercy of the SaaS companies export functionality, if built, to access their data.

### Offline Or Limited Network Support

When you have a downloadable product, you can more easily support for offline or limited network use cases. Some of these use cases include:

* Better, more independent development machines. By using a downloadable tool, developers can have the entire application, with all its components, running on their laptop. While locations that are truly 100% offline are becoming fewer (thanks Starlink!) it can still be quite freeing to not rely on an external service. Local services are quicker to stand up and easier to develop against.
* Out of the ordinary production use cases that require air gapping. There are places that don't have internet connectivity or where internet connectivity is limited. This includes commercial situations like cruise ships and kiosks, as well as high security situations where data is precious. TODO If you have a downloadable product that doesn't need internet connectivity to function, you can serve customers in these situations.

### Your Customer's Budget

If users are running a downloadable product in their own environment, they can control costs in the same way they do for their own software.

This may include using solutions to optimize compute or network. 

### Your Budget

As the seller of a developer tool, you can also decrease your expenses. You sell the product, but they run it. This means that the expenses of operating it fall on your customer.

Let's talk about what to consider when building a self-hostable developer tool.

## What To Think About When Thinking About Building A Downloadable Product

There is a lot to consider from a technical perspective when building a downloadable, self-hostable product. But front and center are dependencies.

### Dependencies

Keep required dependencies to a minimum. This will make your users' lives easier when they are deploying and operating the product, as well as making your life easier when you are supporting your users. For instance, FusionAuth requires the following components if you are self-hosting:

* A relational database
* Elasticsearch or OpenSearch (optional)
* A proxy (optional)

That's it.

Now, it's not like SaaS companies are incorporating all kinds of unneeded functionality or datastores, but if the engineering team sees a need, they have that flexibility. If they need a message queue or multiple datastores for additional functionality, the operational burden can be discussed internally, prioritized and implemented. Asking your customers to learn how to run a NoSQL datastore or message queue, on the other hand, impacts your total market. So you'll want to keep your required architectural components minimal.

If you can bundle all your dependencies with your product, that's even better. Bundle your runtime too so that you don't have to worry about minor version incompatibilities. FusionAuth bundles a known version of Java and nothing else is supported.

A non-technical but important nuance is that if you are using GPL libraries and you provide a binary to your customers, you must provide them with source code too. SaaS TODO companies have the workaround of delivering features but not executables. This is something to consider as you look at your dependencies.

### Deployment Processes

This points to another complexity of downloadable software. In contrast to SaaS, where the deployment process can be complex, for a self-hosted solution you want deployment to be as simple as possible. The installation method becomes critical; it is probably the first experience a developer has with your software. You have to have great installation documentation, which needs to handle all the methods you want to allow.

You'll want to allow a variety of installation methods, too. What methods you support depends on where you expect your customer to run your software, but you'll want to consider:

* Hardware options such as VMs, containers and bare metal
* Operating systems, such as Windows, MacOS and Linux
* Delivery mechanisms such as homebrew, RPMs and Docker
* Dependencies of the major components, including cloud versions

If possible, abstract as many of these away as you can by using a VM like the JVM or a cross compiled language like golang.

### The Network Is The Computer

Think about access to the network as a dependency as well. A downloadable product has the ability to work with no or minimal network access. Depending on your product, you may make foundational or basic functionality available with no network access, but require it for enhanced capabilities.

Such capabilities might include pulling down a license to ensure the product has been purchased or data for features. If you want to offer a true air gapped experience, where no network access at all is allowed, then consider if or how to offer such features or how to verify a license is legitimate.

Downloading data to enable additional functionality requires network traffic. For example, FusionAuth has a corpus of breached passwords that is too large to ship as part of the downloadable executable. You'll want to build in retry logic so if a disk is full or a network is spotty, the data can still be downloaded. 

### Tooling

There are many tools to help you build a better product. There are applications which can help you undersand feature usage, find and squash bugs, or even offer core, undifferentiated functionality like notifications. Many of these are only built for SaaS products. They expect network connectivity.

Sorry, these are no longer for you. You can look to them for inspiration or seek out downloadable choices, but anything that expects to be installed in a SaaS is off-limits.

### Releasing

With a SaaS product, you can roll versions forward or backward easily. This is often done using CI/CD and can be automated. If not automated, you have total control over your server side code. (Client side JS may be cached and mobile apps are a bit different too.)

With server side control, you can canary your changes. By sending a subset of your users through new code paths, you can test if anything breaks without your entire userbase seeing the changes. This can be managed via networking rules at a load balancer or with other tools. With blue/green deployments you can, if your architecture and datastore support it, stand up an entirely separate application and shift traffic gently over to it. Or away from it if the new code isn't performing as it should.

Releasing a downloadable product is different. You have limited control over how your customers deploy you. Remember, as a downloadable product developer, you gave that power to them. You now have a limited ability to upgrade or downgrade. 

Therefore, when you release you need to make extra sure that it is quality. You need rigourous testing across all the supported platforms, architectural components and deployment scenarios. This effort is above and beyond the feature and bugfix testing required of any solid software product, be it downloadable or delivered as a SaaS.

You can work around some limitations, however. For instance, you could build in an automatic upgrade the way that Chrome does. If you do this, make sure you handle network connectivity issues and that your users understand they are installing a downloadable tool that will automatically upgrade functionality. You can also build in automatic downgrading or rolling back of an upgrade. You'll have to build in the tooling and infrastructure to handle such changes in self-contained way. 

Another workaroud is offering beta or early access programs to let customers self-select into running versions of your software not available to the wider public. While this can give you some information that canary deployments would in a pure SaaS, such early access installs happen at the discretion of your customer, rather than being in your control. 

This means you need to document and build your systems such that your users have a clear idea of the impact of production upgrades. There are several approaches, including separating the control and data plane functionality and maintaining strict n-1 version backwards compatibility.

Whatever your release strategy, it must be documented and made available to the developers who build on top of your downloadable product.

### Release Communication

In addition to the nuts and bolts of how a release happens and what impact it has on your users, you need to make sure they know about it, which is a prerequisite to them upgrading.

You must communicate to the user that a new release of your package is available. At FusionAuth, we offer:

* an RSS feed
* a generic new version email list
* a security focused email list
* customer outreach when appropriate

### Third Party Components

The more third party components you bundle, the tighter you can control your dependencies. But this comes at the cost of less flexibility.

For example, consider a situation where your product depends on a relational database. If you don't bundle your database, deployment is simpler; you specify what database and versions you support. Your customer can leverage their database expertise across multiple applications. But you'll need to provide a schema management mechanism. Any changes also must be performant on a variedy of database sizes. Since you don't know how much data customers have stored, you'll need to test with small and large amounts of data before any changes can be released. 

If you support mutiple databases, the schema you ship will need to support them. You'll want to make sure you don't use advanced features of one database which are not available in others. You'll also want to test performance across supported versions of all databases.

Estimate product usage so you can add appropriate indices, which improve read time drastically but can impact write time. 

If you offer rollbacks, you'll need to make sure schema changes don't destroy or degrade data that would make a rollback impossible, such as dropping a column or changing the column to a datatype with less fidelity.

### Understanding Product Usage

Ever used tooling which lets you know what features are used by which users? And which users in a new cohort are similar to users who purchased in the past? Such tooling is foundational for operational efficiencies of SaaS vendors everywhere. Again, that tooling is not for you, unless you build it. The more you report, the higher the impact on your users privacy. Which, if you'll recall, is one of the benefits of self-hostable software.

You should capture only what you need to improve the product, be clear about what you are recording, and have a bright line between the usage data and private data stored in your system. For example, record that feature X is being used, but not the details of the data which feature X is operating on.

Usage reporting may be required for monetization purposes, as well, depending on the product.

Be clear with your customers about what you are gathering and why. Offer them a chance to turn it off. And realize that some self-hosting customers may choose to go beyond turing it off and block network access, which will disable usage statistics reporting.

### Support

Offering support is more difficult with a downloadable product. You are not only answering questions about how to use your product, some of which may be quite niche or twist your product in different ways. In fact developers often depend on undocumented but observable features; [see Hyrum's Law](https://www.hyrumslaw.com/). On top of that, you also need to support heterogenous deployment environments.

In such a world, how do you stand up an environment to replicate an issue? Sometimes you can, but often hopping on a call with a customer to see their environment is more efficient. The more you can bundle, the better off you are in this respect.

You'll have customers and users using different versions and you'll need to think about how to support them. How old a version will you support? What if a customer is paying you?

Since everyone is not on the same version, think about if and when to backport bug fixes, which increases development complexity. This includes security fixes too.

Create a long term support (LTS) program like Linux distributions or programming languages. An LTS lets developers using your tool upgrade to certain supported versions and stick to them for a long period of time. Critical downloadable products share a lot of similarities with programming languages. Your users may be hesitant to invest to regularly upgrading your product. Features can incent that, but once your product meets their needs, they may resist upgrading.

You'll also want a mechanism for backporting certain critical fixes to these LTS versions, particular security fixes.

### Customer Enablement

The above are all considerations you and your engineering team must consider when building a downloadable product. But what else does your customer need to succeed?

Operating software can be difficult. That is why many people prefer SaaS solutions, after all. But many teams self-host other parts of their application, whether in a cloud or on their own hardware. These teams have skills to operate software at the scale and performance their employer needs. If you are selling a downloadable product, enable such teams with great docs. This includes detailed documentation around:

* installation
* scaling
* performance tuning
* monitoring
* troubleshooting
* system requirements
* infrastructure integrations
* tooling integrations
* upgrades

You'll need to make this as thorough, accurate and complete as you can. However, the number of possible combinations of how your software can be installed or operated is nearly infinite. You can try to limit the effort by documenting the most common integrations and complementary software components.

Clearly document your changes too, as part of your release notes. You can do this in lo-fi ways such as semver or high fidelity ways like release notes. Provide a way for your users to be notified of changes easily. Methods that can work:

* notification within your application, if there is a UI
* user messages if there is a CLI
* an email list
* an RSS feed

### Configuration Management

The type of organization that can confidently self host critical infrastructure typically requires configuration management capabilities. This is functionality which allows configuration of your application via an API or tooling like Terraform or Pulumi. This allows your customers manage changes to your product in the same way they manage other parts of their application infrastructure.

## What Kind Of Software Makes Sense

Not every type of developer tool makes sense to build as a downloadable solution. But if your product:

* has an offline use case
* appeals to customers familiar with operating software
* solves a critical problem
* integrates with existing well known components
* offers functionality used by a large number of applications

then you should consider a creating a self-hostable solution.

## Monetization 

If you want to sell your downloadable product, you have a few options.

* support
* advanced features
* hosting

Each of these have strengths and weaknesses.

Support is easy to offer; allow some users to pay for access to a slack channel, ticketing system or email address. However, support requires an investment in employees and doesn't scale linearly. For a downloadable product, support can be more complex to offer, as discussed above.

Advanced features can scale revenue without increasing costs, but require significant upfront investment. They also require a licensing system which typically requires network access.

With hosting, single tenant SaaS is a natural fit. You can offer customer controlled upgrades or a fully managed SaaS, depending on what your customer needs and how stable the integration interfaces are. However, you are now responsible for uptime, performance and other aspects of operating software. 

A 'you host or we host' option allows you to offer some of the benefits of SaaS without losing all the benefits of a self-hosted solution. This can be very appealing for customers because they can either start out self-hosted for control or cost and migrate to SaaS when they are ready, or they can start out SaaS to get up and running quickly and migrate to self-hosted when they have a team ready to operate the software and want more control.

### What About Open Source

A self-hostable solution can be open source software (OSS) but doesn't have to be. OSS has lots of benefits in terms of community feedback, bug fixes, and easy adoption, but there are alternatives too. You can offer a free-as-in-beer version of your software. By doing so, you gain many of the marketing and distribution benefits of open source without business model risks. These risksinclude:

* others reselling your product
* forks if the community disagrees with product decisions
* limited monetization options

On the other hand, you won't get the halo effect of an OSS product, you'll have a harder time building trust, you won't get many contributions, and building a community is more difficult.

However, there have been enough re-licenses recently that developers know that just because a solution starts open source doesn't mean it will stay that way. Leaning into the argument that you are building a sustainable business may be enough for some of your users, but for others nothing short of full OSS will satisfy them. That's okay, you don't need to build a product for everyone. Either way, be prepared to defend your decision.

## Conclusion

There is unique value in building a self-hostable developer tool, but there are corresponding challenges as well. If you are purely self-hostable, you are limited to a certain kind of customer who can and wants to operate their own infrastructure, but they'll need the tooling and documentation to support that desire. You hae a variety of monetization options, but some cut your margins.

