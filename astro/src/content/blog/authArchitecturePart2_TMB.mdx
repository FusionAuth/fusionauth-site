---
publish_date: 2025-10-08
title: "Token-mediating backend: An alternative to the BFF architecture"
htmlTitle: "Part 2 of 3 on authentication architecture | FusionAuth"
description: "Learn how a token-mediating backend (TMB) is less secure than a BFF, and when to use it. Part 2 of 3 in the architecture-driven auth series."
image: /img/blogs/bff/bff-header.png # TODO: replace image
authors: Kim Maida
categories: Education, Security
tags: oauth, security, BFF, TMB, React, tokens, architecture, FusionAuth
excerpt_separator: "{/* more */}"
---

import {RemoteCode} from '@fusionauth/astro-components';
import Aside from 'src/components/Aside.astro';
import Breadcrumb from 'src/components/Breadcrumb.astro';
import InlineField from 'src/components/InlineField.astro';
import InlineUIElement from 'src/components/InlineUIElement.astro';
import PremiumPlanBlurb from 'src/content/docs/_shared/_premium-plan-blurb.astro';

{/* Search for TODO before publishing this. */}

## Introduction

This post discusses the token-mediating backend (TMB) authentication architecture: how secure it is, when to use it, and how to implement it. This is part two of a three part series on OAuth2 architectures. Please read [part one](/blog/TODO) if you haven't already, so you understand how the BFF architecture works, since TMB is a variation of BFF.

## What is a Token-Mediating Backend?

A TMB is identical to the BFF pattern you learnt in part one, except for one difference: access tokens are stored in the frontend (desktop app, mobile app, or web app) instead of in the backend. (Remember that the access token is the secret that gives a client permission to call a resource server). Since the access token is now available in the browser, the browser can call a resource server directly, instead of having to call the backend and get the backend to call the resource server with the token.




- Link to OAuth2 TMB spec

## How secure is a TMB?
- Massively less secure than BFF in part 1, as tokens are stored in browser localStorage and thus vulnerable to malicious JS.
- Massively more secure than serverless app in part 3.
- Protected from cross site attacks.
- Successful attacks are short-lived if you follow best practices (link to OAuth 2.1 draft and explain, with summary link to https://maida.kim/oauth2-best-practices-for-developers), which include short timeouts on tokens.

## When to use a TMB?
- Only if you cannot, or may not, call a resource server through a proxy (backend) server and must call it through the frontend directly. (Can't think of an example of this, I must go find or LLM one)

The spec only says this:

> When considering a token-mediating backend architecture, it is strongly recommended to evaluate if adopting a full BFF as discussed in Section 6.1 is a viable alternative. Only when the use cases or system requirements would prevent the use of a proxying BFF should the token-mediating backend be considered over a full BFF.

Performance and latency costs could be a reason not to, such as in use cases like game or video streaming and realtime stuff (like collaboration tools like Figma).

Infrastructure can also impact this... like PaaS that are meant to deploy static sites.

But honestly, the one that would probably affect the most people is that, if you're using a third party auth server, many of them use TMB out of the box.


- Aside, FA uses BFF by default, with easy to use hosted backend; perhaps with link to first articleâ€™s section on BFF-HB benefits
- Even if your auth provider SDK doesn't provide a hosted backend it's still trivial to create a BFF in a tiny page of JS (see my article here https://fusionauth.io/blog/backend-for-frontend#how-to-create-a-bff-for-a-serverless-app and code here https://github.com/FusionAuth/fusionauth-example-hostedbackend/blob/main/nodeApp/app.js)

## Getting technical: how the TMB flow works
- This section explains the TMB oauth flow
- You can skip it and proceed to the demo in the next section if you don't need to implement or understand the details yourself
- First review the BFF flow in part 1
- Explanation the differences with an example login and resource call, include a diagram
- Potential attacks noted

## Code demonstration
- The section will allow you to run a simple but functional TMB web app and server with FA to see how it works
### Prerequisites
- Docker, Node/Bun/Deno
### Run the app
- Download, configure, run, login, usernames and passwords, screenshots
### How it works
- Briefly describe what's in each file

## Summary
- Brief repeat of the 'when to use section' because of the 'how secure' section.
- Link to FA hosted backend

## Read part 3
- Brief description of what's in that article

## Links

- niel bff article - https://github.com/FusionAuth/fusionauth-site/pull/3942
- my old article with diagrams to reuse - https://fusionauth.io/blog/backend-for-frontend
- kim talk - https://drive.google.com/file/d/1B40E5zmVHaGfE9kEMAbOWRy3YS2D2EcC/view?pli=1
- kim's 3 part brief - https://docs.google.com/document/d/1FZzTzodOd9YQOCVKhi4V46LiUPbRvnsy2XQ5dTC0mg0/edit?tab=t.0
- kim repo - https://github.com/kmaida/auth-architecture
- kim article on oauth best practices - https://maida.kim/oauth2-best-practices-for-developers/
- kim's outline feedback - https://github.com/FusionAuth/fusionauth-site/pull/3949/files

---


## kim talk notes

3 archs
authen, author
  auth(orization) server - issues authen and author tokens
  id tokens for authen
  access tokens for author
  refresh tokens renew other tokens
browser based apps - spa, static sites
  app, server, db, api
  or platform as a service
backend can safely store secrets, sessions, and tokens (incl. http only cookies)
frontend can't safely store secrets, can't have sessions as lost on reload, can't store tokens due to xss attacks
if you have a bff you can safely implements security

- bff advantages
  - backend is confidential
  - no csrf attacks
  - no token theft
  - can't use stolen tokens
- disadvantages
  - complex
  - same domain cookies only
  - more work to proxy apis instead of calling
  - need to learn oauth2
  - manual implementation (unless provider like FA provides bff)

### token mediating backend (TMB)
- similar to bff - all auth done securely in backend. session in backend.
- no refresh tokens in the browser, but access tokens are in the browser (in app memory)
- uses authorz code flow with pkce
- backend must keep latest access token by refreshing with refresh token so it's available when browser needs it
- browser calls resource server directly with the access token, rather than through backend proxy
- can use session cookie or access token to call local backend
- advantages
  - backend confidential
  - no crsf attacks
  - customisable security arch
  - refresh token can't be stolen
  - browser can directly call resource api (no need to use backend)
  - common approach in many auth platform JS SDKs
- disadvantage
  - still complexand requires backend
  - need to learn oauth2
  - access token can be stolen from app memory by theft
  - requires additional security
- oauth 2.1 consolidates best practices, though is not yet final. summary of recommendations is here: https://maida.kim/oauth2-best-practices-for-developers.
- frontend only (serverless apps)
  - no safe place to store tokens
  - use only for data that would not be disastrous to leak online
  - authen is just for convenience
  - least secure
    - never store tokens
    - short life time tokens (15m) - user has to log in again with password
    - tokens single use and rotated
  - advantages
    - simpler
    - easy to implement with sdks
    - frontend can call resource server directly
  - disadvantages
    - can't store secrets
    - user must relogin
    - not suitable for apps that needs secrecy of any time
    - best practices are need (see kim article link) but still don't help much
- which to use?
  - bff always where possible - critical information, regulations, external api requests
  - tmb - when you can't proxy external apis
  - bboc (browser based oauth 2 client) - architect limtations, auth for convenience not security, need to access no apis or cross origin apis
- FA supports all three archs. TMB and serverless need manual implementation(fa provides client libraries, you must implement the design). if dev doesn't want FA hosted backend, they can use SDK to create their own
- competitors: 30:47 for table
- refer to ietf draft 6.2 - tmb (2.0 and 2.1)
- 9700 best current practice (to be incorporated into 2.1)

## todo
fa - fusionauth
remove temp niel 1 article
rename article with -
remove unused imports
use fa widget instead of docker?