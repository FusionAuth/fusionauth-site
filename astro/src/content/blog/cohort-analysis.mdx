---
publish_date: 2025-12-01
title: "Analyzing why customers leave — cohort analysis in FusionAuth"
description: ""
authors: Person McPersonface
image: /img/blogs/header-example.svg
categories: Education
tags: user, analysis, retention
excerpt_separator: "{/* more */}"
---

import Aside from 'src/components/Aside.astro';
import Breadcrumb from 'src/components/Breadcrumb.astro';
import InlineField from 'src/components/InlineField.astro';
import InlineUIElement from 'src/components/InlineUIElement.astro';

- [Introduction](#introduction)
- [Some useful customer statistics](#some-useful-customer-statistics)
- [Extract customer data](#extract-customer-data)
- [Calculate user statistics and display in charts](#calculate-user-statistics-and-display-in-charts)
- [Summary](#summary)
- [Appendix — How to create fake customer data in FA](#appendix--how-to-create-fake-customer-data-in-fa)
- [todo](#todo)


## Introduction

Do you know how frequently your customers use your app? Do you know how many people sign up but quickly lose interest in your service? In this article, you'll learn how to use FA track customer statistics: retention rates, customer age analysis, and customer cohorts (groups). While you need to investigate your own application database for reasons *why* customers stay or leave, having a base of FA login stats to work from lets you know who to analyze.

## Some useful customer statistics

FA has a few built-in charts with views of total logins and registrations. But if you want a deeper analysis, you need to extract your customer data and calculate your own statistics.

![Existing FA charts](../../../../astro/public/img/blogs/cohort-analysis/faCharts.webp)

data available: customer identifier, registration date, series of login dates

stats per customer: has verified, verification date, acquisition (date registered), login frequency, login regularity, abandonment (date of last login)

groups: for each stat you can create groups to get an idea of numbers of each type of customer

aggregate stats: customers per date, abandonment per date, acquisition by date

stats granularity can be day, month, year

look at how users used your app or support service before abandonment

List of charts:
- Total number of users (split bar chart showing verified/unverified) per year and month
- User acquisition per year and month (sales performance)
- Number of users per age in years (mirror image of user acquisition per year, but shows customer analysis and retention)
- Number of logins per year and month
- Number of users that haven't logged in for 1, 2, 6, 12 months
- Number users that haven't logged in for 6 months by year <-- TODO START THIS
- Number of users that log in 1,10,>10 times per month

- Active users grouped by age and year of reqistration
- Returning users by month (users who haven't logged in in the last 6 months who returned in a specific month (new feature, competitor change, or advertising)

## Extract customer data

While application databases, like FA, store data in a denormalized structure to save space, data analysis needs data to be normalized for fast retrieval and computation.

The first step to analyze your user data in FA is to extract it and store it in a usable format. As this process puts the database under load, you should run it on a copy of your database, or when few users are busy.

Create a file called `extract.mjs` and insert the code below. Change the variables at the top to match your FA instance.

```js
import * as fs from 'fs/promises';

const applicationId = 'e9fdb985-9173-4e01-9d73-ac2d60d1dc8e';
const apiKey = '33052c8a-c283-4e96-9d2a-eb1215c69f8f-not-for-prod';
const faUrl = 'http://fa:9011';

async function getFaData(url) {
	try {
		const response = await fetch(faUrl+url, {
			method: 'GET',
			headers: {
				'Authorization': apiKey,
				'Content-Type': 'application/json'
			}
		});
		if (!response.ok) {
			console.error(`httpError! status: ${response.status}`);
			return;
		}
		const result = await response.json();
		return result;
	}
	catch (error) {
		console.error(error.message);
	}
}

async function getUsersFromFaUsers(faUsers) {
	const users = [];
	for (let faUser of faUsers) {
		const identity = faUser.identities.filter((i) => i.primary)[0];
		const registration = faUser.registrations.filter((r) => r.applicationId == applicationId)[0];
		if (!registration || !identity) continue;
		const user = {
			'id': faUser.id,
			'email': faUser.email,
			'isVerified': identity.verified || ![`Completed`, `Implicit`, `Pending`].includes(identity.verifiedReason),
			'registeredDate': registration.insertInstant,
			'loginDates': []
		}
		const logins = await getFaData('/api/system/login-record/search?userId='+user.id+'&startRow=0&numberOfResults=999999');
		logins.logins.map((l) => {user.loginDates.push(l.instant);});
		user.loginDates.sort();
		users.push(user);
		console.log('Extracted user ' + user.email);
	};
	return users;
}

let faUsers = await getFaData("/api/user/search?queryString=*&numberOfResults=999999&startRow=0");
faUsers = faUsers.users;
console.log('Got all users');

await fs.writeFile('faUsers.json', JSON.stringify(faUsers, null, 2));
console.log('Wrote FA users to faUsers.json');

const users = await getUsersFromFaUsers(faUsers);
await fs.writeFile('users.json', JSON.stringify(users, null, 2));
console.log('Wrote extracted users to users.json');
```

Run the file with the command below.

```sh
node extract.mjs
```

This command creates two files, `faUsers.json` containing the raw data from FA, and `users.json` containing the processed set of users with all login dates but all other fields removed.

The `users.json` file has structure below.

```js
  [{
    id: string
    email: string
    isVerified: bool
    registeredDate: string // timestamp since 1970
    loginDates: string[] // where [0] is oldest date
  }]
```

## Calculate user statistics and display in charts

Create a file called `app.mjs` in the same directory as the `users.json` file you extracted earlier and insert the code below.

```js
// clear; docker run --init  -it --rm --name "app" -v ".:/app" -w "/app" -p 7777:7777 node:25-alpine  sh -c  "node --watch 4app.mjs";

import express from 'express';
import * as fs from 'fs/promises';

const users = await getUsersFromFile();
const app = express();
app.get('/', async (request, response) => {
	const page = await getPage(users);
	response.send(page);
});
app.listen(7777, '0.0.0.0', () => { console.log(`Express server listening at http://0.0.0.0:7777`); });

async function getUsersFromFile() {
	const fileContent = await fs.readFile('users.json', { encoding: 'utf8' });
	const users = JSON.parse(fileContent);
	for (let u of users) { // charts work with dates, not timestamp strings
		u.registeredDate = new Date(Number(u.registeredDate) * 1000);
		for (let i = 0; i < u.loginDates.length; i++) {
			if (u.loginDates[i] > 30000000000) { // check for errors
				log(" ");
				log(u.id);
				log(u.email);
				log(u.loginDates[i]);
				log(new Date(Number(u.loginDates[i]) * 1000));
			}
			u.loginDates[i] = new Date(Number(u.loginDates[i]) * 1000);
		}
	}
	// printMemoryUse(users);
	return users;
}

async function getPage(users) {
	const chartData = getChartData(users);
	const html = await fs.readFile(`5page.html`, { encoding: 'utf8' });
	return html.replace('{{CHARTDATA}}', JSON.stringify(chartData));
}

function getChartData(users) {
	const result = {
		'totalUsersPerYearChart' : { 'labels': [], 'verifiedData': [], 'unverifiedData': [] },
		'totalUsersPerMonthChart' : { 'labels': [], 'verifiedData': [], 'unverifiedData': [] },
		'newUsersPerYearChart' : { 'labels': [], 'verifiedData': [], 'unverifiedData': [] },
		'newUsersPerMonthChart' : { 'labels': [], 'verifiedData': [], 'unverifiedData': [] },
		'userAgeChart' : { 'labels': [], 'verifiedData': [], 'unverifiedData': [] },
		'loginsPerYearChart' : { 'labels': [], 'data': [] },
		'loginsPerMonthChart' : { 'labels': [], 'data': [] },
		'abandonmentPerMonthChart' : { 'labels': [1, 2, 6, 12], 'data': [0,0,0,0] },
	}
	const thisYear = new Date().getFullYear();
	const now = new Date();
	let minYear = thisYear;
	let maxYear = 0;
	let minMonth = 12;
	let yearContainingMinMonth = thisYear;
	log("Start user loop");
	users.forEach(user => {
		const yearRegistered = user.registeredDate.getFullYear();
		const monthRegistered = user.registeredDate.getMonth();
		if (yearRegistered < minYear) minYear = yearRegistered;
		if (yearRegistered > maxYear) maxYear = yearRegistered;
		if (yearRegistered < yearContainingMinMonth || (yearRegistered == yearContainingMinMonth && monthRegistered < minMonth)) {
			yearContainingMinMonth = yearRegistered;
			minMonth = monthRegistered;
		}
		let mostRecentLoginDate = new Date('1800-01-01');
		user.loginDates.forEach(loginDate => {
			if (loginDate.getFullYear() > maxYear) maxYear = loginDate.getFullYear();
			if (loginDate > mostRecentLoginDate) mostRecentLoginDate = loginDate;
		});
		addUserToAbandonmentPerMonthChart(now, mostRecentLoginDate, result.abandonmentPerMonthChart);
		const age = thisYear - yearRegistered;
		if (!result.userAgeChart.verifiedData[age]) result.userAgeChart.verifiedData[age] = 0;
		if (!result.userAgeChart.unverifiedData[age]) result.userAgeChart.unverifiedData[age] = 0;
		if (user.isVerified) result.userAgeChart.verifiedData[age]++;
		else result.userAgeChart.unverifiedData[age]++;
	});
	log("End user loop");
	for (let age = 0; age <= thisYear - minYear; age++) {
		result.userAgeChart.labels.push(age.toString());
		result.userAgeChart.verifiedData[age] = result.userAgeChart.verifiedData[age] || 0;
		result.userAgeChart.unverifiedData[age] = result.userAgeChart.unverifiedData[age] || 0;
		result.userAgeChart.verifiedData = result.userAgeChart.verifiedData.slice(0, thisYear - minYear + 1);
		result.userAgeChart.unverifiedData = result.userAgeChart.unverifiedData.slice(0, thisYear - minYear + 1);
	}
	let runningVerifiedCountYearly = 0;
	let runningUnverifiedCountYearly = 0;
	let runningVerifiedCountMonthly = 0;
	let runningUnverifiedCountMonthly = 0;
	log("Start year loop");
	for (let year = minYear; year <= maxYear; year++) {
		result.totalUsersPerYearChart.labels.push(year.toString());
		result.newUsersPerYearChart.labels.push(year.toString());
		const newVerifiedThisYear = users.filter(user => user.registeredDate.getFullYear() === year && user.isVerified === true).length;
		const newUnverifiedThisYear = users.filter(user => user.registeredDate.getFullYear() === year && user.isVerified === false).length;
		result.newUsersPerYearChart.verifiedData.push(newVerifiedThisYear);
		result.newUsersPerYearChart.unverifiedData.push(newUnverifiedThisYear);
		runningVerifiedCountYearly += newVerifiedThisYear;
		runningUnverifiedCountYearly += newUnverifiedThisYear;
		result.totalUsersPerYearChart.verifiedData.push(runningVerifiedCountYearly);
		result.totalUsersPerYearChart.unverifiedData.push(runningUnverifiedCountYearly);
		const loginsThisYear = users.reduce((sum, user) => sum + user.loginDates.filter(loginDate => loginDate.getFullYear() === year).length, 0);
		result.loginsPerYearChart.labels.push(year.toString());
		result.loginsPerYearChart.data.push(loginsThisYear);
		for (let month = 0; month < 12; month++) {
			if (year === minYear && month < minMonth) continue;
			if (year === maxYear && month > new Date().getMonth()) break;
			const newVerifiedThisMonth = users.filter(user => user.registeredDate.getFullYear() === year && user.registeredDate.getMonth() === month && user.isVerified === true).length;
			const newUnverifiedThisMonth = users.filter(user => user.registeredDate.getFullYear() === year && user.registeredDate.getMonth() === month && user.isVerified === false).length;
			runningVerifiedCountMonthly += newVerifiedThisMonth;
			runningUnverifiedCountMonthly += newUnverifiedThisMonth;
			result.totalUsersPerMonthChart.labels.push(`${year}-${String(month + 1).padStart(2, '0')}`);
			result.totalUsersPerMonthChart.verifiedData.push(runningVerifiedCountMonthly);
			result.totalUsersPerMonthChart.unverifiedData.push(runningUnverifiedCountMonthly);
			result.newUsersPerMonthChart.labels.push(`${year}-${String(month + 1).padStart(2, '0')}`);
			result.newUsersPerMonthChart.verifiedData.push(newVerifiedThisMonth);
			result.newUsersPerMonthChart.unverifiedData.push(newUnverifiedThisMonth);
			const loginsThisMonth = users.reduce((sum, user) => sum + user.loginDates.filter(loginDate => loginDate.getFullYear() === year && loginDate.getMonth() === month).length, 0);
			result.loginsPerMonthChart.labels.push(`${year}-${String(month + 1).padStart(2, '0')}`);
			result.loginsPerMonthChart.data.push(loginsThisMonth);
		}
	}
	log("End year loop");
	return result;
}

function addUserToAbandonmentPerMonthChart(now, mostRecentLoginDate, abandonmentPerMonthChart) {
	const diffTime = now.getTime() - mostRecentLoginDate.getTime();
	const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
	if (diffDays >= 365) abandonmentPerMonthChart.data[3]++;
	else if (diffDays >= 182) abandonmentPerMonthChart.data[2]++;
	else if (diffDays >= 60) abandonmentPerMonthChart.data[1]++;
	else if (diffDays >= 30) abandonmentPerMonthChart.data[0]++;
}

function printMemoryUse(users) {
	const jsonString = JSON.stringify(users);
	const arraySizeInBytes = Buffer.byteLength(jsonString, 'utf8');
	const arraySizeInMiB = (arraySizeInBytes / (1024 * 1024)).toFixed(2);
	console.log(`Users array is approximately ${arraySizeInBytes} bytes, or ${arraySizeInMiB} MiB.`);
}

function log(msg) {
	console.log(msg);
}
```

page.html

```html
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>User statistics</title>
		<style>
			body{background-color:#eee}
			.chart{max-width:820px;padding-right:20px;margin:20px auto;margin-bottom:40px; background-color:#fff; border-radius:12px;}
		</style>
	</head>
	<body>
		<div class="chart"><canvas id="totalUsersPerYearChart"></canvas></div>
		<div class="chart"><canvas id="totalUsersPerMonthChart"></canvas></div>
		<div class="chart"><canvas id="newUsersPerYearChart"></canvas></div>
		<div class="chart"><canvas id="newUsersPerMonthChart"></canvas></div>
		<div class="chart"><canvas id="userAgeChart"></canvas></div>
		<div class="chart"><canvas id="loginsPerYearChart"></canvas></div>
		<div class="chart"><canvas id="loginsPerMonthChart"></canvas></div>
		<div class="chart"><canvas id="abandonmentPerMonthChart"></canvas></div>
	</body>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<script>
		const data = JSON.parse('{{CHARTDATA}}');

// Total users per year chart--------------------------------------------------
		new Chart(document.getElementById('totalUsersPerYearChart'), {
			type: 'bar',
			data: {
				labels: data.totalUsersPerYearChart.labels,
				datasets: [{
					label: 'Unverified',
					data: data.totalUsersPerYearChart.unverifiedData,
					backgroundColor: 'rgba(255, 99, 132, 0.7)',
				},
				{
					label: 'Verified',
					data: data.totalUsersPerYearChart.verifiedData,
					backgroundColor: 'rgba(75, 192, 192, 0.7)',
				}]
			},
			options: getBarChartOptions('Total users per year', true)
		});

// Total users per month chart--------------------------------------------------
		new Chart(document.getElementById('totalUsersPerMonthChart'), {
			type: 'bar',
			data: {
				labels: data.totalUsersPerMonthChart.labels,
				datasets: [{
					label: 'Unverified',
					data: data.totalUsersPerMonthChart.unverifiedData,
					backgroundColor: 'rgba(255, 99, 132, 0.7)',
				},
				{
					label: 'Verified',
					data: data.totalUsersPerMonthChart.verifiedData,
					backgroundColor: 'rgba(75, 192, 192, 0.7)',
				}]
			},
			options: getBarChartOptions('Total users per month', true)
		});

// New users per year chart--------------------------------------------------
		new Chart(document.getElementById('newUsersPerYearChart'), {
			type: 'bar',
			data: {
				labels: data.newUsersPerYearChart.labels,
				datasets: [{
					label: 'Unverified',
					data: data.newUsersPerYearChart.unverifiedData,
					backgroundColor: 'rgba(255, 99, 132, 0.7)',
				},
				{
					label: 'Verified',
					data: data.newUsersPerYearChart.verifiedData,
					backgroundColor: 'rgba(75, 192, 192, 0.7)',
				}]
			},
			options: getBarChartOptions('New users per year', true)
		});

// New users per month chart--------------------------------------------------
		new Chart(document.getElementById('newUsersPerMonthChart'), {
			type: 'bar',
			data: {
				labels: data.newUsersPerMonthChart.labels,
				datasets: [{
					label: 'Unverified',
					data: data.newUsersPerMonthChart.unverifiedData,
					backgroundColor: 'rgba(255, 99, 132, 0.7)',
				},
				{
					label: 'Verified',
					data: data.newUsersPerMonthChart.verifiedData,
					backgroundColor: 'rgba(75, 192, 192, 0.7)',
				}]
			},
			options: getBarChartOptions('New users per month', true)
		});

// User age chart --------------------------------------------------
		new Chart(document.getElementById('userAgeChart'), {
			type: 'bar',
			data: {
				labels: data.userAgeChart.labels,
				datasets: [{
					label: 'Unverified',
					data: data.userAgeChart.unverifiedData,
					backgroundColor: 'rgba(255, 99, 132, 0.7)',
				},
				{
					label: 'Verified',
					data: data.userAgeChart.verifiedData,
					backgroundColor: 'rgba(75, 192, 192, 0.7)',
				}]
			},
			options: getBarChartOptions('Number of years since user registered', true)
		});

// Logins per year chart --------------------------------------------------
		new Chart(document.getElementById('loginsPerYearChart'), {
			type: 'bar',
			data: {
				labels: data.loginsPerYearChart.labels,
				datasets: [{
					data: data.loginsPerYearChart.data,
					backgroundColor: 'rgba(75, 192, 192, 0.7)',
				}]
			},
			options: getBarChartOptions('Logins per year', false, false)
		});

// Logins per month chart --------------------------------------------------
		new Chart(document.getElementById('loginsPerMonthChart'), {
			type: 'bar',
			data: {
				labels: data.loginsPerMonthChart.labels,
				datasets: [{
					data: data.loginsPerMonthChart.data,
					backgroundColor: 'rgba(75, 192, 192, 0.7)',
				}]
			},
			options: getBarChartOptions('Logins per month', false, false)
		});

// Abandonment per month chart --------------------------------------------------
		new Chart(document.getElementById('abandonmentPerMonthChart'), {
			type: 'bar',
			data: {
				labels: data.abandonmentPerMonthChart.labels,
				datasets: [{
					data: data.abandonmentPerMonthChart.data,
					backgroundColor: 'rgba(75, 192, 192, 0.7)',
				}]
			},
			options: getBarChartOptions('Number of users who haven\'t logged in for months', false, false, 'Number of months')
		});


// Helper functions --------------------------------------------------
		function getBarChartOptions(title, isStackedBar=true, shouldShowLegend=true, xAxisTitle='') {
			return {
				responsive: true,
				plugins: {
					legend: {display: shouldShowLegend,position: 'bottom',},
					title: {display: true,text: title}
				},
				scales: {
					x: {
						grid: {display: false},
						stacked: isStackedBar,
						title: {display: true,text: xAxisTitle}
					},
					y: {
						stacked: isStackedBar,
						title: {display: true,text: ''},
						beginAtZero: true
					}
				}
			}
		}
	</script>
</html>
```

Run the code with the command below.

```sh
npm install express
node app.mjs
```

## Summary

## Appendix — How to create fake customer data in FA

To create an FA application with fake users and login data you need to run a JS and SQL script.

Create a file called `fake.mjs` containing the code below. It will register 10 000 new users when run.

```js
async function registerUsers(num) {
  for (let i = 1; i <= num; i++) {
    try {
      const response = await fetch('http://fa:9011/api/user/registration', {
        method: 'POST',
        headers: {
          Authorization: '33052c8a-c283-4e96-9d2a-eb1215c69f8f-not-for-prod',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          user: { email: `${i}@example.com`, password: 'password' },
          registration: { applicationId: 'e9fdb985-9173-4e01-9d73-ac2d60d1dc8e' }
        })
      });
      if (!response.ok) {
        const errorBody = await response.text();
        console.log(`httpError ${response.status} for user ${i}@example.com: ${errorBody}`);
        return;
      }
      const result = await response.json();
      console.log(JSON.stringify(result));
    } catch (error) {
      console.log(`networkError for user ${i}@example.com: ${(error).message}`);
    }
    console.log('');
  }
}

await registerUsers(10000);
```

Adjust the URL, authorization key, and application Id in the code above to match your FA instance. Then run the file with the command below.

```sh
node fake.mjs
```

If you don't have Node installed, or want to avoid running code directly on your computer, you can use Docker with the command below. (If you're running FA on your local machine, you need to put FA and the command on the same `--network`.)

```sh
docker run --init  -it --rm --name "app" -v ".:/app" -w "/app" --network faNetwork node:25-alpine sh -c  "node fake.mjs";
```

Once the users are created, you need randomize their registration dates, set 5% of user email addresses to unverified, and create thousands of login dates. This can't be done with the FA API, so you need to run SQL directly on the PostgreSQL FA database.

Run the SQL below.

```sql
-- randomize registration dates. a day from 2015 to 2025
UPDATE user_registrations SET insert_instant =
    EXTRACT(EPOCH FROM (
        '2015-01-01'::DATE + (FLOOR(('2025-12-31'::DATE - '2015-01-01'::DATE) * random()))::INT
    )::TIMESTAMP WITHOUT TIME ZONE)::BIGINT;

-- check dates if you want
-- SELECT * FROM user_registrations

-- set 5% users to unverified
UPDATE identities
SET verified = CASE
    WHEN random() < 0.05 THEN false
    ELSE true
END
WHERE identities.is_primary = true;

UPDATE identities
SET verified_reason = 5
WHERE identities.is_primary = true;

-- add login dates
WITH user_min_instant AS (
    SELECT
        user_registrations.users_id,
        MIN(user_registrations.insert_instant) AS minInstant
    FROM
        user_registrations
    GROUP BY
        user_registrations.users_id
),
users_with_series AS (
    SELECT
        users.id AS usersId,
        user_min_instant.minInstant,
        generate_series(1, (1 + floor(random() * 4991))::INTEGER) AS seriesNum -- 10 to 5000 logins
    FROM
        users
    JOIN
        user_min_instant ON users.id = user_min_instant.users_id
)
INSERT INTO raw_logins (applications_id, instant, ip_address, identities_value, identities_type, users_id)
SELECT
    'e9fdb985-9173-4e01-9d73-ac2d60d1dc8e',
    (users_with_series.minInstant + FLOOR(
        (EXTRACT(EPOCH FROM '2026-01-01 00:00:00Z'::timestamp) - users_with_series.minInstant) * random()
    ))::BIGINT,
    '127.0.0.1',
    NULL,
    NULL,
    users_with_series.usersId
FROM
    users_with_series;

-- delete logins for unverified users
delete from raw_logins
where users_id in (select users_id from identities WHERE is_primary=true and verified=false)
```

## todo

use 10 000 users
copy in correct sql date creation code into article.
fa

https://github.com/FusionAuth/fusionauth-site/issues/2990 - cohort analysis
