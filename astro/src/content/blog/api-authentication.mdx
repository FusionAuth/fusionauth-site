---
publish_date: 2024-01-10
title: Protecting Your APIs
description: What are ways you can authenticate requesters to protect APIs?
authors: Dan Moore
image: /img/blogs/api-authentication/protecting-apis.png
categories: Education
tags: apis, authentication, api keys, oauth, tokens
excerpt_separator: "{/* more */}"
---
import APIRequest from "../../diagrams/articles/security/api-authentication/api-request.astro";
import FailedAPIRequest from "../../diagrams/articles/security/api-authentication/failed-api-request.astro";
import Aside from '../../components/Aside.astro';


TODO fix diagrams

When you are building out web APIs for web applications, desktop apps or mobile applications to access functionality or data, you need to authenticate these requests. 

You may say to yourself "of course" but there have been incidents where APIs were not protected at relatively large or prominent organizations, including [LinkedIn and Parler](https://securityboulevard.com/2021/11/biggest-api-security-attacks-of-2021-so-far/).

There's an [OWASP API top 10](https://owasp.org/API-Security/editions/2023/en/0x11-t10/), and authentication is number two on the list.

Let's take a look at some considerations below.

{/* more */}

## What Is An API?

First, what is an API? API stands for Application Programming Interface and in the general sense is a way for one piece of software to communicate with another. The method of transport and the format of messages need to be defined, whether a C program is calling into a numeric processing library or a mobile application is requesting user data. 

Web APIs can take a lot of different forms, but a very common one nowadays has the following attributes:

* TLS and HTTP, including verbs, for the transport layer
* JSON and HTTP headers for the message formatting layer

An API has:

* an client, the software program making the request
* an API server, which holds the protected data or functionality
* an API key, a unique identifier for the client which can be validated by the API server
* a central authority which can issue API keys

I like examples, so throughout this post, you'll examine a hypothetical todo service run by Pied Piper, which allows users to create, update and delete todos. It'll have multiple client applications and an API which records these tasks. Users should be able to create and update their own tasks, but not those of others.

A web browser can make a `GET` request against an API server such as `https://todo.piedpiper.com/api/todo` to retrieve a list of todos for a certain user. The browser is a client and the server is at `todos.piedpiper.com`. An API key is held by the client and presented to the API server to authenticate the request. An API key needs to be HTTP safe and unique to a given user, but there are no other constraints.

<APIRequest alt="An API request." />

But how does the server know which user to get todos for when it receives a request? And how do you know that the requester is allowed to access them? After all, you need to deny random or malicious users access to those precious, precious tasks. If the API server knows the caller is Richard, it knows that the requester can read and write Richard's todos, but not Dinesh's.

<FailedAPIRequest alt="A failed API request." />

## What Are API Authentication Needs

To get access to data from an API, the user or software program needs to provide proof of who/what they are to get access to functionality and/or data. The API authentication mechanism should be:

* secure
* performant

The pre-eminent task any API authentication method must perform is to make sure that only the appropriate callers gets access to data or functionality. There are many aspects to this, including how the initial authentication is performed, looking for unexpected requests, and determining what access is requested and provided.

While you can rely on TLS for HTTP API requests to secure the API key in transit, you need to make sure the API key is secured both on the client and the API server.

API authentication methods must also be performant. While a secondary concern, if an API is not accessible due slow authentication of requests, the API is broken.

## API Protection Options

There are really three ways to protect an API.

* No authentication
* Centralized authentication, where validity is determined by the central authority
* Decentralized authentication, where the API server can determine API key validity

TODO define validity?

### Unprotected APIs

The first option is useful when you have a public API that offers the same data or functionality for all users. I once worked on an application that needed tremendous scale and it achieved it by publishing JSON formatted messages to Amazon S3, which were then ingested by JavaScript running on millions of browsers. This was a read-only API that had no authentication. Having no authentication simplifies everything and is a good option when it works.

Updating the data that this API served was done through a different process which was absolutely authenticated.

This approach is the exception rather than the rule. It only applies when client data access is read only and the data is the same for every client.

Far more often, especially if you are using APIs to let clients update data in the server or offering user specific functionality or data, you will need to perform some sort of authentication and authorization.

## Authentication And Authorization

Typically after you authenticate and know who the caller, you authorize the request. That lets the system know what access the caller has, or whether access should be denied entirely.

<Aside type="note" nodark="true">
Authentication is "who are you" and authorization is "what can you do". While they can be treated separately (car keys authorize without authenticating and a business card weakly authenticates without authorizing) they are usually considered together.
</Aside>

This can be done with a variety of mechanisms, including role-based access control (RBAC) but is typically embedded in business logic or extracted to an authorization server which controls access. 

For example, after a request to `todos.piedpiper.com/api/todos` with a proper API key, if the system knows the caller is Richard, it knows that the requester can read and write Richard's todos, but not Dinesh's. The API key doesn't necessarily contain information about what Richard can and can't do, but the API server consuming the API key needs to have an access control layer.

Each API is stateless because it is over HTTP. Because this system needs to support a variety of clients, browser-specific mechanisms like cookie sessions can't be relied on. This means that the API key should be presented every time.

## Centralized vs Decentralized Authentication and Authorization

Let's look at the differences between centralized and decentralized authentication and authorization for your API calls. Let's examine the hypothetical todo service run by Pied Piper, which again allows users to create, update and delete tasks. It'll have multiple client applications and an API which records these tasks. Users should be able to create and update their own tasks, but not those of others.

To simplify this process, assume that the client making request magically has obtained the appropriate API key from the central authority. In this system, there are also other API services too. There might be a service for sharing todos or summarizing them using an LLM. These will also require authentication.

So, to sum up, these are the important parts of the system:

* the client, which wants to display or add todos
* the todo API server, which holds the todos
* the API key, which authenticates the client to the todo API server
* the central authority, which determines API key validity
* the other API services, such as a sharing or summarization service

Let's look at centralized authentication first.

## Centralized Authentication

With centralized authentication, the central authority is consulted every time there is an API request. The client offers up the API key on every request to the API server, and the API server needs to in turn present the API key to the central authority. The central authority verifies the API key is valid using the value of the API key and contextual information about the request and requested resource.

TODO diagram showing validation

Now, a word about the central authority. It could be a database table, a separate in-memory service or a separate architectural component. Conceptually these are all the same, but of course performance and complexity are different for each of these solutions, as well as their ability to support different services.

There are tradeoffs with this approach. Revocation of an API key is easy, if a client should no longer have access. Every request is checked, so when a user should no longer be able to access their todos, the central authority updates an API key status or removes the API key from its datastore. Subsequent requests fail.

However, with this approach, the central authority is a chokepoint. Each service needs to verify every request. This means the central authority needs to meet high availability and performance requirements. As you add more services and more clients, the requirements become more stringent.

TODO hub and spoke or multiple requests

TODO stopped here

### Decentralized Authentication

With decentralized authentication, the central authority issues a signed token. These signed tokens use public key cryptography to allow an API server to validate an API key without communicating with the central authority every request. Instead, the signature of the API key is

TODO diagram

OAuth is a common implementation of decentralized authentication. To map the terms used above into OAuth jargon:

| Term used above | OAuth term |
| ---- | ---- | 
| client | client | 
| central authority | authorization server |
| api server | resource server |
| API key | access token |
| refresh API key | refresh token |

An API key in a decentralized system is often a JWT TODO link or other self contained token which can carry more information than a simple API key in a centralized system can.

TODO JWT image

That means you can include items like:

* the user identity
* who the API key is intended for
* who created the API key
* business specific data like the account level of the user

With decentralized authentication, you have less communication with the central authority and can leverage delivered data.

But the flip side is that revocation of the API key TODO link to revocation is more complex. This is why API keys in a decnetralized system have valid time windows built into them. Having those attributes means that no API key will ever be valid forever.

### Introspection

If you use introspection ([RFC 7662](https://datatracker.ietf.org/doc/html/rfc7662)), then you can make an OAuth server behave like the centralized scenario. Every time the API server receives a request, it can present the central authority with the API key.

The response is defined by the standard and a typical one will look like:

```json
{
  "active": true,
  "client_id": "l238j323ds-23ij4",
  "username": "jdoe",
  "scope": "read write dolphin",
  "sub": "Z5O3upPC88QrAjx00dis",
  "aud": "https://protected.example.net/resource",
  "iss": "https://server.example.com/",
  "exp": 1419356238,
  "iat": 1419350238,
  "extension_field": "twenty-seven"
}
```

However, make sure you understand what a valid response from the central authority means. The `active` attribute is the only required value. From the specification, `active` is a

> [b]oolean indicator of whether or not the presented token is currently active.  The specifics of a token's "active" state will vary depending on the implementation of the authorization server and the information it keeps about its tokens...

TODO diagram

## First Party vs Third Party APIs

Another key dimension to think about is first party vs third party APIs. In the example above, the todos client, the API and the central authority are all owned by example.com. This makes the API a first party API. The same entity controls access to the data.

But what if they want to build a platform, building a true ecosystem of todos based add-ons. As alluded to above, there are additional services which might make users' todo experiences more enjoyable. Some examples:

* an LLM based service to summarize todos
* a reminder service to read todo due dates and text you or email you when you have an upcoming task due
* an analytics service to give you monthly summaries of your accomplishments
* custom clients to add todos, so you don't have to use example.com's crufty interface

While these could be built by example.com, they could also be built by third party developers. In this case, you'd need to authenticate not just the API requester, but also give them varying levels of access. For example the custom client would need to read and write todos. The analytics service would only need read access.

These third party API clients hit a little different.

### Third Party API Requirements

You'll want to define coarse grained permissions. More importantly, you'll need the client to ask permission and the *user* to grant or withhold permissions. This will typically happen when the user installs or authorizes access for one of these third party solutions.

The OAuth solution is to use scopes. Reqeusted scopes are provided when the user first grants access to the third party application.

TODO diagram
user visits marketplace
user installs third party app
user bounces to central authority with scopes
user prompted for consent
user consents
user bounced back to third party app which stores api key
third party app makes request with API key

Again, when you are building out API schemes, you won't need to worry about third party APIs unless you are building a platform.

### Designing Scopes

Scope design is difficult to do upfront, but even more painful to retrofit. Since third party clients are building on top of these systems, updating or changing the scopes will be a long, drawn out process. So spend some time up front thinking about scopes.

You want them to be:

* cover a cohesive chunk of functionality
* be understandable to users
* have no overlap

One common way to design these is to break your APIs into chunks of functionality and then offer read and write permissions to each of these. So for our todo application, these scopes might make sense:

* todo-read: the permission to read and list todos
* todo-write: the permission to create and update todos

This is more of an art than a science.

## Wrapping Up

When you are exposing an API, you need to protect it. You should think about whether to use a centralized system or a decentralized system. You also may need to consider handling coarse grained permissions for third party API users.

