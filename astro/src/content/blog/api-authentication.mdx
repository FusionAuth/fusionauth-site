---
publish_date: 2024-01-10
title: Protecting Your APIs
description: What are ways you can authenticate requesters to protect APIs?
authors: Dan Moore
image: /img/blogs/api-authentication/protecting-apis.png
categories: Education
tags: apis, authentication, api keys, oauth, tokens
excerpt_separator: "{/* more */}"
---
import APIRequest from "../../diagrams/articles/security/api-authentication/api-request.astro";
import FailedAPIRequest from "../../diagrams/articles/security/api-authentication/failed-api-request.astro";
import Aside from '../../components/Aside.astro';


TODO fix diagrams

When you are building out web APIs for web applications, desktop apps or mobile applications to access functionality or data, you need to authenticate these requests. 

You may say to yourself "of course" but there have been incidents where APIs were not protected at relatively large or prominent organizations, including [LinkedIn and Parler](https://securityboulevard.com/2021/11/biggest-api-security-attacks-of-2021-so-far/).

There's an [OWASP API top 10](https://owasp.org/API-Security/editions/2023/en/0x11-t10/), and authentication is number two on the list.

Let's take a look at some considerations below.

{/* more */}

## What Is An API?

First, what is an API? API stands for Application Programming Interface and in the general sense is a way for one piece of software to communicate with another. The method of transport and the format of messages need to be defined, whether a C program is calling into a numeric processing library or a mobile application is requesting user data. 

Web APIs can take a lot of different forms, but a very common one nowadays has the following attributes:

* TLS and HTTP, including verbs, for the transport layer
* JSON and HTTP headers for the message formatting layer

An API has:

* an client, the software program making the request
* an API server, which holds the protected data or functionality
* an API key, a unique identifier for the client which can be validated by the API server
* a central authority which can issue API keys

I like examples, so throughout this post, you'll examine a hypothetical todo service run by Pied Piper, which allows users to create, update and delete todos. It'll have multiple client applications and an API which records these tasks. Users should be able to create and update their own tasks, but not those of others.

A web browser can make a `GET` request against an API server such as `https://todo.piedpiper.com/api/todo` to retrieve a list of todos for a certain user. The browser is a client and the server is at `todos.piedpiper.com`. An API key is held by the client and presented to the API server to authenticate the request. An API key needs to be HTTP safe and unique to a given user, but there are no other constraints.

<APIRequest alt="An API request." />

But how does the server know which user to get todos for when it receives a request? And how do you know that the requester is allowed to access them? After all, you need to deny random or malicious users access to those precious, precious tasks. If the API server knows the caller is Richard, it knows that the requester can read and write Richard's todos, but not Dinesh's.

<FailedAPIRequest alt="A failed API request." />

## What Are API Authentication Needs

To get access to data from an API, the user or software program needs to provide proof of who/what they are to get access to functionality and/or data. The API authentication mechanism should be:

* secure
* performant

The pre-eminent task any API authentication method must perform is to make sure that only the appropriate callers gets access to data or functionality. There are many aspects to this, including how the initial authentication is performed, looking for unexpected requests, and determining what access is requested and provided.

While you can rely on TLS for HTTP API requests to secure the API key in transit, you need to make sure the API key is secured both on the client and the API server.

API authentication methods must also be performant. While a secondary concern, if an API is not accessible due slow authentication of requests, the API is broken.

## API Protection Options

There are really three ways to protect an API.

* No authentication
* Centralized authentication, where validity is determined by the central authority
* Decentralized authentication, where the API server can determine API key validity

TODO define validity?

### Unprotected APIs

The first option is useful when you have a public API that offers the same data or functionality for all users. I once worked on an application that needed tremendous scale and it achieved it by publishing JSON formatted messages to Amazon S3, which were then ingested by JavaScript running on millions of browsers. This was a read-only API that had no authentication. Having no authentication simplifies everything and is a good option when it works.

Updating the data that this API served was done through a different process which was absolutely authenticated.

This approach is the exception rather than the rule. It only applies when client data access is read only and the data is the same for every client.

Far more often, especially if you are using APIs to let clients update data in the server or offering user specific functionality or data, you will need to perform some sort of authentication and authorization.

## Authentication And Authorization

Typically after you authenticate and know who the caller, you authorize the request. That lets the system know what access the caller has, or whether access should be denied entirely.

<Aside type="note" nodark="true">
Authentication is "who are you" and authorization is "what can you do". While they can be treated separately (car keys authorize without authenticating and a business card weakly authenticates without authorizing) they are usually considered together.
</Aside>

This can be done with a variety of mechanisms, including role-based access control (RBAC) but is typically embedded in business logic or extracted to an authorization server which controls access. 

For example, after a request to `todos.piedpiper.com/api/todos` with a proper API key, if the system knows the caller is Richard, it knows that the requester can read and write Richard's todos, but not Dinesh's. The API key doesn't necessarily contain information about what Richard can and can't do, but the API server consuming the API key needs to have an access control layer.

Each API is stateless because it is over HTTP. Because this system needs to support a variety of clients, browser-specific mechanisms like cookie sessions can't be relied on. This means that the API key should be presented every time.

## Centralized vs Decentralized Authentication and Authorization

Let's look at the differences between centralized and decentralized authentication and authorization for your API calls. Let's examine the hypothetical todo service run by Pied Piper, which again allows users to create, update and delete tasks. It'll have multiple client applications and an API which records these tasks. Users should be able to create and update their own tasks, but not those of others.

To simplify this process, assume that the client making request magically has obtained the appropriate API key from the central authority. In this system, there are also other API services too. There might be a service for sharing todos or summarizing them using an LLM. These will also require authentication.

So, to sum up, these are the important parts of the system:

* the client, which wants to display or add todos
* the todo API server, which holds the todos
* the API key, which authenticates the client to the todo API server
* the central authority, which determines API key validity
* the other API services, such as a sharing or summarization service

Let's look at centralized authentication first.

## Centralized Authentication

With centralized authentication, the central authority is consulted every time there is an API request. The client offers up the API key on every request to the API server, and the API server needs to in turn present the API key to the central authority. The central authority verifies the API key is valid using the value of the API key and contextual information about the request and requested resource.

TODO diagram showing validation

Now, a word about the central authority. It could be a database table, a separate in-memory service or a separate architectural component. Conceptually these are all the same, but of course performance and complexity are different for each of these solutions, as well as their ability to support different services.

There are tradeoffs with this approach. Revocation of an API key is easy, if a client should no longer have access. Every request is checked, so when a user should no longer be able to access their todos, the central authority updates an API key status or removes the API key from its datastore. Subsequent requests fail.

However, with this approach, the central authority is a chokepoint. Each service needs to verify every request. This means the central authority needs to meet high availability and performance requirements. As you add more services and more clients, the requirements become more stringent.

TODO hub and spoke or multiple requests

### Decentralized Authentication

With decentralized authentication, the central authority issues a signed token for use as an API key. These use public key cryptography to allow an API server to validate them without communicating with the central authority every request. They do this by validating the signature using a known public key, and then examining the content of the API key to make sure they are expected.

TODO diagram

OAuth is a common implementation of decentralized authentication. To map the terms used above into OAuth jargon:

| Term used above | OAuth term |
| ---- | ---- | 
| client | client | 
| central authority | authorization server |
| api server | resource server |
| API key | access token |

However, for clarity, this post will continue to use the same terms, such as API server, as before.

An API key in a decentralized system is often a JWT TODO link which can carry more information than a simple API key in a centralized system does.

TODO JWT image

This payload can be trusted because of the signature. The existence of the signature means that the API server can verify that the contents of the API key were not changed after it was created by the central authority.

An API key can include information like:

* the user identity
* who the API key is intended for
* who created the API key
* business specific data like the account level of the user

With decentralized authentication, you have far less communication with the central authority. Because of the signature integrity guarantees, you can use the payload to reduce network calls.

But the flip side of this decentralization is that revocation of the API key TODO link to revocation is more complex. To minimize the impact of revocation complexity, API keys in a decentralized system have time windows, which mean that no API key in a decentralized system will be valid forever.

### Introspection

As mentioned above, OAuth supports decentralized API authentication. However, if you use introspection ([RFC 7662](https://datatracker.ietf.org/doc/html/rfc7662)), then you can make use OAuth in a centralized scenario. 

With introspection, every time the API server receives a request, it presents the central authority with the API key. The central authoriy then responds with a valid/not valid response. The format of the response is defined by the RFC.

TODO introspection diagram

A typical response looks like:

```json
{
  "active": true,
  "client_id": "l238j323ds-23ij4",
  "username": "jdoe",
  "scope": "read write dolphin",
  "sub": "Z5O3upPC88QrAjx00dis",
  "aud": "https://protected.example.net/resource",
  "iss": "https://server.example.com/",
  "exp": 1419356238,
  "iat": 1419350238,
  "extension_field": "twenty-seven"
}
```

However, ensure you understand what a valid response from the central authority means. The `active` attribute is the only required value. From the specification, `active` is a:

> [b]oolean indicator of whether or not the presented token is currently active.  The specifics of a token's "active" state will vary depending on the implementation of the authorization server and the information it keeps about its tokens...

## First Party vs Third Party APIs

Another API authentication consideration is whether you are securing a first party or third party API. In the example above, the todos client, the API server and the central authority are all owned by piedpiper.com. This makes the todos API a first party API because the same entity controls access to the data.

But what if Pied Piper wants to build a platform to foster an ecosystem of todos based add-ons. There are additional services which will make users' todo experiences more enjoyable. Some examples include:

* an LLM based service to summarize todos
* a reminder service to read todo due dates and text or email a user about upcoming tasks
* an analytics service to give the user monthly summaries of their accomplishments
* custom clients to add todos, so you don't have to use piedpiper.com's interface

While these could be built by Pied Piper, if they open up a platform and provide the right incentives, Pied Piper can harness the creativity and energy of more developers than they could ever hope to hire. 

With the platform in mind, Pied Piper needs to authenticate not just the API requester, but also control thier access in a more sophsiticated way, based on the service's needs. The custom client would need to read and write todos. The analytics service would only need read access.

But third party API clients have even more specific authentication requirements.

### Third Party API Authentication Requirements

You'll want to define coarse grained permissions. More importantly, you'll need the client to ask permission and the *user* to grant or withhold permissions. That's right, these clients aren't granted access based on just what they are, but also on a user by user basis.

This particular access grant occurs when the user installs or authorizes access for a third party solution.

<Aside type="note" nodark="true">
It doesn't make sense for a first party API to ask for user permission to certain data or operations because the first party has access to all the data!
</Aside>

The OAuth solution to this problem is to use scopes to define the permissions required and to ask users to grant them. You can also use these concepts with a centralized API key solution. Let's dig into that standards based solution a bit more.

TODO diagram
user visits marketplace
user installs third party app
user bounces to central authority with scopes
user prompted for consent
user consents
user bounced back to third party app which stores api key
third party app makes request with API key

To follow the principal of least privilege and security best practices, the third party should ask for as few scopes as needed to perform its operations.

### Scope Validation

Scope validation takes place in a couple of different places and times.

Before a third party is granted access by the central authority to get API keys, the scopes it requests should be vetted. In the OAuth world, this is part of client registration.

When the third party service asks for access to a particular user's data, the user should be prompted to grant permission. 

This is critical for securing user data usage by third party applications. The presentation is controlled by the central authority, but should clearly lay out the ramifications of the data access to the end user. This is the users chance to disallow improper access to their data. For instance, if the analytics tool asks for todos write access, the request should be clear enough that the normal user will prohibit it. 

The central authority should also verify requested scopes. Since the scope request is under control of the third party client, a malicious or buggy client could modify the scope request. If the central authority receives a scope request that is not granted to the third party, it must disallow the request.

### Designing Scopes

Scope design is difficult to do when designing your APIs, but even more painful to retrofit. Since third party clients are building on top of the APIs you provide, updating or changing the scopes will be a long, drawn out process. Spend some time up front thinking about scopes. You want them to be:

* broad enough to cover a cohesive chunk of functionality
* narrow enough to be useful to control access (avoid `admin` scopes)
* be understandable to users
* have no overlap
* not be overbroad

You don't need to have scopes for every API endpoint. For example, there may be certain admin APIs which would only be usable by first party applications. In that case, exclude them from your scope definitions to remove the possibility they'd ever be granted to or requested by third party applications.

One common way to design scopes is to break your APIs into defined sections of functionality and offer read and write permissions to each area. For the Pied Piper todo application, scopes might be:

* `todo-read`: the permission to read and list todos
* `todo-write`: the permission to create and update todos

As more API functionality is built, different read and write scopes can be added. In addition, there might be scopes which allow for higher level access. This is more of an art than a science.

These scopes should be validated by the API server to check that the scope in the API token matches the requested operation.

## Wrapping Up

When you are exposing an API, you need to protect it.

You should think about whether to use a centralized system or a decentralized system. You also may need to consider handling coarse grained permissions for third party API users.

