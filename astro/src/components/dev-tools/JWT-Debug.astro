---
import Textarea from "../../components/Textarea.astro";
const token =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0ODUxNDA5ODQsImlhdCI6MTQ4NTEzNzM4NCwiaXNzIjoiYWNtZS5jb20iLCJzdWIiOiIyOWFjMGMxOC0wYjRhLTQyY2YtODJmYy0wM2Q1NzAzMThhMWQiLCJhcHBsaWNhdGlvbklkIjoiNzkxMDM3MzQtOTdhYi00ZDFhLWFmMzctZTAwNmQwNWQyOTUyIiwicm9sZXMiOltdfQ.Mp0Pcwsz5VECK11Kf2ZZNF_SMKu5CgBeLN9ZOP04kZo";
---
<div class="gap-y-6 grid md:grid-cols-2 gap-5 my-8">


<div id="encoded-textarea" class="row-span-2 relative">
  <span class="label text-sm absolute top-[-0.8em] left-[1ch] z-10 bg-white px-[2ch]">Token</span>
</div>

<div id="header-textarea" class="relative">
    <span class="label text-sm absolute top-[-0.8em] left-[1ch] z-10 bg-white px-[2ch]">Header</span>
</div>


<div id="payload-textarea" class="relative">
  <span class="label text-sm absolute top-[-0.8em] left-[1ch] z-10 bg-white px-[2ch]">Payload</span>
</div>
</div>


<script>
  "use strict";
  import { json } from "@codemirror/lang-json";
  import { MatchDecorator, ViewPlugin, Decoration } from "@codemirror/view";

  import { EditorView, basicSetup } from "codemirror";

  const token =
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0ODUxNDA5ODQsImlhdCI6MTQ4NTEzNzM4NCwiaXNzIjoiYWNtZS5jb20iLCJzdWIiOiIyOWFjMGMxOC0wYjRhLTQyY2YtODJmYy0wM2Q1NzAzMThhMWQiLCJhcHBsaWNhdGlvbklkIjoiNzkxMDM3MzQtOTdhYi00ZDFhLWFmMzctZTAwNmQwNWQyOTUyIiwicm9sZXMiOltdfQ.Mp0Pcwsz5VECK11Kf2ZZNF_SMKu5CgBeLN9ZOP04kZo";
  const { headers, payload } = decodeJwt(token);

  function decodeJwt(stringToDecode) {
    const s = stringToDecode.split(".");

    const headers = window.JSON.stringify(window.JSON.parse(window.atob(s[0])),null,2);
    const payload = window.JSON.stringify(window.JSON.parse(window.atob(s[1])), null, 2);

    return { payload, headers };
  }

  // Function to check if this change is applied via one of our programmatic shifts
  function isProgrammatic(transactions) {
    if (transactions.length == 0) return false;
    if (
      transactions.length > 0 &&
      typeof transactions[0].annotations[0].value !== "number"
    )
      return false;
    return true;
  }

  // Decorator for color coding the token
  const tokenDec = Decoration.mark({ class: "headerDec" }); // This adds a className to the text that matches the regex.

  const tokenDecorator = new MatchDecorator({
    regexp: /([^.]+)/g,
    decoration: (m) => tokenDec,
  });
const tokenColors = ViewPlugin.define(
  (view) => ({
    decorations: tokenDecorator.createDeco(view),
    update(u) {
      this.decorations = tokenDecorator.updateDeco(u, this.decorations);
    },
  }),
  {
    decorations: (v) => v.decorations,
  }
);

// Inits CodeMirror for Tokens
  const tokenEditor = new EditorView({
    parent: document.getElementById("encoded-textarea"),
    doc: token,

    extensions: [
      basicSetup,
      tokenColors,

      EditorView.lineWrapping,
      EditorView.updateListener.of((update) => {

        if (update.docChanged) {
          const programUpdated = isProgrammatic(update.transactions);
          if (!programUpdated) {
            const { headers, payload } = decodeJwt(update.state.doc.text[0]);

            headersEditor.dispatch({
              changes: {
                from: 0,
                to: headersEditor.state.doc.length,
                insert: headers,
              },
            });
            payloadEditor.dispatch({
              changes: {
                from: 0,
                to: payloadEditor.state.doc.length,
                insert: payload,
              },
            });
          }
        }
 
      }),
    ],
  });

  // Inits CodeMirror for Header

  const headersEditor = new EditorView({
    parent: document.getElementById("header-textarea"),
    doc: headers,

    extensions: [
      basicSetup,
      EditorView.lineWrapping,

      EditorView.updateListener.of((update) => {
        if (update.docChanged) {
          const programUpdated = isProgrammatic(update.transactions);
          if (!programUpdated) {
            const currentToken = tokenEditor.state.doc.text[0].split(".");
            const docText = update.state.doc.text.join("")
            const updatedHeader = window.btoa(docText);

            tokenEditor.dispatch({
              changes: {
                from: 0,
                to: tokenEditor.state.doc.length,
                insert: `${updatedHeader}.${currentToken[1]}`,
              },
            });
          }
        }
      }),
      json() /* ... */,
    ],
  });

  // Inits CodeMirror for Payload

  const payloadEditor = new EditorView({
    parent: document.getElementById("payload-textarea"),
    doc: payload,
    extensions: [
      basicSetup,
      EditorView.lineWrapping,

      EditorView.updateListener.of((update) => {
        if (update.docChanged) {
          const programUpdated = isProgrammatic(update.transactions);
          if (!programUpdated) {
            const docText = update.state.doc.text.join("")

            const currentToken = tokenEditor.state.doc.text[0].split(".");
            const updatedPayload = window.btoa(docText);

            tokenEditor.dispatch({
              changes: {
                from: 0,
                to: tokenEditor.state.doc.length,
                insert: `${currentToken[0]}.${updatedPayload}`,
              },
            });
          }
        }
      }),
      json() /* ... */,
    ],
  });

  // elements.forEach(element => {
  //   console.log(element)
  //   const view = new EditorView({
  //     parent: element,
  //     doc: token,
  //     extensions: [basicSetup /* ... */]

  //   })
  //   view.dispatch()
  // })

  // const view = new EditorView({
  //   parent: document.querySelector('.component'),
  // doc: 'test',
  //   extensions: [basicSetup /* ... */]
  // })

  // CodeMirror.defineMode('encoded-jwt', function() {
  //   return {
  //     token: function(stream, state) {
  //       if (stream.eatWhile(/[^.]/)) {
  //         if (state.position === 'header') {
  //           state.position = 'payload';
  //           return 'jwt-header';
  //         } else if (state.position === 'payload') {
  //           state.position = 'signature';
  //           return 'jwt-payload';
  //         } else {
  //           return 'jwt-signature';
  //         }
  //       }

  //       stream.next();
  //       return null;
  //     },
  //     startState: function() {
  //       return {
  //         position : 'header'
  //       };
  //     }
  //   };
  // });

  // class JWTDecoder {
  //   constructor() {
  //     this.encoded = document.getElementById('encoded-textarea');
  //     this.encoded.focus();
  //     this.jwtHeader = document.getElementById('header-textarea');
  //     this.jwtBody = document.getElementById('payload-textarea');

  //     this.encoedEditor = CodeMirror.fromTextArea(this.encoded, {
  //       autofocus: true,
  //       lineNumbers: true,
  //       lineWrapping: true,
  //       viewportMargin: 100,
  //       mode: 'encoded-jwt'
  //     });
  //     this.encoedEditor.setSize(null, 50);
  //     this.encoedEditor.on('keyup', event => this.#handleKeyUp(event));
  //     this.jwtHeaderEditor = CodeMirror.fromTextArea(this.jwtHeader, {
  //       autofocus: false,
  //       lineNumbers: true,
  //       lineWrapping: false,
  //       viewportMargin: 100,
  //       mode: 'javascript'
  //     });
  //     this.jwtHeaderEditor.setSize(null, 80);
  //     this.jwtHeaderEditor.on('keyup', event => this.#handleJSONKeyUp(event));

  //     this.jwtBodyEditor = CodeMirror.fromTextArea(this.jwtBody, {
  //       autofocus: false,
  //       lineNumbers: true,
  //       lineWrapping: false,
  //       viewportMargin: 100,
  //       mode: 'javascript'
  //     });
  //     this.jwtBodyEditor.setSize(null, 120);
  //     this.jwtBodyEditor.on('keyup', event => this.#handleJSONKeyUp(event));
  //     if (this.encoded.value) this.#handleKeyUp()

  //   }

  //   #handleJSONKeyUp() {
  //     var current = this.encoedEditor.getValue().split('.');
  //     // Do each part separately so that if we exception we can continue

  //     try {
  //       var headValue = this.jwtHeaderEditor.getValue();
  //       if (headValue === '') {
  //         current[0] = headValue;
  //       } else {
  //         var headStringified = JSON.stringify(JSON.parse(headValue));
  //         current[0] = window.btoa(headStringified).replace(/=/g, '');
  //       }
  //     } catch (error) {
  //       console.info(error);
  //       // Ignore
  //     }

  //     try {
  //       var bodyValue = this.jwtBodyEditor.getValue();
  //       if (bodyValue === '') {
  //         current[1] = bodyValue;
  //       } else {
  //         var bodyStringified = JSON.stringify(JSON.parse(bodyValue));
  //         current[1] = window.btoa(bodyStringified).replace(/=/g, '');
  //       }
  //     } catch (error) {
  //       console.info(error);
  //       // Ignore
  //     }

  //     this.encoedEditor.setValue(current.join('.'));
  //   }

  //   #handleKeyUp() {
  //     try {
  //       this.encoedEditor.setSize(null, this.encoded.nextElementSibling.querySelector('.CodeMirror-sizer').offsetHeight + 5);
  //       var s = this.encoedEditor.getValue().split('.');
  //       if (s.length > 0) {
  //         var header = JSON.parse(window.atob(s[0]));
  //         this.jwtHeaderEditor.setValue(JSON.stringify(header, null, 2));
  //         try {
  //           this.jwtHeaderEditor.setSize(null, this.jwtHeader.nextElementSibling.querySelector('.CodeMirror-sizer').offsetHeight + 5);
  //         } catch (error) {
  //           // Ignore
  //           console.log(error)
  //         }
  //       }

  //       if (s.length > 1) {
  //         var body = JSON.parse(window.atob(s[1]));
  //         this.jwtBodyEditor.setValue(JSON.stringify(body, null, 2));
  //         try {
  //           this.jwtBodyEditor.setSize(null, this.jwtBody.nextElementSibling.querySelector('.CodeMirror-sizer').offsetHeight + 5);
  //         } catch (error) {
  //           console.log(error)
  //         }
  //       }
  //     } catch (error) {
  //           console.log(error)
  //     }
  //   }

  // }

  // addEventListener('DOMContentLoaded', () => new JWTDecoder());
</script>

<style is:global>

#encoded-textarea {
    display: grid
  }
  .cm-editor {
    height: 100%;

    padding: .5rem;
    border: 1px solid #3e4e50;
    border-radius: 5px;
    background-color: white;
  }
  .cm-editor .cm-activeLine {
    background: transparent;
  }
  .cm-editor .cm-gutters.cm-gutters-before {
    display: none;
  }
  .headerDec:first-of-type {
    color: green;
  }
  .headerDec:nth-of-type(2) {
    color:blue
  }
    .headerDec:nth-of-type(3) {
    color:red
  }

</style>