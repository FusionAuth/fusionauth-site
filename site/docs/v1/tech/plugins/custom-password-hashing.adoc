---
layout: doc
title: Custom Password Hashing (Password Encryptors)
description: Learn how to write a FusionAuth plugin to implement a custom password hashing algorithm (also referred to a password encryptors)
redirect_from:
  - /docs/v1/tech/plugins/password-encryptors/
---

== Overview

There are times when you have a custom password hash that you want to import into FusionAuth. link:/docs/v1/tech/reference/password-encryptors/[FusionAuth supports a number of password hashing schemes] but you can write a custom plugin if you have hashed your passwords using a different scheme.

You can use your custom password hashing scheme going forward, or you can rehash your passwords. You'd use the former strategy if you wanted to use a strong, unsupported password hashing scheme such as Argon2. You'd use the latter strategy if you are migrating from a system with a weaker hashing algorithm.

* <<Write the Password Encryptor Class>>
* <<Adding the Guice Bindings>>
* <<Writing a Unit Test>>
* <<Integration Test>>
* <<Sample Code>>
* <<Rehashing User Passwords>>

[NOTE]
====
This code uses the words 'encryption' and 'encryptor' for backwards compatibility, but what it is really doing is hashing the password.
====

=== Write the Password Encryptor Class

The main plugin interface in FusionAuth is the Password Encryptors interface. This allows you to write a custom password hashing scheme. A custom password hashing scheme is useful when you import users from an existing database into FusionAuth so that the users don't need to reset their passwords to login into your applications.

To write a Password Encryptor, you must first implement the io.fusionauth.plugin.spi.security.PasswordEncryptor interface. Here's an example of a simple Password Encryptor. This implementation reverses the password.

[WARNING]
====
DO NOT use this password hashing scheme in a production environment!
====

[source,java]
.Password Encryptor
----
package com.mycompany.fusionauth.plugins;

import io.fusionauth.plugin.spi.security.PasswordEncryptor;

/**
 * Super strong hashing that reverses the password. DO NOT USE IN PRODUCTION!
 */
public class ReversePasswordEncryptor implements PasswordEncryptor {
  @Override
  public int defaultFactor() {
    return 1;
  }

  @Override
  public String encrypt(String password, String salt, int factor) {
    return new StringBuilder(password).reverse().toString();
  }
}
----

=== Adding the Guice Bindings

To complete the main plugin code (before we write a unit test), you need to add Guice binding for your new Password Encryptor. Password Encryptors use Guice Multibindings via Map. Here is an example of binding our new Password Encryptor so that FusionAuth can use it for users.

[source,java]
.Guice Module
----
package com.mycompany.fusionauth.plugins.guice;

import com.google.inject.AbstractModule;
import com.google.inject.multibindings.MapBinder;
import io.fusionauth.plugin.spi.PluginModule;
import io.fusionauth.plugin.spi.security.PasswordEncryptor;
import com.mycompany.fusionauth.plugins.ReversePasswordEncryptor;

/**
 * A cool FusionAuth plugin module (plus a Password Encryptor).
 */
@PluginModule
public class MyCompanyFusionAuthPluginsModule extends AbstractModule {
  @Override
  protected void configure() {
    MapBinder<String, PasswordEncryptor> passwordEncryptorMapBinder = MapBinder.newMapBinder(binder(), String.class, PasswordEncryptor.class);
    passwordEncryptorMapBinder.addBinding("reverse").to(ReversePasswordEncryptor.class);
  }
}
----

You can see that we have bound the Password Encryptor under the name "reverse". This is the same name that you will use when creating users via the `/api/user` API.

=== Writing a Unit Test

You'll probably want to write some tests to ensure that your new Password Encryptor is working properly. Our example uses TestNG, but you can use JUnit or another framework if you prefer. Here's a simple unit test for our Password Encryptor:

[source,java]
.Unit Test
----
package com.mycompany.fusionauth.plugins;

import org.testng.annotations.Test;
import static org.testng.Assert.assertEquals;

/**
 * A simple unit test
 */
public class ReversePasswordEncryptorTest {
  @Test
  public void reverse() {
    ReversePasswordEncryptor reversePasswordEncryptor = new ReversePasswordEncryptor();
    assertEquals(reversePasswordEncryptor.encrypt("hello world", null), "dlrow olleh");
  }
}
----

If you are using our Savant build file, you can run this test by executing this command:

[source]
----
sb test
----

=== Integration Test

After you have completed your plugin, the unit test and installed the plugin into a running FusionAuth installation, you can test it by hitting the `/api/user` API and creating a test user. Here's an example JSON request that uses the new Password Encryptor:

[source,json]
----
{
  "user": {
    "id": "00000000-0000-0000-0000-000000000001",
    "active": true,
    "email": "test0@fusionauth.io",
    "encryptionScheme": "reverse",
    "password": "password",
    "username": "username0",
    "timezone": "Denver",
    "data": {
      "attr1": "value1",
      "attr2": ["value2", "value3"]
    },
    "preferredLanguages": ["en", "fr"],
    "registrations": [
      {
        "applicationId": "00000000-0000-0000-0000-000000000042",
        "data": {
          "attr3": "value3",
          "attr4": ["value4", "value5"]
        },
        "id": "00000000-0000-0000-0000-000000000003",
        "preferredLanguages": ["de"],
        "roles": ["role 1"],
        "username": "username0"
      }
    ]
  }
}
----

Notice that we've passed in the `encryptionScheme` property with a value of `reverse`. This will instruct FusionAuth to use your newly written Password Encryptor.

=== Sample Code

https://github.com/FusionAuth/fusionauth-example-password-encryptor[A sample plugin project is available]. If you are looking to write your own custom password hashing algorithm, this project is a good starting point.

=== Rehashing User Passwords

The purpose of writing a custom password hasher is to import users into FusionAuth using an existing hashing scheme. This allows you to seamlessly import your users without requiring them to change their password. The downside of this approach is that you now have preserved a hash which may be weak. FusionAuth will continue to use that hash unless you rehash users' passwords. 

To remedy this common situation, FusionAuth has the ability to rehash passwords on user login. Once enabled, during the next login event for a given user, FusionAuth will transparently rehash that user's password. The stronger, more secure hash will be used in the future for that user. 

To import users and transparently rehash their passwords, do the following:

* Write a custom password hasher.
* Import user passwords, setting the scheme for each user to the custom password hasher.
* Decide on the new hashing scheme you want to use.
* In the administrative user interface, navigate to [breadcrumb]#Tenants -> Your Tenant -> Password# and then to the [breadcrumb]#Cryptographic hash settings# section. Here you will configure both the new scheme and the rehash on login behavior.
* Configure the tenant to use the new hashing scheme by selecting it. You may use one of the standard hashing schemes or a different custom scheme. This will be used for all new users in this tenant as well.
* Configure the tenant to rehash on login by checking the [field]#Re-hash on login# checkbox.
* Save the tenant configuration.

image::plugins/rehashing-passwords-on-login.png[Tenant settings for rehashing passwords on login,width=1200,role=top-cropped]

After you have enabled this, when a user logs in, the password they provide will be transparently rehashed and they will use the stronger scheme in the future.
